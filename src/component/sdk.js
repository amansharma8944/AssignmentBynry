var classDetailMap = {
    "BluePrint.Model.BluePrint": {
      processInfo: {
        lookup: !0,
        structure_name: "BluePrint.Model.ProcessInfo",
        name: "process_info",
        type: "BluePrint.Model.ProcessInfo",
      },
      data: {
        structure_name: "Record.Model.Record",
        "required-in-update": !0,
        "skip-mandatory": !0,
        name: "data",
        type: "Record.Model.Record",
      },
      transitionId: {
        "required-in-update": !0,
        name: "transition_id",
        type: "Long",
      },
      transitions: {
        lookup: !0,
        structure_name: "BluePrint.Model.Transition",
        name: "transitions",
        type: "List",
      },
    },
    "Tag.Model.Info": {
      count: { name: "count", type: "Integer" },
      allowedCount: { name: "allowed_count", type: "Integer" },
    },
    "Notification.Model.GetNotificationDetailsParam": {
      perPage: { name: "per_page", type: "Integer" },
      module: { name: "module", type: "String" },
      page: { name: "page", type: "Integer" },
      channelId: { name: "channel_id", type: "Long" },
    },
    "Record.Model.UpsertRecordsHeader": {
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "Territory.Model.APIException": {
      code: {
        values: [
          "OAUTH_SCOPE_MISMATCH",
          "INTERNAL_ERROR",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_DATA",
          "CURRENCIES_NOT_ENABLED",
          "FEATURE_NOT_SUPPORTED",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: { name: "details", type: "Map" },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Function.Model.ExecuteFunctionUsingRequestBodyHeader": {
      customFunctionsHeader: { name: "custom_functions_header", type: "Map" },
    },
    "Record.Model.PricingDetails": {
      discount: { name: "discount", type: "Double", required: !0 },
      toRange: { name: "to_range", type: "Double", required: !0 },
      fromRange: { name: "from_range", type: "Double", required: !0 },
    },
    "Notification.Model.BodyWrapper": {
      watch: {
        structure_name: "Notification.Model.Notification",
        name: "watch",
        "max-length": 100,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "Record.Model.Record": {
      modifiedTime: { name: "Modified_Time", type: "DateTime" },
      createdBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "Created_By",
        type: "User.Model.User",
      },
      createdTime: { name: "Created_Time", type: "DateTime" },
      modifiedBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "Modified_By",
        type: "User.Model.User",
      },
      id: { name: "id", type: "Long", primary: !0 },
      tag: {
        structure_name: "Tag.Model.Tag",
        "skip-mandatory": !0,
        name: "Tag",
        type: "List",
      },
    },
    "Record.Model.GetMassUpdateStatusParam": {
      jobId: { name: "job_id", type: "String" },
    },
    "Notification.Model.Notification": {
      resourceId: { name: "resource_id", type: "String" },
      deleteevents: { name: "_delete_events", type: "Boolean" },
      notifyOnRelatedAction: {
        name: "notify_on_related_action",
        type: "Boolean",
      },
      notifyUrl: { name: "notify_url", type: "String", required: !0 },
      resourceName: { name: "resource_name", type: "String" },
      resourceUri: { name: "resource_uri", type: "String" },
      channelExpiry: { name: "channel_expiry", type: "DateTime" },
      fields: { name: "fields", type: "Map" },
      channelId: {
        name: "channel_id",
        type: "Long",
        required: !0,
        primary: !0,
      },
      events: {
        "required-in-update": !0,
        name: "events",
        type: "List",
        required: !0,
      },
      token: {
        name: "token",
        "max-length": 50,
        type: "String",
        "min-length": 1,
      },
    },
    "Note.Model.ResponseHandler": {
      classes: ["Note.Model.APIException", "Note.Model.ResponseWrapper"],
      interface: !0,
    },
    "RelatedList.Model.ResponseHandler": {
      classes: [
        "RelatedList.Model.ResponseWrapper",
        "RelatedList.Model.APIException",
      ],
      interface: !0,
    },
    "BulkRead.Model.APIException": {
      code: {
        values: [
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_SERVICE_NAME",
          "INVALID_BULK_OPERATION",
          "RESOURCE_NOT_FOUND",
          "MEDIA_TYPE_NOT_SUPPORTED",
          "REQUEST_BODY_NOT_READABLE",
          "REQUEST_BODY_IS_EMPTY",
          "MODULE_NOT_AVAILABLE",
          "NOT_SUPPORTED_FEATURE",
          "NO_PERMISSION",
          "MODULE_NOT_SUPPORTED",
          "JOB_NOT_SUPPORTED",
          "QUERY_NOT_SUPPORTED",
          "INVALID_CALLBACK_URL",
          "INVALID_CALLBACK_METHOD",
          "JOIN_LIMIT_EXCEEDED",
          "CRITERIA_NOT_SUPPORTED",
          "INVALID_CRITERIA",
          "AMBIGUOUS_CRITERIA",
          "AMBIGUOUS_GROUP_IN_CRITERIA",
          "CRITERIA_LIMIT_EXCEEDED",
          "FIELD_IN_CRITERIA_NOT_SUPPORTED",
          "FIELD_AND_COMPARATOR_IN_CRITERIA_NOT_COMPATIBLE",
          "FIELD_IN_CRITERIA_NOT_AVAILABLE",
          "FIELD_COMPARATOR_IN_CRITERIA_NOT_SUPPORTED",
          "VALUE_IN_CRITERIA_NOT_SUPPORTED",
          "FIELD_AND_VALUE_IN_CRITERIA_NOT_COMPATIBLE",
          "COMPARATOR_AND_VALUE_IN_CRITERIA_NOT_COMPATIBLE",
          "COMPARATOR_AND_ENCRYPTED_VALUE_IN_CRITERIA_NOT_COMPATIBLE",
          "GROUP_OPERATOR_NOT_SUPPORTED",
          "FIELD_NOT_AVAILABLE",
          "FIELD_NOT_SUPPORTED",
          "VALUE_LIMIT_EXCEEDED_IN_CRITERIA",
          "PAGE_NOT_SUPPORTED",
          "PAGE_RANGE_EXCEEDED",
          "TOO_MANY_REQUESTS",
          "CALLBACK_FAILURE",
          "INTERNAL_SERVER_ERROR",
          "INTERNAL_ERROR",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "resource", type: "String" },
          { name: "message", type: "String" },
          { name: "expected_data_type", type: "String" },
          { name: "info_message", type: "String" },
          { name: "parent_api_name", type: "String" },
          { name: "comparator", type: "String" },
          { name: "value", type: "String" },
          { name: "api_name", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "Provided service name %s is not valid/not supported",
          "Requested operation is an invalid bulk operation",
          "record not in process",
          "The requested resource doesn't exist.",
          "Media type is not supported.",
          "Unable to parse the request body.",
          "Request body is empty.",
          "Requested module '%s' is not available.",
          "Feature is not supported",
          " permission denied",
          "Invalid module for the query. Module '%s' is not supported.",
          "Invalid bulk %s job.",
          "Invalid query for bulk %s job. Query '%s' is not supported.",
          "Invalid URL '%s' for callback.",
          "Invalid request method %s for callback.",
          "Join limit exceeded for the query. Maximum number of joins supported in a query is %d",
          "Invalid criteria for the query. Criteria %s is not supported.",
          "Invalid criteria %s for the query.",
          "Ambiguous criteria %s. Criteria can have either {group",
          " group_operator} or {api_name",
          " comparator",
          " value}.",
          "Ambiguous group in criteria %s. Group should be used only when there are more than one criteria",
          "Number of criteria exceeded the maximum limit of %d",
          "Field api name '%s' for criteria %s is not supported.",
          "Field api name '%s' is not supported with comparator '%s' for criteria %s.",
          "Field api name '%s' is not available for criteria %s. Check visibility and permission for the field",
          "Field api name '%s' doesn't support this comparator '%s' for criteria %s.",
          "Value '%s' is not supported for criteria %s.",
          "Field '%s' is not supported with value '%s' for criteria %s.",
          "Comparator '%s' is not supported with value '%s' for criteria %s.",
          "Comparator '%s' is not supported with value '%s' for criteria %s as the value is encrypted.",
          "Criteria %s doesn't support this logical group operator '%s'. Supported operators are 'and'",
          " 'or'.",
          "Requested field api name '%s' is not available for the module '%s'. Check permission or visibility for the field.",
          "Invalid field for the module provided in fields. Field api name '%s' is not supported for this module '%s'.",
          "Value exceeded limit %d",
          "Invalid page number for query. Page %s is not supported for the query.",
          "Invalid page number for query. Page %s is not supported for the query. Page range is from %d to %d.",
          "Many requests fired in concurrent than the allowed limit",
          "Callback failed after %d attempts.",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "User.Model.CustomizeInfo": {
      bcView: { name: "bc_view", type: "String" },
      showDetailView: { name: "show_detail_view", type: "Boolean" },
      showHome: { name: "show_home", type: "Boolean" },
      showRightPanel: { name: "show_right_panel", type: "String" },
      notesDesc: { name: "notes_desc", type: "Boolean" },
      unpinRecentItem: { name: "unpin_recent_item", type: "String" },
    },
    "Function.Model.SuccessResponse": {
      code: { values: ["success"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [
          { name: "userMessage", type: "List" },
          { name: "output_type", type: "String" },
          { name: "id", type: "String" },
          { name: "output", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["function executed successfully"],
        name: "message",
        type: "util.Model.Choice",
      },
    },
    "Note.Model.Note": {
      owner: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "Owner",
        type: "User.Model.User",
      },
      modifiedTime: { name: "Modified_Time", type: "DateTime" },
      noteTitle: { name: "Note_Title", type: "String" },
      noteContent: { name: "Note_Content", type: "String", required: !0 },
      attachments: {
        lookup: !0,
        structure_name: "Attachment.Model.Attachment",
        name: "$attachments",
        type: "List",
      },
      voiceNote: { name: "$voice_note", type: "Boolean" },
      editable: { name: "$editable", type: "Boolean" },
      isSharedToClient: { name: "$is_shared_to_client", type: "Boolean" },
      parentId: {
        lookup: !0,
        structure_name: "Record.Model.Record",
        name: "Parent_Id",
        type: "Record.Model.Record",
        required: !0,
      },
      seModule: { name: "$se_module", type: "String", required: !0 },
      size: { name: "$size", type: "String" },
      createdBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "Created_By",
        type: "User.Model.User",
      },
      createdTime: { name: "Created_Time", type: "DateTime" },
      modifiedBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "Modified_By",
        type: "User.Model.User",
      },
      state: { name: "$state", type: "String" },
      id: { name: "id", type: "Long", primary: !0 },
    },
    "Layout.Model.GetLayoutsParam": {
      module: { name: "module", type: "String" },
    },
    "Record.Model.GetRecordsHeader": {
      IfModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "RelatedRecord.Model.GetRelatedRecordsUsingExternalIDHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
      IfModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
    },
    "Org.Model.APIException": {
      code: {
        values: [
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INTERNAL_ERROR",
          "INVALID_DATA",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: { name: "details", type: "Map" },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "The module name given seems to be invalid",
          "the request does not contain any file",
          "invalid file type",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Tag.Model.GetRecordCountForTagParam": {
      module: { name: "module", type: "String", required: !0 },
    },
    "BluePrint.Model.ActionResponse": {
      classes: [
        "BluePrint.Model.SuccessResponse",
        "BluePrint.Model.APIException",
      ],
      interface: !0,
    },
    "Layout.Model.GetLayoutParam": {
      module: { name: "module", type: "String" },
    },
    "Tag.Model.CreateTagsParam": {
      module: { name: "module", type: "String", required: !0 },
    },
    "Query.Model.BodyWrapper": {
      selectQuery: { name: "select_query", type: "String", required: !0 },
    },
    "ContactRole.Model.DeleteContactRolesParam": {
      ids: { name: "ids", type: "String" },
    },
    "CustomView.Model.APIException": {
      code: {
        values: [
          "NO_PERMISSION",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "REQUIRED_PARAM_MISSING",
          "INVALID_MODULE",
          "INTERNAL_ERROR",
          "INVALID_DATA",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "permissions", type: "List" },
          { name: "expected_data_type", type: "String" },
          { name: "api_name", type: "String" },
          {
            structure_name: "CustomView.Model.Range",
            name: "range",
            type: "CustomView.Model.Range",
          },
          { name: "json_path", type: "String" },
          { name: "resource_path_index", type: "Integer" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "The module name given seems to be invalid",
          "The given module is not supported in API",
          "invalid data",
          "Invalid ID",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "RelatedRecord.Model.GetRelatedRecordsHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
      IfModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
    },
    "Org.Model.LicenseDetails": {
      paidType: { name: "paid_type", type: "String" },
      trialType: { name: "trial_type", type: "String" },
      paidExpiry: { name: "paid_expiry", type: "DateTime" },
      paid: { name: "paid", type: "Boolean" },
      usersLicensePurchased: { name: "users_license_purchased", type: "Long" },
      trialExpiry: { name: "trial_expiry", type: "String" },
    },
    "Module.Model.ResponseWrapper": {
      modules: {
        structure_name: "Module.Model.Module",
        name: "modules",
        type: "List",
      },
    },
    "Record.Model.Criteria": {
      comparator: {
        values: [
          "equal",
          "not_equal",
          "in",
          "not_in",
          "less_than",
          "less_equal",
          "greater_than",
          "greater_equal",
          "contains",
          "not_contains",
          "starts_with",
          "ends_with",
          "between",
          "not_between",
        ],
        name: "comparator",
        type: "util.Model.Choice",
      },
      groupOperator: {
        values: ["and", "or"],
        name: "group_operator",
        type: "util.Model.Choice",
      },
      field: { name: "field", type: "String" },
      value: { name: "value", type: "Object" },
      group: {
        lookup: !0,
        structure_name: "Record.Model.Criteria",
        name: "group",
        type: "List",
      },
    },
    "Notification.Model.ActionHandler": {
      classes: [
        "Notification.Model.APIException",
        "Notification.Model.ActionWrapper",
      ],
      interface: !0,
    },
    "Tax.Model.ActionWrapper": {
      taxes: {
        structure_name: "Tax.Model.ActionResponse",
        name: "taxes",
        type: "List",
      },
    },
    "ShareRecord.Model.ActionResponse": {
      classes: [
        "ShareRecord.Model.SuccessResponse",
        "ShareRecord.Model.APIException",
      ],
      interface: !0,
    },
    "Tag.Model.RecordActionWrapper": {
      lockedCount: { name: "locked_count", type: "Integer" },
      data: {
        structure_name: "Tag.Model.RecordActionResponse",
        name: "data",
        type: "List",
      },
      successCount: { name: "success_count", type: "String" },
      wfScheduler: { name: "wf_scheduler", type: "Boolean" },
    },
    "VariableGroup.Model.ResponseWrapper": {
      variableGroups: {
        structure_name: "VariableGroup.Model.VariableGroup",
        name: "variable_groups",
        type: "List",
      },
    },
    "User.Model.GetUsersParam": {
      perPage: { name: "per_page", type: "Integer" },
      page: { name: "page", type: "Integer" },
      type: { name: "type", type: "String", required: !0 },
    },
    "Record.Model.Info": {
      perPage: { name: "per_page", type: "Integer" },
      moreRecords: { name: "more_records", type: "Boolean" },
      count: { name: "count", type: "Integer" },
      page: { name: "page", type: "Integer" },
    },
    "Field.Model.ResponseWrapper": {
      fields: {
        structure_name: "Field.Model.Field",
        name: "fields",
        type: "List",
      },
    },
    "ContactRole.Model.ContactRole": {
      sequenceNumber: { name: "sequence_number", type: "Integer" },
      name: { unique: !0, name: "name", type: "String", required: !0 },
      id: { name: "id", type: "Long", primary: !0 },
    },
    "BulkRead.Model.JobDetail": {
      result: {
        structure_name: "BulkRead.Model.Result",
        name: "result",
        type: "BulkRead.Model.Result",
      },
      createdBy: {
        structure_name: "User.Model.User",
        name: "created_by",
        type: "User.Model.User",
      },
      query: {
        structure_name: "BulkRead.Model.Query",
        name: "query",
        type: "BulkRead.Model.Query",
      },
      createdTime: { name: "created_time", type: "DateTime" },
      id: { name: "id", type: "Long", primary: !0 },
      state: {
        values: ["COMPLETED", "IN PROGRESS", "ADDED", "FAILURE"],
        name: "state",
        type: "util.Model.Choice",
      },
      operation: { name: "operation", type: "String" },
      fileType: { name: "file_type", type: "String" },
    },
    "Note.Model.ActionHandler": {
      classes: ["Note.Model.ActionWrapper", "Note.Model.APIException"],
      interface: !0,
    },
    "Module.Model.ActionWrapper": {
      modules: {
        structure_name: "Module.Model.ActionResponse",
        name: "modules",
        type: "List",
      },
    },
    "User.Model.Territory": {
      manager: { name: "manager", type: "Boolean" },
      name: { name: "name", type: "String" },
      id: { name: "id", type: "Long" },
    },
    "Tag.Model.RecordActionHandler": {
      classes: ["Tag.Model.APIException", "Tag.Model.RecordActionWrapper"],
      interface: !0,
    },
    "ContactRole.Model.ContactRoleWrapper": {
      contactRole: {
        "required-in-update": !0,
        name: "Contact_Role",
        type: "String",
      },
    },
    "VariableGroup.Model.ResponseHandler": {
      classes: [
        "VariableGroup.Model.ResponseWrapper",
        "VariableGroup.Model.APIException",
      ],
      interface: !0,
    },
    "Module.Model.ResponseHandler": {
      classes: ["Module.Model.APIException", "Module.Model.ResponseWrapper"],
      interface: !0,
    },
    "Field.Model.GetFieldsParam": {
      module: { name: "module", type: "String" },
      type: { name: "type", type: "String" },
    },
    "BulkWrite.Model.APIException": {
      code: {
        values: [
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "FILE_TOO_LARGE",
          "INVALID_FILE_FORMAT",
          "MANDATORY_FIELDS_NOT_MAPPED",
          "MANDATORY_NOT_FOUND",
          "INVALID_FIELD",
          "INVALID_FORMAT",
          "INVALID_FILE_ID",
          "HEADER_LIMIT_EXCEEDED",
          "COLUMN_INDEX_NOT_FOUND",
          "MODULE_NOT_AVAILABLE",
          "INVALID_DATA",
          "DUPLICATE_DATA",
          "NOT_APPROVED",
          "BLOCKED_RECORD",
          "CANNOT_PROCESS",
          "LIMIT_EXCEEDED",
          "RESOURCE_NOT_FOUND",
          "MISSING_REQUIRED_KEY",
          "INVALID_FIELD_NAME",
          "FILE_NOT_SUPPORTED",
          "INTERNAL_ERROR",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      xError: {
        values: ["check if headers [feature:X-CRM-ORG] are present and valid"],
        name: "x-error",
        type: "util.Model.Choice",
      },
      httpStatus: { name: "http_status", type: "String" },
      errorMessage: {
        values: ["Bad Request"],
        name: "ERROR_MESSAGE",
        type: "util.Model.Choice",
      },
      errorCode: { name: "ERROR_CODE", type: "Integer" },
      details: { name: "details", type: "Map" },
      xInfo: {
        values: ["Link not valid"],
        name: "x-info",
        type: "util.Model.Choice",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "invalid file format. only zip format is supported",
          "File size too large to process",
          "The requested resource doesn't exist.",
          "required key operation is not found in request body.",
          "improper file id",
          "required key index for field Company is not found in request body.",
          "All mandatory fields are not mapped for the layout",
          "Requested module 'asdf' is not available.",
          "invalid mapping. invalid api_name ast_Name.",
          "File not supported for bulk write",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
      info: { values: ["Forbidden"], name: "info", type: "util.Model.Choice" },
    },
    "RelatedRecord.Model.GetRelatedRecordsParam": {
      perPage: { name: "per_page", type: "Integer" },
      page: { name: "page", type: "Integer" },
    },
    "User.Model.User": {
      country: { name: "country", type: "String" },
      lastName: { name: "last_name", type: "String", required: !0 },
      role: {
        lookup: !0,
        structure_name: "Role.Model.Role",
        name: "role",
        type: "Role.Model.Role",
        required: !0,
      },
      decimalSeparator: { name: "decimal_separator", type: "String" },
      signature: { name: "signature", type: "String" },
      city: { name: "city", type: "String" },
      dateFormat: { name: "date_format", type: "String" },
      language: { name: "language", type: "String" },
      countryLocale: { name: "country_locale", type: "String" },
      locale: { name: "locale", type: "String" },
      microsoft: { name: "microsoft", type: "Boolean" },
      isonline: { name: "Isonline", type: "Boolean" },
      nameFormat: { name: "name_format", type: "String" },
      street: { name: "street", type: "String" },
      alias: { name: "alias", type: "String" },
      currency: { name: "Currency", type: "String" },
      theme: {
        lookup: !0,
        structure_name: "User.Model.Theme",
        name: "theme",
        type: "User.Model.Theme",
      },
      personalAccount: { name: "personal_account", type: "Boolean" },
      state: { name: "state", type: "String" },
      fax: { name: "fax", type: "String" },
      email: { name: "email", type: "String", required: !0 },
      reportingTo: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "Reporting_To",
        type: "User.Model.User",
      },
      zip: { name: "zip", type: "String" },
      website: { name: "website", type: "String" },
      offset: { name: "offset", type: "Long" },
      profile: {
        lookup: !0,
        structure_name: "Profile.Model.Profile",
        name: "profile",
        type: "Profile.Model.Profile",
        required: !0,
      },
      mobile: { name: "mobile", type: "String" },
      timeZone: { name: "time_zone", type: "String" },
      fullName: { name: "full_name", type: "String" },
      customizeInfo: {
        lookup: !0,
        structure_name: "User.Model.CustomizeInfo",
        name: "customize_info",
        type: "User.Model.CustomizeInfo",
      },
      zuid: { name: "zuid", type: "String" },
      confirm: { name: "confirm", type: "Boolean" },
      firstName: { name: "first_name", type: "String" },
      territories: {
        lookup: !0,
        structure_name: "User.Model.Territory",
        name: "territories",
        type: "List",
      },
      phone: { name: "phone", type: "String" },
      dob: { name: "dob", type: "String" },
      timeFormat: { name: "time_format", type: "String" },
      name: { name: "name", type: "String" },
      defaultTabGroup: { name: "default_tab_group", type: "String" },
      status: { name: "status", type: "String" },
    },
    "Record.Model.DownloadHandler": {
      classes: ["Record.Model.APIException", "Record.Model.FileBodyWrapper"],
      interface: !0,
    },
    "util.Model.Model": {
      classes: [
        "Attachment.Model.SuccessResponse",
        "Attachment.Model.APIException",
        "Attachment.Model.Attachment",
        "Attachment.Model.ActionWrapper",
        "Attachment.Model.ResponseWrapper",
        "Attachment.Model.FileBodyWrapper",
        "Note.Model.ActionWrapper",
        "Note.Model.SuccessResponse",
        "Note.Model.BodyWrapper",
        "Note.Model.APIException",
        "Note.Model.Info",
        "Note.Model.ResponseWrapper",
        "Note.Model.Note",
        "Function.Model.APIException",
        "Function.Model.BodyWrapper",
        "Function.Model.FileBodyWrapper",
        "Function.Model.SuccessResponse",
        "Role.Model.Role",
        "Role.Model.APIException",
        "Role.Model.ResponseWrapper",
        "RelatedList.Model.ResponseWrapper",
        "RelatedList.Model.RelatedList",
        "RelatedList.Model.APIException",
        "Tax.Model.Preference",
        "Tax.Model.ActionWrapper",
        "Tax.Model.SuccessResponse",
        "Tax.Model.APIException",
        "Tax.Model.ResponseWrapper",
        "Tax.Model.BodyWrapper",
        "Tax.Model.Tax",
        "Layout.Model.ResponseWrapper",
        "Layout.Model.Section",
        "Layout.Model.APIException",
        "Layout.Model.Properties",
        "Layout.Model.Layout",
        "BulkWrite.Model.CallBack",
        "BulkWrite.Model.SuccessResponse",
        "BulkWrite.Model.RequestWrapper",
        "BulkWrite.Model.APIException",
        "BulkWrite.Model.BulkWriteResponse",
        "BulkWrite.Model.File",
        "BulkWrite.Model.Resource",
        "BulkWrite.Model.FieldMapping",
        "BulkWrite.Model.FileBodyWrapper",
        "BulkWrite.Model.Result",
        "CustomView.Model.SharedDetails",
        "CustomView.Model.Translation",
        "CustomView.Model.ResponseWrapper",
        "CustomView.Model.Info",
        "CustomView.Model.CustomView",
        "CustomView.Model.Criteria",
        "CustomView.Model.Range",
        "CustomView.Model.APIException",
        "Notification.Model.SuccessResponse",
        "Notification.Model.Info",
        "Notification.Model.BodyWrapper",
        "Notification.Model.APIException",
        "Notification.Model.ActionWrapper",
        "Notification.Model.ResponseWrapper",
        "Notification.Model.Notification",
        "BluePrint.Model.Transition",
        "BluePrint.Model.BluePrint",
        "BluePrint.Model.SuccessResponse",
        "BluePrint.Model.BodyWrapper",
        "BluePrint.Model.NextTransition",
        "BluePrint.Model.ProcessInfo",
        "BluePrint.Model.ResponseWrapper",
        "BluePrint.Model.APIException",
        "BluePrint.Model.ValidationError",
        "File.Model.BodyWrapper",
        "File.Model.SuccessResponse",
        "File.Model.ActionWrapper",
        "File.Model.APIException",
        "File.Model.FileBodyWrapper",
        "Record.Model.ResponseWrapper",
        "Record.Model.Consent",
        "Record.Model.SuccessResponse",
        "Record.Model.ConvertActionWrapper",
        "Record.Model.MassUpdateBodyWrapper",
        "Record.Model.APIException",
        "Record.Model.Territory",
        "Record.Model.SuccessfulConvert",
        "Record.Model.LeadConverter",
        "Record.Model.BodyWrapper",
        "Record.Model.Criteria",
        "Record.Model.MassUpdateActionWrapper",
        "Record.Model.Info",
        "Record.Model.FileBodyWrapper",
        "Record.Model.InventoryLineItems",
        "Record.Model.MassUpdate",
        "Record.Model.ActionWrapper",
        "Record.Model.Record",
        "Record.Model.RemindAt",
        "Record.Model.Participants",
        "Record.Model.ConvertBodyWrapper",
        "Record.Model.MassUpdateResponseWrapper",
        "Record.Model.FileDetails",
        "Record.Model.Reminder",
        "Record.Model.DeletedRecordsWrapper",
        "Record.Model.DeletedRecord",
        "Record.Model.LineTax",
        "Record.Model.RecurringActivity",
        "Record.Model.LineItemProduct",
        "Record.Model.Comment",
        "Record.Model.CarryOverTags",
        "Record.Model.MassUpdateSuccessResponse",
        "Record.Model.PricingDetails",
        "RelatedRecord.Model.APIException",
        "RelatedRecord.Model.SuccessResponse",
        "RelatedRecord.Model.BodyWrapper",
        "RelatedRecord.Model.ActionWrapper",
        "RelatedRecord.Model.ResponseWrapper",
        "RelatedRecord.Model.FileBodyWrapper",
        "ShareRecord.Model.SuccessResponse",
        "ShareRecord.Model.SharedThrough",
        "ShareRecord.Model.APIException",
        "ShareRecord.Model.ResponseWrapper",
        "ShareRecord.Model.ShareRecord",
        "ShareRecord.Model.DeleteActionWrapper",
        "ShareRecord.Model.BodyWrapper",
        "ShareRecord.Model.ActionWrapper",
        "BulkRead.Model.Criteria",
        "BulkRead.Model.Query",
        "BulkRead.Model.RequestWrapper",
        "BulkRead.Model.SuccessResponse",
        "BulkRead.Model.JobDetail",
        "BulkRead.Model.Result",
        "BulkRead.Model.CallBack",
        "BulkRead.Model.ResponseWrapper",
        "BulkRead.Model.APIException",
        "BulkRead.Model.ActionWrapper",
        "BulkRead.Model.FileBodyWrapper",
        "Variable.Model.ResponseWrapper",
        "Variable.Model.BodyWrapper",
        "Variable.Model.APIException",
        "Variable.Model.Variable",
        "Variable.Model.SuccessResponse",
        "Variable.Model.ActionWrapper",
        "Org.Model.SuccessResponse",
        "Org.Model.ResponseWrapper",
        "Org.Model.Org",
        "Org.Model.LicenseDetails",
        "Org.Model.APIException",
        "Org.Model.FileBodyWrapper",
        "Query.Model.ResponseWrapper",
        "Query.Model.BodyWrapper",
        "Query.Model.APIException",
        "Profile.Model.APIException",
        "Profile.Model.Category",
        "Profile.Model.Profile",
        "Profile.Model.PermissionDetail",
        "Profile.Model.Section",
        "Profile.Model.ResponseWrapper",
        "User.Model.ActionWrapper",
        "User.Model.SuccessResponse",
        "User.Model.ResponseWrapper",
        "User.Model.Territory",
        "User.Model.CustomizeInfo",
        "User.Model.Theme",
        "User.Model.BodyWrapper",
        "User.Model.Info",
        "User.Model.Shift",
        "User.Model.RequestWrapper",
        "User.Model.User",
        "User.Model.APIException",
        "User.Model.TabTheme",
        "Module.Model.Module",
        "Module.Model.Territory",
        "Module.Model.APIException",
        "Module.Model.SuccessResponse",
        "Module.Model.ActionWrapper",
        "Module.Model.ResponseWrapper",
        "Module.Model.Argument",
        "Module.Model.RelatedListProperties",
        "Module.Model.BodyWrapper",
        "Tag.Model.MergeWrapper",
        "Tag.Model.ActionWrapper",
        "Tag.Model.BodyWrapper",
        "Tag.Model.ResponseWrapper",
        "Tag.Model.Tag",
        "Tag.Model.Info",
        "Tag.Model.SuccessResponse",
        "Tag.Model.APIException",
        "Tag.Model.RecordActionWrapper",
        "Tag.Model.CountWrapper",
        "Tag.Model.ConflictWrapper",
        "Territory.Model.Territory",
        "Territory.Model.APIException",
        "Territory.Model.ResponseWrapper",
        "ContactRole.Model.ResponseWrapper",
        "ContactRole.Model.SuccessResponse",
        "ContactRole.Model.RecordBodyWrapper",
        "ContactRole.Model.BodyWrapper",
        "ContactRole.Model.RecordActionWrapper",
        "ContactRole.Model.ContactRoleWrapper",
        "ContactRole.Model.RecordResponseWrapper",
        "ContactRole.Model.APIException",
        "ContactRole.Model.ActionWrapper",
        "ContactRole.Model.ContactRole",
        "Field.Model.RelatedDetails",
        "Field.Model.Field",
        "Field.Model.Unique",
        "Field.Model.Crypt",
        "Field.Model.ViewType",
        "Field.Model.AutoNumber",
        "Field.Model.MultiSelectLookup",
        "Field.Model.PickListValue",
        "Field.Model.ResponseWrapper",
        "Field.Model.ToolTip",
        "Field.Model.Currency",
        "Field.Model.Formula",
        "Field.Model.Private",
        "Field.Model.LookupField",
        "Field.Model.APIException",
        "Field.Model.Module",
        "Field.Model.AssociationDetails",
        "VariableGroup.Model.ResponseWrapper",
        "VariableGroup.Model.VariableGroup",
        "VariableGroup.Model.APIException",
        "Currency.Model.Currency",
        "Currency.Model.ResponseWrapper",
        "Currency.Model.SuccessResponse",
        "Currency.Model.BaseCurrencyWrapper",
        "Currency.Model.ActionWrapper",
        "Currency.Model.APIException",
        "Currency.Model.BodyWrapper",
        "Currency.Model.Format",
        "Currency.Model.BaseCurrencyActionWrapper",
      ],
      interface: !0,
    },
    "Tag.Model.UpdateTagsParam": {
      module: { name: "module", type: "String", required: !0 },
    },
    "Record.Model.MassUpdateBodyWrapper": {
      cvid: { name: "cvid", type: "String" },
      data: {
        structure_name: "Record.Model.Record",
        "skip-mandatory": !0,
        name: "data",
        type: "List",
        required: !0,
      },
      criteria: {
        structure_name: "Record.Model.Criteria",
        name: "criteria",
        type: "List",
      },
      ids: { name: "ids", type: "List" },
      territory: {
        structure_name: "Record.Model.Territory",
        name: "territory",
        type: "Record.Model.Territory",
      },
      overWrite: { name: "over_write", type: "Boolean" },
    },
    "File.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [
          { name: "name", type: "String" },
          { name: "id", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["uploaded Succeessfully"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "BluePrint.Model.Transition": {
      executionTime: { name: "execution_time", type: "DateTime" },
      criteriaMatched: { name: "criteria_matched", type: "Boolean" },
      percentPartialSave: { name: "percent_partial_save", type: "Double" },
      data: {
        structure_name: "Record.Model.Record",
        "skip-mandatory": !0,
        name: "data",
        type: "Record.Model.Record",
      },
      nextTransitions: {
        lookup: !0,
        structure_name: "BluePrint.Model.NextTransition",
        name: "next_transitions",
        type: "List",
      },
      name: { name: "name", type: "String" },
      criteriaMessage: { name: "criteria_message", type: "String" },
      nextFieldValue: { name: "next_field_value", type: "String" },
      id: { name: "id", type: "Long" },
      fields: {
        lookup: !0,
        structure_name: "Field.Model.Field",
        name: "fields",
        type: "List",
      },
      type: { name: "type", type: "String" },
    },
    "User.Model.GetUsersHeader": {
      IfModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
    },
    "Attachment.Model.ActionResponse": {
      classes: [
        "Attachment.Model.SuccessResponse",
        "Attachment.Model.APIException",
      ],
      interface: !0,
    },
    "Record.Model.Reminder": {
      period: { name: "period", type: "String", required: !0 },
      unit: { name: "unit", type: "String", required: !0 },
    },
    "Profile.Model.APIException": {
      code: {
        values: [
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INTERNAL_ERROR",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: { name: "details", type: "Map" },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "The module name given seems to be invalid",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "ContactRole.Model.BodyWrapper": {
      contactRoles: {
        structure_name: "ContactRole.Model.ContactRole",
        name: "contact_roles",
        "max-length": 100,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "Territory.Model.Territory": {
      modifiedTime: { name: "modified_time", type: "DateTime" },
      manager: {
        structure_name: "User.Model.User",
        name: "manager",
        type: "User.Model.User",
      },
      createdBy: {
        structure_name: "User.Model.User",
        name: "created_by",
        type: "User.Model.User",
      },
      criteria: {
        structure_name: "CustomView.Model.Criteria",
        name: "criteria",
        type: "CustomView.Model.Criteria",
      },
      name: { name: "name", type: "String" },
      createdTime: { name: "created_time", type: "DateTime" },
      description: { name: "description", type: "String" },
      modifiedBy: {
        structure_name: "User.Model.User",
        name: "modified_by",
        type: "User.Model.User",
      },
      id: { name: "id", type: "Long", primary: !0 },
      parentId: { name: "parent_id", type: "String" },
    },
    "RelatedRecord.Model.UpdateRelatedRecordHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
    },
    "Attachment.Model.APIException": {
      code: {
        values: [
          "NO_PERMISSION",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_DATA",
          "INTERNAL_ERROR",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "permissions", type: "List" },
          { name: "id", type: "Long" },
          { name: "resource_path_index", type: "Integer" },
          { name: "related_status", type: "String" },
          { name: "param_name", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "As it is a linked attachment",
          " you can not download it",
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "record not deleted",
          "the related id given seems to be invalid",
          "Attachment link already exists",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Attachment.Model.GetAttachmentsParam": {
      perPage: { name: "per_page", type: "Integer" },
      page: { name: "page", type: "Integer" },
      fields: { name: "fields", type: "String" },
    },
    "Profile.Model.Profile": {
      displayLabel: { name: "display_label", type: "String" },
      modifiedTime: { name: "modified_time", type: "DateTime" },
      permissionsDetails: {
        structure_name: "Profile.Model.PermissionDetail",
        name: "permissions_details",
        type: "List",
      },
      description: { name: "description", type: "String" },
      delete1: { name: "_delete", type: "Boolean" },
      sections: {
        structure_name: "Profile.Model.Section",
        name: "sections",
        type: "List",
      },
      createdBy: {
        structure_name: "User.Model.User",
        name: "created_by",
        type: "User.Model.User",
      },
      default1: { name: "default", type: "Boolean" },
      name: { name: "name", type: "String" },
      createdTime: { name: "created_time", type: "DateTime" },
      modifiedBy: {
        structure_name: "User.Model.User",
        name: "modified_by",
        type: "User.Model.User",
      },
      id: { name: "id", type: "Long", primary: !0 },
      category: { name: "category", type: "Boolean" },
    },
    "Tax.Model.ActionResponse": {
      classes: ["Tax.Model.SuccessResponse", "Tax.Model.APIException"],
      interface: !0,
    },
    "Note.Model.ResponseWrapper": {
      data: { structure_name: "Note.Model.Note", name: "data", type: "List" },
      info: {
        structure_name: "Note.Model.Info",
        name: "info",
        type: "Note.Model.Info",
      },
    },
    "BulkWrite.Model.ResponseHandler": {
      classes: [
        "BulkWrite.Model.APIException",
        "BulkWrite.Model.FileBodyWrapper",
      ],
      interface: !0,
    },
    "Tag.Model.RemoveTagsFromRecordParam": {
      tagNames: { name: "tag_names", type: "String", required: !0 },
    },
    "Variable.Model.ActionResponse": {
      classes: [
        "Variable.Model.APIException",
        "Variable.Model.SuccessResponse",
      ],
      interface: !0,
    },
    "Tax.Model.APIException": {
      code: {
        values: [
          "OAUTH_SCOPE_MISMATCH",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "MANDATORY_NOT_FOUND",
          "INVALID_DATA",
          "INTERNAL_ERROR",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "api_name", type: "String" },
          { name: "id", type: "Long" },
          { name: "name", type: "String" },
          { name: "value", type: "String" },
          { name: "maximum_length", type: "Integer" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "required field not found",
          "Sequence number out of range",
          "Sequence number cannot be repeated in same request",
          "Given ID does not exist",
          "tax not deleted",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "ShareRecord.Model.ResponseHandler": {
      classes: [
        "ShareRecord.Model.APIException",
        "ShareRecord.Model.ResponseWrapper",
      ],
      interface: !0,
    },
    "RelatedRecord.Model.UpdateRelatedRecordsHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
    },
    "Record.Model.MassUpdateResponse": {
      classes: ["Record.Model.APIException", "Record.Model.MassUpdate"],
      interface: !0,
    },
    "Profile.Model.GetProfilesHeader": {
      ifModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
    },
    "Variable.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [{ name: "id", type: "Long" }],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["variable added", "variable updated", "variable deleted"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Record.Model.MassUpdateActionHandler": {
      classes: [
        "Record.Model.APIException",
        "Record.Model.MassUpdateActionWrapper",
      ],
      interface: !0,
    },
    "ShareRecord.Model.DeleteActionHandler": {
      classes: [
        "ShareRecord.Model.APIException",
        "ShareRecord.Model.DeleteActionWrapper",
      ],
      interface: !0,
    },
    "BulkWrite.Model.ActionResponse": {
      classes: [
        "BulkWrite.Model.SuccessResponse",
        "BulkWrite.Model.APIException",
      ],
      interface: !0,
    },
    "RelatedList.Model.GetRelatedListParam": {
      module: { name: "module", type: "String" },
    },
    "Variable.Model.ActionWrapper": {
      variables: {
        structure_name: "Variable.Model.ActionResponse",
        name: "variables",
        type: "List",
        required: !0,
      },
    },
    "Layout.Model.ResponseHandler": {
      classes: ["Layout.Model.ResponseWrapper", "Layout.Model.APIException"],
      interface: !0,
    },
    "RelatedList.Model.ResponseWrapper": {
      relatedLists: {
        structure_name: "RelatedList.Model.RelatedList",
        name: "related_lists",
        type: "List",
      },
    },
    "User.Model.Shift": {
      name: { name: "name", type: "String" },
      id: { name: "id", type: "Long" },
    },
    "Record.Model.DeleteRecordHeader": {
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "Field.Model.AutoNumber": {
      startNumber: { name: "start_number", type: "Integer" },
      prefix: { name: "prefix", type: "String" },
      suffix: { name: "suffix", type: "String" },
    },
    "BluePrint.Model.NextTransition": {
      name: { name: "name", type: "String" },
      id: { name: "id", type: "Long" },
    },
    "Variable.Model.APIException": {
      code: {
        values: [
          "UNABLE_TO_PARSE_DATA_TYPE",
          "REQUIRED_PARAM_MISSING",
          "DUPLICATE_DATA",
          "INVALID_DATA",
          "OAUTH_SCOPE_MISMATCH",
          "INVALID_TOKEN",
          "INTERNAL_ERROR",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "param", type: "String" },
          { name: "api_name", type: "String" },
          { name: "id", type: "Long" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "either the request body or parameters is in wrong format",
          "One of the expected parameter is missing",
          "duplicate data",
          "variable not deleted",
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "BulkRead.Model.Result": {
      perPage: { name: "per_page", type: "Integer" },
      moreRecords: { name: "more_records", type: "Boolean" },
      count: { name: "count", type: "Integer" },
      downloadUrl: { name: "download_url", type: "String" },
      page: { name: "page", type: "Integer" },
    },
    "Function.Model.APIException": {
      code: {
        values: [
          "SERVICE_NOT_FOUND",
          "CONNECTION_TIMEOUT",
          "AUTHORIZATION_FAILED",
          "NO_PERMISSION",
          "INVALID_DATA",
          "MANDATORY_NOT_FOUND",
          "NO_PERMISSION",
          "FEATURE_NOT_AVAILABLE",
          "UNCONFIRMED_EMAIL",
          "PATTERN_NOT_MATCHED",
          "INVALID_DATA",
          "FUNCTION_NOT_CREATED",
          "FUNCTION_NOT_UPDATED",
          "FUNCTION_NOT_DELETED",
          "NO_PERMISSION",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "api_name", type: "String" },
          { name: "permissions", type: "List" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "service unavailable. please try after sometime",
          "unable to connect. please try after sometime",
          "unable to authorize your request.",
          "no permission to perform an action on this record",
          "your edition doesn't support this feature",
          "please confirm your email",
          "failed to update function",
          "unable to delete a configured function.",
          "permission denied",
          "invalid file type",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Tag.Model.RemoveTagsFromMultipleRecordsParam": {
      ids: { name: "ids", type: "Long", required: !0 },
      tagNames: { name: "tag_names", type: "String", required: !0 },
    },
    "Record.Model.Consent": {
      owner: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "Owner",
        type: "User.Model.User",
      },
      mailSentTime: { name: "Mail_Sent_Time", type: "DateTime" },
      consentThrough: { name: "Consent_Through", type: "String" },
      contactThroughSocial: { name: "Contact_Through_Social", type: "Boolean" },
      contactThroughPhone: { name: "Contact_Through_Phone", type: "Boolean" },
      contactThroughSurvey: { name: "Contact_Through_Survey", type: "Boolean" },
      consentDate: { name: "Consent_Date", type: "LocalDate" },
      dataProcessingBasis: { name: "Data_Processing_Basis", type: "String" },
      contactThroughEmail: { name: "Contact_Through_Email", type: "Boolean" },
      consentRemarks: { name: "Consent_Remarks", type: "String" },
    },
    "Layout.Model.APIException": {
      code: {
        values: [
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_MODULE",
          "REQUIRED_PARAM_MISSING",
          "INTERNAL_ERROR",
          "NO_PERMISSION",
          "INVALID_DATA",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: { name: "details", type: "Map" },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "User does not have permission to access this layout.",
          "Layout does not belongs to the given module",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Org.Model.ResponseHandler": {
      classes: ["Org.Model.ResponseWrapper", "Org.Model.APIException"],
      interface: !0,
    },
    "Record.Model.DeleteRecordsHeader": {
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "Module.Model.BodyWrapper": {
      modules: {
        structure_name: "Module.Model.Module",
        name: "modules",
        "max-length": 1,
        type: "List",
        "min-length": 1,
      },
    },
    "Note.Model.Info": {
      perPage: { name: "per_page", type: "Integer" },
      moreRecords: { name: "more_records", type: "Boolean" },
      count: { name: "count", type: "Integer" },
      page: { name: "page", type: "Integer" },
    },
    "Function.Model.ExecuteFunctionUsingFileParam": {
      uploadFileParam: { name: "upload_file_param", type: "Map" },
      arguments1: { name: "arguments", type: "Map" },
      authType: { name: "auth_type", type: "String" },
    },
    "Record.Model.RemindAt": {
      alarm: { name: "ALARM", type: "String", required: !0 },
    },
    "Record.Model.GetDeletedRecordsHeader": {
      IfModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
    },
    "BulkWrite.Model.Result": {
      downloadUrl: { name: "download_url", type: "String" },
    },
    "File.Model.ActionWrapper": {
      data: {
        structure_name: "File.Model.ActionResponse",
        name: "data",
        type: "List",
      },
    },
    "Tag.Model.ActionResponse": {
      classes: ["Tag.Model.SuccessResponse", "Tag.Model.APIException"],
      interface: !0,
    },
    "Variable.Model.DeleteVariablesParam": {
      ids: { name: "ids", type: "Long", required: !0 },
    },
    "Currency.Model.ResponseHandler": {
      classes: [
        "Currency.Model.ResponseWrapper",
        "Currency.Model.APIException",
      ],
      interface: !0,
    },
    "Record.Model.SuccessfulConvert": {
      deals: { name: "Deals", type: "String" },
      accounts: { name: "Accounts", type: "String" },
      contacts: { name: "Contacts", type: "String" },
    },
    "Record.Model.ConvertActionHandler": {
      classes: [
        "Record.Model.ConvertActionWrapper",
        "Record.Model.APIException",
      ],
      interface: !0,
    },
    "Record.Model.GetRecordHeader": {
      IfModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "Field.Model.ViewType": {
      view: { name: "view", type: "Boolean" },
      edit: { name: "edit", type: "Boolean" },
      quickCreate: { name: "quick_create", type: "Boolean" },
      create: { name: "create", type: "Boolean" },
    },
    "Tag.Model.APIException": {
      code: {
        values: [
          "REQUIRED_PARAM_MISSING",
          "MANDATORY_NOT_FOUND",
          "INVALID_MODULE",
          "DUPLICATE_DATA",
          "TAG_ID_NOT_FOUND",
          "FAILURE",
          "INTERNAL_ERROR",
          "NO_PERMISSION",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_DATA",
          "LICENSE_LIMIT_EXCEEDED",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "api_name", type: "String" },
          { name: "id", type: "Long" },
          { name: "param", type: "String" },
          { name: "permissions", type: "List" },
          { name: "maximum_length", type: "Integer" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "tags not found",
          "special characters found in the given name",
          "One of the expected parameter is missing",
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "record not deleted",
          "the related id given seems to be invalid",
          "Internal server error occurred.",
          "The relation name given seems to be invalid",
          "duplicate data",
          "tag edition limit exceeded",
          "invalid data",
          "tags not updated successfully",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Profile.Model.ResponseHandler": {
      classes: ["Profile.Model.APIException", "Profile.Model.ResponseWrapper"],
      interface: !0,
    },
    "RelatedRecord.Model.UpdateRelatedRecordUsingExternalIDHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
    },
    "File.Model.BodyWrapper": {
      file: {
        name: "file",
        "max-length": 10,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "Notification.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [
          {
            structure_name: "Notification.Model.Notification",
            name: "events",
            type: "List",
          },
          { name: "resource_uri", type: "String" },
          { name: "resource_id", type: "String" },
          { name: "channel_id", type: "Long" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "Successfully subscribed for actions-watch of the given module",
          "Successfully un-subscribed from actions-watch",
          "Successfully updated the subscribe details",
          "Successfully removed the subscribe details",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Tax.Model.ActionHandler": {
      classes: ["Tax.Model.ActionWrapper", "Tax.Model.APIException"],
      interface: !0,
    },
    "BulkWrite.Model.ResponseWrapper": {
      classes: [
        "BulkWrite.Model.APIException",
        "BulkWrite.Model.BulkWriteResponse",
      ],
      interface: !0,
    },
    "Field.Model.Formula": {
      expression: { name: "expression", type: "String" },
      returnType: { name: "return_type", type: "String" },
    },
    "BulkWrite.Model.RequestWrapper": {
      resource: {
        structure_name: "BulkWrite.Model.Resource",
        name: "resource",
        type: "List",
        required: !0,
      },
      callback: {
        structure_name: "BulkWrite.Model.CallBack",
        name: "callback",
        type: "BulkWrite.Model.CallBack",
      },
      characterEncoding: { name: "character_encoding", type: "String" },
      operation: {
        values: ["insert", "update", "upsert"],
        name: "operation",
        type: "util.Model.Choice",
        required: !0,
      },
    },
    "Tag.Model.AddTagsToMultipleRecordsParam": {
      ids: { name: "ids", type: "Long", required: !0 },
      tagNames: { name: "tag_names", type: "String", required: !0 },
      overWrite: { name: "over_write", type: "String" },
    },
    "Currency.Model.BaseCurrencyActionHandler": {
      classes: [
        "Currency.Model.APIException",
        "Currency.Model.BaseCurrencyActionWrapper",
      ],
      interface: !0,
    },
    "Profile.Model.GetProfileHeader": {
      ifModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
    },
    "ContactRole.Model.ActionHandler": {
      classes: [
        "ContactRole.Model.APIException",
        "ContactRole.Model.ActionWrapper",
      ],
      interface: !0,
    },
    "Currency.Model.BaseCurrencyActionWrapper": {
      baseCurrency: {
        structure_name: "Currency.Model.ActionResponse",
        name: "base_currency",
        interface: !0,
        type: "Currency.Model.ActionResponse",
      },
    },
    "Attachment.Model.ResponseWrapper": {
      data: {
        structure_name: "Attachment.Model.Attachment",
        name: "data",
        type: "List",
      },
      info: {
        structure_name: "Record.Model.Info",
        name: "info",
        type: "Record.Model.Info",
      },
    },
    "Tag.Model.UpdateTagParam": {
      module: { name: "module", type: "String", required: !0 },
    },
    "CustomView.Model.GetCustomViewsParam": {
      perPage: { name: "per_page", type: "Integer" },
      module: { name: "module", type: "String" },
      page: { name: "page", type: "Integer" },
    },
    "Record.Model.DeletedRecord": {
      createdBy: {
        structure_name: "User.Model.User",
        name: "created_by",
        type: "User.Model.User",
      },
      displayName: { name: "display_name", type: "String" },
      id: { name: "id", type: "Long", primary: !0 },
      type: { name: "type", type: "String" },
      deletedTime: { name: "deleted_time", type: "DateTime" },
      deletedBy: {
        structure_name: "User.Model.User",
        name: "deleted_by",
        type: "User.Model.User",
      },
    },
    "Currency.Model.ActionResponse": {
      classes: [
        "Currency.Model.SuccessResponse",
        "Currency.Model.APIException",
      ],
      interface: !0,
    },
    "Record.Model.DeleteRecordParam": {
      wfTrigger: { name: "wf_trigger", type: "Boolean" },
    },
    "Field.Model.MultiSelectLookup": {
      displayLabel: { name: "display_label", type: "String" },
      apiName: { name: "api_name", type: "String" },
      connectedlookupApiname: {
        name: "connectedlookup_apiname",
        type: "String",
      },
      lookupApiname: { name: "lookup_apiname", type: "String" },
      linkingModule: { name: "linking_module", type: "String" },
      id: { name: "id", type: "Long" },
    },
    "Record.Model.ConvertActionResponse": {
      classes: ["Record.Model.APIException", "Record.Model.SuccessfulConvert"],
      interface: !0,
    },
    "Record.Model.MassUpdateActionResponse": {
      classes: [
        "Record.Model.APIException",
        "Record.Model.MassUpdateSuccessResponse",
      ],
      interface: !0,
    },
    "Org.Model.ActionResponse": {
      classes: ["Org.Model.SuccessResponse", "Org.Model.APIException"],
      interface: !0,
    },
    "ShareRecord.Model.ActionWrapper": {
      share: {
        structure_name: "ShareRecord.Model.ActionResponse",
        name: "share",
        type: "List",
      },
    },
    "Function.Model.ExecuteFunctionUsingRequestBodyParam": {
      arguments1: { name: "arguments", type: "Map" },
      customFunctionsParam: { name: "custom_functions_param", type: "Map" },
      authType: { name: "auth_type", type: "String" },
    },
    "CustomView.Model.Info": {
      perPage: { name: "per_page", type: "Integer" },
      moreRecords: { name: "more_records", type: "Boolean" },
      default1: { name: "default", type: "String" },
      count: { name: "count", type: "Integer" },
      translation: {
        structure_name: "CustomView.Model.Translation",
        name: "translation",
        type: "CustomView.Model.Translation",
      },
      page: { name: "page", type: "Integer" },
    },
    "Field.Model.Currency": {
      roundingOption: { name: "rounding_option", type: "String" },
      precision: { name: "precision", type: "Integer" },
    },
    "BulkRead.Model.ResponseWrapper": {
      data: {
        structure_name: "BulkRead.Model.JobDetail",
        name: "data",
        type: "List",
      },
    },
    "CustomView.Model.Translation": {
      createdByMe: { name: "created_by_me", type: "String" },
      otherUsersViews: { name: "other_users_views", type: "String" },
      publicViews: { name: "public_views", type: "String" },
      sharedWithMe: { name: "shared_with_me", type: "String" },
    },
    "CustomView.Model.ResponseHandler": {
      classes: [
        "CustomView.Model.ResponseWrapper",
        "CustomView.Model.APIException",
      ],
      interface: !0,
    },
    "Module.Model.ActionHandler": {
      classes: ["Module.Model.APIException", "Module.Model.ActionWrapper"],
      interface: !0,
    },
    "ShareRecord.Model.ActionHandler": {
      classes: [
        "ShareRecord.Model.APIException",
        "ShareRecord.Model.ActionWrapper",
      ],
      interface: !0,
    },
    "Layout.Model.Layout": {
      modifiedTime: { name: "modified_time", type: "DateTime" },
      createdFor: {
        structure_name: "User.Model.User",
        name: "created_for",
        type: "User.Model.User",
      },
      visible: { name: "visible", type: "Boolean" },
      createdBy: {
        structure_name: "User.Model.User",
        name: "created_by",
        type: "User.Model.User",
      },
      name: { name: "name", type: "String" },
      profiles: {
        structure_name: "Profile.Model.Profile",
        name: "profiles",
        type: "List",
      },
      createdTime: { name: "created_time", type: "DateTime" },
      modifiedBy: {
        structure_name: "User.Model.User",
        name: "modified_by",
        type: "User.Model.User",
      },
      id: { name: "id", type: "Long", primary: !0 },
      sections: {
        structure_name: "Layout.Model.Section",
        name: "sections",
        type: "List",
      },
      convertMapping: { name: "convert_mapping", type: "Map" },
      status: { name: "status", type: "Integer" },
    },
    "Variable.Model.GetVariableByIDParam": {
      group: { name: "group", type: "String", required: !0 },
    },
    "Field.Model.LookupField": {
      name: { name: "name", type: "String" },
      id: { name: "id", type: "Long" },
    },
    "Notification.Model.ResponseHandler": {
      classes: [
        "Notification.Model.APIException",
        "Notification.Model.ResponseWrapper",
      ],
      interface: !0,
    },
    "Note.Model.DeleteNotesParam": {
      ids: { name: "ids", type: "Long", required: !0 },
    },
    "Tag.Model.ActionHandler": {
      classes: ["Tag.Model.ActionWrapper", "Tag.Model.APIException"],
      interface: !0,
    },
    "Record.Model.DeleteRecordUsingExternalIDParam": {
      wfTrigger: { name: "wf_trigger", type: "Boolean" },
    },
    "RelatedRecord.Model.APIException": {
      code: {
        values: [
          "NO_PERMISSION",
          "CANNOT_BE_UPDATED",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_DATA",
          "INTERNAL_ERROR",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "permissions", type: "List" },
          { name: "id", type: "Long" },
          { name: "param_name", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid data",
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "record not deleted",
          "the related id given seems to be invalid",
          "Internal server error occurred.",
          "The relation name given seems to be invalid",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "BulkWrite.Model.FieldMapping": {
      apiName: { name: "api_name", type: "String", required: !0 },
      defaultValue: { name: "default_value", type: "Map" },
      module: { name: "module", type: "String" },
      format: { name: "format", type: "String" },
      index: { name: "index", type: "Integer" },
      findBy: { name: "find_by", type: "String" },
    },
    "Currency.Model.ResponseWrapper": {
      currencies: {
        structure_name: "Currency.Model.Currency",
        name: "currencies",
        type: "List",
      },
    },
    "Variable.Model.GetVariablesParam": {
      group: { name: "group", type: "String", required: !0 },
    },
    "Note.Model.GetNoteHeader": {
      IfModifiedSince: {
        name: "If-Modified-Since",
        type: "DateTime",
        required: !0,
      },
    },
    "VariableGroup.Model.APIException": {
      code: {
        values: [
          "INTERNAL_ERROR",
          "OAUTH_SCOPE_MISMATCH",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: { name: "details", type: "Map" },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Field.Model.Module": {
      layout: {
        structure_name: "Layout.Model.Layout",
        name: "layout",
        type: "Layout.Model.Layout",
      },
      displayLabel: { name: "display_label", type: "String" },
      apiName: { name: "api_name", type: "String" },
      module: { name: "module", type: "String" },
      moduleName: { name: "module_name", type: "String" },
      id: { name: "id", type: "Long" },
    },
    "Attachment.Model.Attachment": {
      owner: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "Owner",
        type: "User.Model.User",
      },
      modifiedTime: { name: "Modified_Time", type: "DateTime" },
      fileName: { name: "File_Name", type: "String" },
      editable: { name: "$editable", type: "Boolean" },
      description: { name: "description", type: "String" },
      type: { name: "$type", type: "String" },
      parentId: {
        lookup: !0,
        structure_name: "Record.Model.Record",
        name: "Parent_Id",
        type: "Record.Model.Record",
      },
      seModule: { name: "$se_module", type: "String" },
      size: { name: "Size", type: "Long" },
      createdBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "Created_By",
        type: "User.Model.User",
      },
      linkUrl: { name: "$link_url", type: "String" },
      createdTime: { name: "Created_Time", type: "DateTime" },
      modifiedBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "Modified_By",
        type: "User.Model.User",
      },
      state: { name: "$state", type: "String" },
      id: { name: "id", type: "Long", primary: !0 },
      category: { name: "category", type: "String" },
      fileId: { name: "$file_id", type: "String" },
    },
    "Function.Model.ExecuteFunctionUsingParametersHeader": {
      getCustomFunctionsHeader: {
        name: "get_custom_functions_header",
        type: "Map",
      },
    },
    "Field.Model.PickListValue": {
      displayValue: { name: "display_value", type: "String" },
      sequenceNumber: { name: "sequence_number", type: "Integer" },
      maps: { name: "maps", type: "List" },
      actualValue: { name: "actual_value", type: "String" },
      sysRefName: { name: "sys_ref_name", type: "String" },
      expectedDataType: { name: "expected_data_type", type: "String" },
      type: { name: "type", type: "String" },
    },
    "Currency.Model.ActionWrapper": {
      currencies: {
        structure_name: "Currency.Model.ActionResponse",
        name: "currencies",
        type: "List",
      },
    },
    "Layout.Model.ResponseWrapper": {
      layouts: {
        structure_name: "Layout.Model.Layout",
        name: "layouts",
        type: "List",
      },
    },
    "ShareRecord.Model.GetSharedRecordDetailsParam": {
      view: { name: "view", type: "String" },
      sharedTo: { name: "sharedTo", type: "Long" },
    },
    "Module.Model.ActionResponse": {
      classes: ["Module.Model.APIException", "Module.Model.SuccessResponse"],
      interface: !0,
    },
    "User.Model.ActionResponse": {
      classes: ["User.Model.SuccessResponse", "User.Model.APIException"],
      interface: !0,
    },
    "Attachment.Model.DeleteAttachmentsParam": {
      ids: { name: "ids", type: "Long", required: !0 },
    },
    "Record.Model.ConvertActionWrapper": {
      data: {
        structure_name: "Record.Model.ConvertActionResponse",
        name: "data",
        type: "List",
      },
    },
    "Record.Model.SearchRecordsHeader": {
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "File.Model.GetFileParam": {
      id: { name: "id", type: "String", required: !0 },
    },
    "Module.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [
          { name: "id", type: "Long" },
          { name: "api_name", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["module updated successfully"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "User.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [
          { name: "id", type: "Long" },
          { name: "email", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["User added", "User updated", "User deleted"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Tax.Model.Tax": {
      displayLabel: { name: "display_label", type: "String" },
      sequenceNumber: { name: "sequence_number", type: "Integer" },
      name: { name: "name", type: "String", required: !0 },
      id: { name: "id", type: "Long", primary: !0 },
      value: { name: "value", type: "Double", required: !0 },
    },
    "Record.Model.UpdateRecordHeader": {
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "Role.Model.APIException": {
      code: {
        values: [
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_DATA",
          "INTERNAL_ERROR",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: { name: "details", type: "Map" },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "record not deleted",
          "the related id given seems to be invalid",
          "Internal server error occurred.",
          "The relation name given seems to be invalid",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Tax.Model.Preference": {
      modifyTaxRates: { name: "modify_tax_rates", type: "Boolean" },
      autoPopulateTax: { name: "auto_populate_tax", type: "Boolean" },
    },
    "Notification.Model.DisableNotificationsParam": {
      channelIds: { name: "channel_ids", type: "Long" },
    },
    "Tag.Model.BodyWrapper": {
      tags: {
        structure_name: "Tag.Model.Tag",
        name: "tags",
        type: "List",
        required: !0,
      },
    },
    "Notification.Model.Info": {
      perPage: { name: "per_page", type: "Integer" },
      moreRecords: { name: "more_records", type: "Boolean" },
      count: { name: "count", type: "Integer" },
      page: { name: "page", type: "Integer" },
    },
    "Record.Model.RecurringActivity": {
      rrule: { name: "RRULE", type: "String", required: !0 },
    },
    "ShareRecord.Model.ShareRecord": {
      shareRelatedRecords: { name: "share_related_records", type: "Boolean" },
      sharedThrough: {
        lookup: !0,
        structure_name: "ShareRecord.Model.SharedThrough",
        name: "shared_through",
        type: "ShareRecord.Model.SharedThrough",
      },
      sharedTime: { name: "shared_time", type: "DateTime" },
      sharedBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "shared_by",
        type: "User.Model.User",
      },
      permission: {
        "required-in-update": !0,
        name: "permission",
        type: "String",
        required: !0,
      },
      user: {
        lookup: !0,
        structure_name: "User.Model.User",
        "required-in-update": !0,
        name: "user",
        type: "User.Model.User",
        required: !0,
      },
    },
    "ShareRecord.Model.BodyWrapper": {
      share: {
        structure_name: "ShareRecord.Model.ShareRecord",
        name: "share",
        "max-length": 10,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "Org.Model.ResponseWrapper": {
      org: { structure_name: "Org.Model.Org", name: "org", type: "List" },
    },
    "File.Model.FileBodyWrapper": {
      file: {
        name: "file",
        type: "StreamWrapper.Model.StreamWrapper",
        required: !0,
      },
    },
    "CustomView.Model.Range": {
      from: { name: "from", type: "Integer" },
      to: { name: "to", type: "Integer" },
    },
    "User.Model.BodyWrapper": {
      users: {
        structure_name: "User.Model.User",
        name: "users",
        "max-length": 100,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "BulkRead.Model.ActionResponse": {
      classes: [
        "BulkRead.Model.SuccessResponse",
        "BulkRead.Model.APIException",
      ],
      interface: !0,
    },
    "ContactRole.Model.APIException": {
      code: {
        values: [
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_MODULE",
          "DUPLICATE_DATA",
          "LIMIT_EXCEEDED",
          "MANDATORY_NOT_FOUND",
          "INVALID_DATA",
          "INTERNAL_ERROR",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "api_name", type: "String" },
          { name: "id", type: "Long" },
          { name: "limit", type: "Integer" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "the module name given seems to be invalid",
          "duplicate data",
          "Contact Role feature limit exceeded",
          "required field not found",
          "invalid data",
          "contact role not deleted",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "RelatedRecord.Model.FileBodyWrapper": {
      file: {
        name: "file",
        type: "StreamWrapper.Model.StreamWrapper",
        required: !0,
      },
    },
    "User.Model.TabTheme": {
      background: { name: "background", type: "String" },
      fontColor: { name: "font_color", type: "String" },
    },
    "Record.Model.DeleteRecordUsingExternalIDHeader": {
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "Attachment.Model.UploadLinkAttachmentParam": {
      attachmentUrl: { name: "attachmentUrl", type: "String" },
    },
    "Record.Model.MassUpdateActionWrapper": {
      data: {
        structure_name: "Record.Model.MassUpdateActionResponse",
        name: "data",
        type: "List",
      },
    },
    "Variable.Model.ActionHandler": {
      classes: ["Variable.Model.APIException", "Variable.Model.ActionWrapper"],
      interface: !0,
    },
    "Field.Model.AssociationDetails": {
      lookupField: {
        structure_name: "Field.Model.LookupField",
        name: "lookup_field",
        type: "Field.Model.LookupField",
      },
      relatedField: {
        structure_name: "Field.Model.LookupField",
        name: "related_field",
        type: "Field.Model.LookupField",
      },
    },
    "Module.Model.APIException": {
      code: {
        values: [
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INTERNAL_ERROR",
          "INVALID_MODULE",
          "INVALID_DATA",
          "LIMIT_EXCEEDED",
          "DUPLICATE_DATA",
          "NOT_ALLOWED",
          "NO_PERMISSION",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "api_name", type: "String" },
          { name: "json_path", type: "String" },
          { name: "limit", type: "Integer" },
          { name: "maximum_length", type: "Integer" },
          { name: "permissions", type: "List" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "The module name given seems to be invalid",
          "the given module is not supported in api",
          "invalid data",
          "Api name duplicate",
          "Api name is not valid",
          "System keyword not allowed in api name",
          "Api name update not allowed",
          "No permission to update API name",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Record.Model.FileHandler": {
      classes: ["Record.Model.SuccessResponse", "Record.Model.APIException"],
      interface: !0,
    },
    "RelatedRecord.Model.ResponseHandler": {
      classes: [
        "RelatedRecord.Model.APIException",
        "RelatedRecord.Model.ResponseWrapper",
        "RelatedRecord.Model.FileBodyWrapper",
      ],
      interface: !0,
    },
    "Profile.Model.Section": {
      name: { name: "name", type: "String" },
      categories: {
        structure_name: "Profile.Model.Category",
        name: "categories",
        type: "List",
      },
    },
    "Record.Model.Comment": {
      commentedTime: { name: "commented_time", type: "DateTime" },
      commentContent: { name: "comment_content", type: "String" },
      id: { name: "id", type: "Long" },
      commentedBy: { name: "commented_by", type: "String" },
    },
    "Tag.Model.ResponseWrapper": {
      tags: { structure_name: "Tag.Model.Tag", name: "tags", type: "List" },
      info: {
        structure_name: "Tag.Model.Info",
        name: "info",
        type: "Tag.Model.Info",
      },
    },
    "BulkRead.Model.Criteria": {
      groupOperator: {
        values: ["and", "or"],
        name: "group_operator",
        type: "util.Model.Choice",
      },
      comparator: {
        values: [
          "equal",
          "not_equal",
          "in",
          "not_in",
          "less_than",
          "less_equal",
          "greater_than",
          "greater_equal",
          "contains",
          "not_contains",
          "starts_with",
          "ends_with",
          "between",
          "not_between",
        ],
        name: "comparator",
        type: "util.Model.Choice",
      },
      apiName: { name: "api_name", type: "String" },
      value: { name: "value", type: "Object" },
      group: {
        structure_name: "BulkRead.Model.Criteria",
        name: "group",
        type: "List",
      },
    },
    "ContactRole.Model.RecordResponseWrapper": {
      data: {
        structure_name: "Record.Model.Record",
        name: "data",
        type: "List",
      },
      info: {
        structure_name: "Record.Model.Info",
        name: "info",
        type: "Record.Model.Info",
      },
    },
    "File.Model.APIException": {
      code: {
        values: [
          "VIRUS_DETECTED",
          "failure_in_attachment_handling",
          "INTERNAL_ERROR",
          "INVALID_TOKEN",
          "INVALID_DATA",
          "MANDATORY_NOT_FOUND",
          "NO_PERMISSION",
          "INVALID_MODULE",
          "NOT_SUPPORTED",
          "PATTERN_NOT_MATCHED",
          "OAUTH_SCOPE_MISMATCH",
          "DUPLICATE_DATA",
          "INVALID_QUERY",
          "MAPPING_MISMATCH",
          "ID_ALREADY_CONVERTED",
          "FILE_SIZE_MORE_THAN_ALLOWED_SIZE",
          "RECORD_IN_BLUEPRINT",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "Not Modified",
          "AUTHENTICATION_FAILURE",
          "REQUIRED_PARAM_MISSING",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [{ name: "id", type: "String" }],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "Unable to process your request. Virus has been detected.",
          "Problem in uploading attachment. kindly upload the file properly",
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "The module name given seems to be invalid",
          "invalid data",
          "permission denied",
          "Internal server error occurred.",
          "duplicate data",
          "required field not found",
          "record not deleted",
          "record not deletable",
          "Authentication failed",
          "One of the expected parameter is missing",
          "mandatory param missing",
          "unable to process your request. please verify whether you have entered proper method name",
          " parameter and parameter values.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "User.Model.APIException": {
      code: {
        values: [
          "ID_ALREADY_DELETED",
          "CANNOT_UPDATE_DELETED_USER",
          "AUTHORIZATION_FAILED",
          "PATTERN_NOT_MATCHED",
          "INVALID_REQUEST",
          "LICENSE_LIMIT_EXCEEDED",
          "DUPLICATE_DATA",
          "INVALID_DATA",
          "UNAPPROVABLE",
          "MANDATORY_NOT_FOUND",
          "INTERNAL_ERROR",
          "EMAIL_UPDATE_NOT_ALLOWED",
          "ID_ALREADY_DEACTIVATED",
          "ID_ALREADY_ACTIVE",
          "FEATURE_PERMISSION",
          "OAUTH_SCOPE_MISMATCH",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [{ name: "api_name", type: "String" }],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "Internal server error occurred.",
          "Cannot add user under CRM Plus account. Kindly use CRMPlus URL to add user",
          "Request exceeds your license limit. Need to upgrade in order to add",
          "Failed to add user since same email id is already present",
          "Email Id should not contain @skydesk.jp. Please choose a different email id",
          "Invalid Email Id. Please choose a different email id",
          "Cannot add user for CRMPlus account from CRM. Kindly add user through CRMPlus",
          "Company Name is required",
          "Error occurred in resending the invitation of CRMPLUS user in CRM account",
          "Cannot update the time_zone of another User",
          "Either trial has expired or user does not have sufficient privilege to perform this action",
          "Error occurred while updating CRMPlus User in CRM Account",
          "invalid_data",
          "Deleted user cannot be updated",
          "Re-invite is not allowed for a confirmed user",
          "Cannot update email of a confirmed CRM User",
          "User with same email id is already in CRM Plus",
          "User is already deactivated",
          "Primary Contact cannot be deactivated",
          "User is already active",
          "Share among Subordinates Feature is not available",
          "Profile and Role cannot be Updated by the user.",
          "the_id_given_seems_to_be_invalid",
          "Primary contact cannot be deleted",
          "User is already deleted",
          "User does not have sufficient privilege to delete users",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Record.Model.CreateRecordsHeader": {
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "Currency.Model.BodyWrapper": {
      currencies: {
        structure_name: "Currency.Model.Currency",
        name: "currencies",
        "max-length": 10,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "Record.Model.InventoryLineItems": {
      unitPrice: { name: "unit_price", type: "Double" },
      quantityInStock: { name: "quantity_in_stock", type: "Double" },
      product: {
        lookup: !0,
        structure_name: "Record.Model.LineItemProduct",
        name: "product",
        type: "Record.Model.LineItemProduct",
        required: !0,
      },
      quantity: { name: "quantity", type: "Double", required: !0 },
      book: { name: "book", type: "Double" },
      discount: { name: "Discount", type: "String" },
      tax: { name: "Tax", type: "Double" },
      totalAfterDiscount: { name: "total_after_discount", type: "Double" },
      total: { name: "total", type: "Double" },
      netTotal: { name: "net_total", type: "Double" },
      lineTax: {
        lookup: !0,
        structure_name: "Record.Model.LineTax",
        name: "line_tax",
        type: "List",
      },
      listPrice: { name: "list_price", type: "Double" },
      productDescription: { name: "product_description", type: "String" },
    },
    "Layout.Model.Properties": {
      maximumRows: { name: "maximum_rows", type: "Integer" },
      tooltip: {
        structure_name: "Field.Model.ToolTip",
        name: "tooltip",
        type: "Field.Model.ToolTip",
      },
      reorderRows: { name: "reorder_rows", type: "Boolean" },
    },
    "Profile.Model.PermissionDetail": {
      displayLabel: { name: "display_label", type: "String" },
      module: { name: "module", type: "String" },
      name: { name: "name", type: "String" },
      id: { name: "id", type: "Long" },
      enabled: { name: "enabled", type: "Boolean" },
    },
    "Note.Model.ActionResponse": {
      classes: ["Note.Model.SuccessResponse", "Note.Model.APIException"],
      interface: !0,
    },
    "File.Model.ResponseHandler": {
      classes: ["File.Model.APIException", "File.Model.FileBodyWrapper"],
      interface: !0,
    },
    "Record.Model.BodyWrapper": {
      process: { name: "process", type: "List" },
      data: {
        structure_name: "Record.Model.Record",
        name: "data",
        "max-length": 100,
        type: "List",
        required: !0,
        "min-length": 1,
      },
      larId: { name: "lar_id", type: "String" },
      wfTrigger: { name: "wf_trigger", type: "String" },
      trigger: { name: "trigger", type: "List" },
      duplicateCheckFields: { name: "duplicate_check_fields", type: "List" },
    },
    "Tax.Model.ResponseWrapper": {
      preference: {
        structure_name: "Tax.Model.Preference",
        name: "preference",
        type: "Tax.Model.Preference",
      },
      taxes: { structure_name: "Tax.Model.Tax", name: "taxes", type: "List" },
    },
    "Currency.Model.ActionHandler": {
      classes: ["Currency.Model.ActionWrapper", "Currency.Model.APIException"],
      interface: !0,
    },
    "Record.Model.GetRecordsParam": {
      cvid: { name: "cvid", type: "String" },
      endDateTime: { name: "endDateTime", type: "DateTime" },
      includeChild: { name: "include_child", type: "String" },
      uid: { name: "uid", type: "String" },
      approved: { name: "approved", type: "String" },
      perPage: { name: "per_page", type: "Integer" },
      startDateTime: { name: "startDateTime", type: "DateTime" },
      converted: { name: "converted", type: "String" },
      sortOrder: { name: "sort_order", type: "String" },
      ids: { name: "ids", type: "String", required: !0 },
      territoryId: { name: "territory_id", type: "String" },
      sortBy: { name: "sort_by", type: "String" },
      page: { name: "page", type: "Integer" },
      fields: { name: "fields", type: "String" },
    },
    "BluePrint.Model.BodyWrapper": {
      blueprint: {
        structure_name: "BluePrint.Model.BluePrint",
        name: "blueprint",
        "max-length": 1,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "Territory.Model.ResponseWrapper": {
      territories: {
        structure_name: "Territory.Model.Territory",
        name: "territories",
        type: "List",
      },
    },
    "Role.Model.ResponseWrapper": {
      roles: { structure_name: "Role.Model.Role", name: "roles", type: "List" },
    },
    "Tag.Model.AddTagsToRecordParam": {
      tagNames: { name: "tag_names", type: "String", required: !0 },
      overWrite: { name: "over_write", type: "String" },
    },
    "Tag.Model.ConflictWrapper": {
      conflictId: { name: "conflict_id", type: "String", required: !0 },
    },
    "Role.Model.ResponseHandler": {
      classes: ["Role.Model.APIException", "Role.Model.ResponseWrapper"],
      interface: !0,
    },
    "Notification.Model.ResponseWrapper": {
      watch: {
        structure_name: "Notification.Model.Notification",
        name: "watch",
        type: "List",
      },
      info: {
        structure_name: "Notification.Model.Info",
        name: "info",
        type: "Notification.Model.Info",
      },
    },
    "Module.Model.Module": {
      relatedListProperties: {
        structure_name: "Module.Model.RelatedListProperties",
        name: "related_list_properties",
        type: "Module.Model.RelatedListProperties",
      },
      modifiedTime: { name: "modified_time", type: "DateTime" },
      apiName: { name: "api_name", type: "String", primary: !0 },
      generatedType: {
        values: ["default", "web", "custom", "linking"],
        name: "generated_type",
        type: "util.Model.Choice",
      },
      webLink: { name: "web_link", type: "String" },
      deletable: { name: "deletable", type: "Boolean" },
      moduleName: { name: "module_name", type: "String" },
      description: { name: "description", type: "String" },
      scoringSupported: { name: "scoring_supported", type: "Boolean" },
      filterSupported: { name: "filter_supported", type: "Boolean" },
      feedsRequired: { name: "feeds_required", type: "Boolean" },
      creatable: { name: "creatable", type: "Boolean" },
      customView: {
        lookup: !0,
        structure_name: "CustomView.Model.CustomView",
        name: "custom_view",
        type: "CustomView.Model.CustomView",
      },
      webformSupported: { name: "webform_supported", type: "Boolean" },
      kanbanViewSupported: { name: "kanban_view_supported", type: "Boolean" },
      modifiedBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "modified_by",
        type: "User.Model.User",
      },
      id: { name: "id", type: "Long", primary: !0 },
      showAsTab: { name: "show_as_tab", type: "Boolean" },
      sequenceNumber: { name: "sequence_number", type: "Integer" },
      globalSearchSupported: {
        name: "global_search_supported",
        type: "Boolean",
      },
      visibility: { name: "visibility", type: "Integer" },
      convertable: { name: "convertable", type: "Boolean" },
      editable: { name: "editable", type: "Boolean" },
      quickCreate: { name: "quick_create", type: "Boolean" },
      profiles: {
        lookup: !0,
        structure_name: "Profile.Model.Profile",
        name: "profiles",
        type: "List",
      },
      filterStatus: { name: "filter_status", type: "Boolean" },
      presenceSubMenu: { name: "presence_sub_menu", type: "Boolean" },
      pluralLabel: { name: "plural_label", type: "String" },
      singularLabel: { name: "singular_label", type: "String" },
      parentModule: {
        lookup: !0,
        structure_name: "Module.Model.Module",
        name: "parent_module",
        type: "Module.Model.Module",
      },
      businessCardFieldLimit: {
        name: "business_card_field_limit",
        type: "Integer",
      },
      perPage: { name: "per_page", type: "Integer" },
      viewable: { name: "viewable", type: "Boolean" },
      apiSupported: { name: "api_supported", type: "Boolean" },
      name: { name: "name", type: "String" },
      displayField: { name: "display_field", type: "String" },
      arguments1: {
        structure_name: "Module.Model.Argument",
        name: "arguments",
        type: "List",
      },
      emailtemplateSupport: { name: "emailTemplate_support", type: "Boolean" },
      triggersSupported: { name: "triggers_supported", type: "Boolean" },
      kanbanView: { name: "kanban_view", type: "Boolean" },
      inventoryTemplateSupported: {
        name: "inventory_template_supported",
        type: "Boolean",
      },
      properties: { name: "$properties", type: "List" },
      searchLayoutFields: { name: "search_layout_fields", type: "List" },
      territory: {
        lookup: !0,
        structure_name: "Module.Model.Territory",
        name: "territory",
        type: "Module.Model.Territory",
      },
    },
    "BulkWrite.Model.File": {
      updatedCount: { name: "updated_count", type: "Integer" },
      name: { name: "name", type: "String" },
      skippedCount: { name: "skipped_count", type: "Integer" },
      addedCount: { name: "added_count", type: "Integer" },
      totalCount: { name: "total_count", type: "Integer" },
      status: {
        values: ["ADDED", "IN PROGRESS", "COMPLETED", "SKIPPED", "FAILED"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "User.Model.ActionHandler": {
      classes: ["User.Model.ActionWrapper", "User.Model.APIException"],
      interface: !0,
    },
    "CustomView.Model.CustomView": {
      criteria: {
        structure_name: "CustomView.Model.Criteria",
        name: "criteria",
        type: "CustomView.Model.Criteria",
      },
      displayValue: { name: "display_value", type: "String" },
      offline: { name: "offline", type: "Boolean" },
      systemName: { name: "system_name", type: "String" },
      default1: { name: "default", type: "Boolean" },
      sortOrder: { name: "sort_order", type: "String" },
      sharedDetails: {
        structure_name: "CustomView.Model.SharedDetails",
        name: "shared_details",
        type: "List",
      },
      name: { name: "name", type: "String" },
      sharedType: { name: "shared_type", type: "String" },
      sortBy: { name: "sort_by", type: "String" },
      id: { name: "id", type: "Long", primary: !0 },
      category: { name: "category", type: "String" },
      systemDefined: { name: "system_defined", type: "Boolean" },
      fields: { name: "fields", type: "List" },
      favorite: { name: "favorite", type: "Integer" },
    },
    "Record.Model.MassUpdateResponseWrapper": {
      data: {
        structure_name: "Record.Model.MassUpdateResponse",
        name: "data",
        type: "List",
      },
    },
    "Record.Model.GetRecordUsingExternalIDHeader": {
      IfModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "ShareRecord.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [{ name: "id", type: "Long" }],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["record will be shared successfully", "Sharing Revoked"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "BulkRead.Model.FileBodyWrapper": {
      file: {
        name: "file",
        type: "StreamWrapper.Model.StreamWrapper",
        required: !0,
      },
    },
    "Record.Model.MassUpdate": {
      failedCount: { name: "Failed_Count", type: "Integer" },
      updatedCount: { name: "Updated_Count", type: "Integer" },
      notUpdatedCount: { name: "Not_Updated_Count", type: "Integer" },
      totalCount: { name: "Total_Count", type: "Integer" },
      status: {
        values: ["COMPLETED", "SCHEDULED", "RUNNING", "FAILED"],
        name: "Status",
        type: "util.Model.Choice",
      },
    },
    "Profile.Model.ResponseWrapper": {
      profiles: {
        structure_name: "Profile.Model.Profile",
        name: "profiles",
        type: "List",
      },
    },
    "User.Model.Theme": {
      newBackground: { name: "new_background", type: "String" },
      normalTab: {
        lookup: !0,
        structure_name: "User.Model.TabTheme",
        name: "normal_tab",
        type: "User.Model.TabTheme",
      },
      background: { name: "background", type: "String" },
      screen: { name: "screen", type: "String" },
      type: { name: "type", type: "String" },
      selectedTab: {
        lookup: !0,
        structure_name: "User.Model.TabTheme",
        name: "selected_tab",
        type: "User.Model.TabTheme",
      },
    },
    "Variable.Model.BodyWrapper": {
      variables: {
        structure_name: "Variable.Model.Variable",
        name: "variables",
        "max-length": 100,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "CustomView.Model.ResponseWrapper": {
      customViews: {
        structure_name: "CustomView.Model.CustomView",
        name: "custom_views",
        type: "List",
      },
      info: {
        structure_name: "CustomView.Model.Info",
        name: "info",
        type: "CustomView.Model.Info",
      },
    },
    "Tax.Model.DeleteTaxesParam": {
      ids: { name: "ids", type: "Long", required: !0 },
    },
    "Record.Model.MassUpdateResponseHandler": {
      classes: [
        "Record.Model.APIException",
        "Record.Model.MassUpdateResponseWrapper",
      ],
      interface: !0,
    },
    "ShareRecord.Model.DeleteActionResponse": {
      classes: [
        "ShareRecord.Model.SuccessResponse",
        "ShareRecord.Model.APIException",
      ],
      interface: !0,
    },
    "ContactRole.Model.RecordActionWrapper": {
      data: {
        structure_name: "ContactRole.Model.ActionResponse",
        name: "data",
        "max-length": 100,
        type: "List",
      },
    },
    "RelatedList.Model.GetRelatedListsParam": {
      module: { name: "module", type: "String" },
    },
    "Record.Model.ResponseWrapper": {
      data: {
        structure_name: "Record.Model.Record",
        name: "data",
        type: "List",
      },
      info: {
        structure_name: "Record.Model.Info",
        name: "info",
        type: "Record.Model.Info",
      },
    },
    "Record.Model.FileDetails": {
      extn: { name: "extn", type: "String" },
      fileName: { name: "file_Name", type: "String" },
      previewUrl: { name: "preview_Url", type: "String" },
      isPreviewAvailable: { name: "is_Preview_Available", type: "Boolean" },
      downloadUrl: { name: "download_Url", type: "String" },
      creatorId: { name: "creator_Id", type: "String" },
      entityId: { name: "entity_Id", type: "String" },
      delete1: { name: "_delete", type: "String" },
      mode: { name: "mode", type: "String" },
      linkDocs: { name: "link_Docs", type: "Integer" },
      fileSize: { name: "file_Size", type: "String" },
      deleteUrl: { name: "delete_Url", type: "String" },
      attachmentId: { name: "attachment_Id", type: "String" },
      originalSizeByte: { name: "original_Size_Byte", type: "String" },
      fileId: { name: "file_Id", type: "String", required: !0 },
    },
    "Record.Model.ConvertBodyWrapper": {
      data: {
        structure_name: "Record.Model.LeadConverter",
        name: "data",
        "max-length": 1,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "BulkRead.Model.CallBack": {
      method: {
        values: ["post"],
        name: "method",
        type: "util.Model.Choice",
        required: !0,
      },
      url: { name: "url", type: "String", required: !0 },
    },
    "Record.Model.APIException": {
      code: {
        values: [
          "FEATURE_NOT_SUPPORTED",
          "CONVERTED_RECORD",
          "NOT_FOUND",
          "NO_RECORDS_FOUND",
          "NOT_APPROVED",
          "LIMIT_EXCEEDED",
          "ALREADY_SCHEDULED",
          "CANNOT_PERFORM_ACTION",
          "CANNOT_PROCESS",
          "INTERNAL_ERROR",
          "INVALID_TOKEN",
          "INVALID_DATA",
          "MANDATORY_NOT_FOUND",
          "NO_PERMISSION",
          "INVALID_MODULE",
          "NOT_SUPPORTED",
          "PATTERN_NOT_MATCHED",
          "OAUTH_SCOPE_MISMATCH",
          "DUPLICATE_DATA",
          "INVALID_QUERY",
          "MAPPING_MISMATCH",
          "ID_ALREADY_CONVERTED",
          "FILE_SIZE_MORE_THAN_ALLOWED_SIZE",
          "RECORD_IN_BLUEPRINT",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "Not Modified",
          "AUTHENTICATION_FAILURE",
          "CANNOT_DELETE",
          "REQUIRED_PARAM_MISSING",
          "DATA_MISMATCH",
          "RECORD_LOCKED",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "permissions", type: "List" },
          { name: "param_name", type: "String" },
          { name: "api_name", type: "String" },
          { name: "id", type: "Long" },
          { name: "module", type: "String" },
          { name: "expected_data_type", type: "String" },
          { name: "index", type: "Integer" },
          { name: "maximum_length", type: "String" },
          { name: "mapped_field", type: "String" },
          { name: "reason", type: "String" },
          { name: "operator", type: "String" },
          { name: "allowed_count", type: "Integer" },
          { name: "limit", type: "Integer" },
          { name: "json_path", type: "String" },
          { name: "parent_api_name", type: "String" },
          { name: "param", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "The value of the external field is invalid.",
          "There is no data for the ID specified or there is no matching record in the given module.",
          "The external field contains duplicate data.",
          "The external ID of the lookup field or the Price Book is incorrect",
          "the id given seems to be invalid.",
          "Already an Mass Action scheduler is runing for the given cvid",
          "Scheduled Mass Operation feature is not available in your edition",
          "can't update the converted record",
          "Field cannot be updated in Scheduled Mass Update",
          "Field is not visible",
          "Field cannot be updated as it is associated with a validation rule.",
          "Field cannot be updated as it is associated with a layout rule.This field cannot be updated in the Mass Update",
          "Max field limit exceeded",
          "Maximum lookup field limit in criteria exceeded",
          "No field found",
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "The module name given seems to be invalid",
          "Territory is not supported for the given module",
          "Please check whether the input values are correct",
          "invalid data",
          "permission denied",
          "Internal server error occurred.",
          "duplicate data",
          "required field not found",
          "Layout doesn't contain the Pipeline",
          "Pipeline doesn't contain the Stage",
          "the id given seems to be invalid",
          "record not deleted",
          "record not deletable",
          "Authentication failed",
          "One of the expected parameter is missing",
          "mandatory param missing",
          "invalid query formed",
          "id already converted",
          "body",
          "given id is invalid",
          "Already a Mass Action scheduler is running for the given cvid",
          "The record is in stop processing",
          "The record is in blue print",
          "no permission to perform an action on this record",
          "Record count exceeded",
          "record not approved",
          "no record found to update",
          "Field Edit Permission not given",
          "Customview not accessible",
          "Empty response",
          "give contact id is mismatched with the data",
          "give account id is mismatched with the data",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Record.Model.FileBodyWrapper": {
      file: {
        name: "file",
        type: "StreamWrapper.Model.StreamWrapper",
        required: !0,
      },
    },
    "ContactRole.Model.ActionWrapper": {
      contactRoles: {
        structure_name: "ContactRole.Model.ActionResponse",
        name: "contact_roles",
        type: "List",
      },
    },
    "Record.Model.GetDeletedRecordsParam": {
      perPage: { name: "per_page", type: "Integer" },
      page: { name: "page", type: "Integer" },
      type: { name: "type", type: "String" },
    },
    "RelatedRecord.Model.ActionHandler": {
      classes: [
        "RelatedRecord.Model.APIException",
        "RelatedRecord.Model.ActionWrapper",
      ],
      interface: !0,
    },
    "BluePrint.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: { name: "details", type: "Map" },
      message: {
        values: ["transition updated successfully"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Note.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [
          { name: "Modified_Time", type: "DateTime" },
          {
            structure_name: "User.Model.User",
            name: "Modified_By",
            type: "User.Model.User",
          },
          { name: "Created_Time", type: "DateTime" },
          { name: "id", type: "Long" },
          {
            structure_name: "User.Model.User",
            name: "Created_By",
            type: "User.Model.User",
          },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["record added", "record updated", "record deleted"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Territory.Model.ResponseHandler": {
      classes: [
        "Territory.Model.APIException",
        "Territory.Model.ResponseWrapper",
      ],
      interface: !0,
    },
    "RelatedRecord.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [
          { name: "id", type: "Long" },
          { name: "External_Deal_ID", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["relation added", "relation removed"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Field.Model.APIException": {
      code: {
        values: [
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_MODULE",
          "INTERNAL_ERROR",
          "REQUIRED_PARAM_MISSING",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [{ name: "param", type: "String" }],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "the given module is not supported for this api",
          "Internal server error occurred.",
          "the module name given seems to be invalid",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "RelatedRecord.Model.UpdateRelatedRecordsUsingExternalIDHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
    },
    "Org.Model.FileBodyWrapper": {
      file: {
        name: "file",
        type: "StreamWrapper.Model.StreamWrapper",
        required: !0,
      },
    },
    "BluePrint.Model.ValidationError": {
      apiName: { name: "api_name", type: "String" },
      message: { name: "message", type: "String" },
    },
    "BluePrint.Model.ResponseWrapper": {
      blueprint: {
        structure_name: "BluePrint.Model.BluePrint",
        name: "blueprint",
        type: "BluePrint.Model.BluePrint",
      },
    },
    "RelatedRecord.Model.DeleteRelatedRecordsUsingExternalIDParam": {
      ids: { name: "ids", type: "String", required: !0 },
    },
    "File.Model.UploadFilesParam": {
      type: { name: "type", type: "String", required: !0 },
    },
    "Tax.Model.ResponseHandler": {
      classes: ["Tax.Model.APIException", "Tax.Model.ResponseWrapper"],
      interface: !0,
    },
    "BulkWrite.Model.Resource": {
      file: {
        structure_name: "BulkWrite.Model.File",
        name: "file",
        type: "BulkWrite.Model.File",
      },
      module: { name: "module", type: "String", required: !0 },
      ignoreEmpty: { name: "ignore_empty", type: "Boolean" },
      findBy: { name: "find_by", type: "String" },
      fieldMappings: {
        structure_name: "BulkWrite.Model.FieldMapping",
        name: "field_mappings",
        type: "List",
      },
      type: {
        values: ["data"],
        name: "type",
        type: "util.Model.Choice",
        required: !0,
      },
      status: {
        values: ["ADDED", "IN PROGRESS", "COMPLETED", "SKIPPED", "FAILED"],
        name: "status",
        type: "util.Model.Choice",
      },
      fileId: { name: "file_id", type: "String", required: !0 },
    },
    "Field.Model.GetFieldParam": { module: { name: "module", type: "String" } },
    "ContactRole.Model.RecordResponseHandler": {
      classes: [
        "ContactRole.Model.RecordResponseWrapper",
        "ContactRole.Model.APIException",
      ],
      interface: !0,
    },
    "Note.Model.APIException": {
      code: {
        values: [
          "NO_PERMISSION",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INTERNAL_ERROR",
          "MANDATORY_NOT_FOUND",
          "INVALID_DATA",
          "NOT_SUPPORTED",
          "REQUIRED_PARAM_MISSING",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "permissions", type: "List" },
          { name: "api_name", type: "String" },
          { name: "param", type: "String" },
          { name: "id", type: "Long" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "The module name given seems to be invalid",
          "the id given seems to be invalid",
          "One of the expected parameter is missing",
          "record not deleted",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Role.Model.Role": {
      displayLabel: { name: "display_label", type: "String" },
      forecastManager: {
        structure_name: "User.Model.User",
        name: "forecast_manager",
        type: "User.Model.User",
      },
      adminUser: { name: "admin_user", type: "Boolean" },
      shareWithPeers: { name: "share_with_peers", type: "Boolean" },
      name: { name: "name", type: "String" },
      description: { name: "description", type: "String" },
      id: { name: "id", type: "Long", primary: !0 },
      reportingTo: {
        structure_name: "User.Model.User",
        name: "reporting_to",
        type: "User.Model.User",
      },
    },
    "Field.Model.Field": {
      apiName: { name: "api_name", type: "String" },
      webhook: { name: "webhook", type: "Boolean" },
      criteria: {
        structure_name: "CustomView.Model.Criteria",
        name: "criteria",
        type: "CustomView.Model.Criteria",
      },
      crypt: {
        structure_name: "Field.Model.Crypt",
        name: "crypt",
        type: "Field.Model.Crypt",
      },
      defaultValue: { name: "default_value", type: "String" },
      validationRule: { name: "validation_rule", type: "Map" },
      tooltip: {
        structure_name: "Field.Model.ToolTip",
        name: "tooltip",
        type: "Field.Model.ToolTip",
      },
      quickSequenceNumber: { name: "quick_sequence_number", type: "Integer" },
      relatedDetails: {
        structure_name: "Field.Model.RelatedDetails",
        name: "related_details",
        type: "Field.Model.RelatedDetails",
      },
      jsonType: { name: "json_type", type: "String" },
      type: { name: "_type", type: "String" },
      layouts: {
        structure_name: "Layout.Model.Layout",
        name: "layouts",
        type: "Layout.Model.Layout",
      },
      mandatory: { name: "mandatory", type: "Boolean" },
      content: { name: "content", type: "String" },
      blueprintSupported: { name: "blueprint_supported", type: "Boolean" },
      associationDetails: {
        structure_name: "Field.Model.AssociationDetails",
        name: "association_details",
        type: "Field.Model.AssociationDetails",
      },
      pickListValues: {
        structure_name: "Field.Model.PickListValue",
        name: "pick_list_values",
        type: "List",
      },
      fieldLabel: { name: "field_label", type: "String" },
      fieldReadOnly: { name: "field_read_only", type: "Boolean" },
      businesscardSupported: {
        name: "businesscard_supported",
        type: "Boolean",
      },
      currency: {
        structure_name: "Field.Model.Currency",
        name: "currency",
        type: "Field.Model.Currency",
      },
      id: { name: "id", type: "Long", "read-only": !0, primary: !0 },
      displayLabel: { name: "display_label", type: "String" },
      personalityName: { name: "personality_name", type: "String" },
      lookup: {
        structure_name: "Field.Model.Module",
        name: "lookup",
        type: "Field.Model.Module",
      },
      visible: { name: "visible", type: "Boolean" },
      dataType: { name: "data_type", type: "String", "read-only": !0 },
      length: { name: "length", type: "Integer" },
      readOnly: { name: "read_only", type: "Boolean" },
      historyTracking: { name: "history_tracking", type: "Boolean" },
      sectionId: { name: "section_id", type: "Integer" },
      systemMandatory: { name: "system_mandatory", type: "Boolean" },
      message: { name: "message", type: "String" },
      subform: {
        structure_name: "Field.Model.Module",
        name: "subform",
        type: "Field.Model.Module",
      },
      autoNumber: {
        structure_name: "Field.Model.AutoNumber",
        name: "auto_number",
        type: "Field.Model.AutoNumber",
      },
      private1: {
        structure_name: "Field.Model.Private",
        name: "private",
        type: "Field.Model.Private",
      },
      customField: { name: "custom_field", type: "Boolean" },
      decimalPlace: { name: "decimal_place", type: "Integer" },
      convertMapping: { name: "convert_mapping", type: "Map" },
      createdSource: { name: "created_source", type: "String" },
      multiModuleLookup: { name: "multi_module_lookup", type: "Map" },
      massUpdate: { name: "mass_update", type: "Boolean" },
      transitionSequence: { name: "transition_sequence", type: "Integer" },
      unique: {
        structure_name: "Field.Model.Unique",
        name: "unique",
        type: "Field.Model.Unique",
      },
      viewType: {
        structure_name: "Field.Model.ViewType",
        name: "view_type",
        type: "Field.Model.ViewType",
      },
      formula: {
        structure_name: "Field.Model.Formula",
        name: "formula",
        type: "Field.Model.Formula",
      },
      multiselectlookup: {
        structure_name: "Field.Model.MultiSelectLookup",
        name: "multiselectlookup",
        type: "Field.Model.MultiSelectLookup",
      },
      columnName: { name: "column_name", type: "String" },
    },
    "ContactRole.Model.ResponseWrapper": {
      contactRoles: {
        structure_name: "ContactRole.Model.ContactRole",
        name: "contact_roles",
        type: "List",
      },
    },
    "Field.Model.Unique": {
      casesensitive: { name: "casesensitive", type: "String" },
    },
    "ContactRole.Model.GetAllContactRolesOfDealParam": {
      ids: { name: "ids", type: "String" },
    },
    "Note.Model.GetNoteParam": { fields: { name: "fields", type: "String" } },
    "Tag.Model.GetTagsParam": {
      myTags: { values: ["true", "false"], name: "my_tags", type: "String" },
      module: { name: "module", type: "String", required: !0 },
    },
    "Currency.Model.BaseCurrencyWrapper": {
      baseCurrency: {
        structure_name: "Currency.Model.Currency",
        name: "base_currency",
        type: "Currency.Model.Currency",
        required: !0,
      },
    },
    "Record.Model.CarryOverTags": {
      deals: { name: "Deals", type: "List" },
      accounts: { name: "Accounts", type: "List" },
      contacts: { name: "Contacts", type: "List" },
    },
    "Query.Model.APIException": {
      code: {
        values: [
          "INVALID_QUERY",
          "OAUTH_SCOPE_MISMATCH",
          "SYNTAX_ERROR",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_MODULE",
          "DUPLICATE_DATA",
          "LIMIT_EXCEEDED",
          "MANDATORY_NOT_FOUND",
          "INVALID_DATA",
          "INTERNAL_ERROR",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "near", type: "String" },
          { name: "column", type: "Integer" },
          { name: "line", type: "Integer" },
          { name: "clause", type: "String" },
          { name: "by", type: "String" },
          { name: "limit", type: "Integer" },
          { name: "column_name", type: "String" },
          { name: "reason", type: "String" },
          { name: "module", type: "String" },
          { name: "data_type", type: "String" },
          { name: "expected_data_type", type: "String" },
          { name: "operator", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid query formed",
          "value given seems to be invalid for the column",
          "data type not supported",
          "column given seems to be invalid",
          "invalid oauth scope to access this URL",
          "limit exceeded",
          "given coql query not supported",
          "select columns limit exceeded",
          "join limit exceeded",
          "missing clause",
          "error occured while parsing the query",
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "the module name given seems to be invalid",
          "duplicate data",
          "required field not found",
          "invalid data",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "ContactRole.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [{ name: "id", type: "Long" }],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "contact role added",
          "contact role updated",
          "contact role deleted",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "RelatedRecord.Model.GetRelatedRecordHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
      IfModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
    },
    "ShareRecord.Model.APIException": {
      code: {
        values: [
          "NO_PERMISSION",
          "BAD_REQUEST",
          "INVALID_MODULE",
          "SHARE_LIMIT_EXCEEDED",
          "OAUTH_SCOPE_MISMATCH",
          "INTERNAL_ERROR",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "DUPLICATE_DATA",
          "LIMIT_EXCEEDED",
          "MANDATORY_NOT_FOUND",
          "INVALID_DATA",
          "ENTITY_ID_INVALID",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [{ name: "permissions", type: "List" }],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "Scheduler is running",
          "cannot share to the user",
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "record not deleted",
          "the related id given seems to be invalid",
          "Internal server error occurred.",
          "The relation name given seems to be invalid.",
          "invalid oauth scope to access this URL",
          "Please check if the URL trying to access is a correct one.",
          "Permission is invalid",
          "record is already visible to the user.",
          "Cannot share a record to more than 10 users.",
          "No sharing through this record is available to revoke.",
          "ENTITY_ID_INVALID",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "RelatedRecord.Model.DeleteRelatedRecordsUsingExternalIDHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
    },
    "RelatedRecord.Model.ResponseWrapper": {
      data: {
        structure_name: "Record.Model.Record",
        name: "data",
        type: "List",
      },
      info: {
        structure_name: "Record.Model.Info",
        name: "info",
        type: "Record.Model.Info",
      },
    },
    "Variable.Model.ResponseWrapper": {
      variables: {
        structure_name: "Variable.Model.Variable",
        name: "variables",
        type: "List",
      },
    },
    "File.Model.ActionResponse": {
      classes: ["File.Model.SuccessResponse", "File.Model.APIException"],
      interface: !0,
    },
    "User.Model.ResponseHandler": {
      classes: ["User.Model.ResponseWrapper", "User.Model.APIException"],
      interface: !0,
    },
    "Note.Model.BodyWrapper": {
      data: {
        structure_name: "Note.Model.Note",
        name: "data",
        "max-length": 100,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "Notification.Model.ActionResponse": {
      classes: [
        "Notification.Model.SuccessResponse",
        "Notification.Model.APIException",
      ],
      interface: !0,
    },
    "RelatedRecord.Model.GetRelatedRecordsUsingExternalIDParam": {
      perPage: { name: "per_page", type: "Integer" },
      page: { name: "page", type: "Integer" },
    },
    "VariableGroup.Model.VariableGroup": {
      displayLabel: { name: "display_label", type: "String" },
      apiName: { name: "api_name", type: "String" },
      name: { name: "name", type: "String" },
      description: { name: "description", type: "String" },
      id: { name: "id", type: "Long", primary: !0 },
    },
    "Tag.Model.CountHandler": {
      classes: ["Tag.Model.APIException", "Tag.Model.CountWrapper"],
      interface: !0,
    },
    "RelatedRecord.Model.DelinkRecordHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
    },
    "Currency.Model.Currency": {
      symbol: { name: "symbol", type: "String", required: !0 },
      modifiedTime: { name: "modified_time", type: "DateTime" },
      format: {
        structure_name: "Currency.Model.Format",
        name: "format",
        type: "Currency.Model.Format",
        required: !0,
      },
      isActive: { name: "is_active", type: "Boolean" },
      exchangeRate: { name: "exchange_rate", type: "String", required: !0 },
      createdBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "created_by",
        type: "User.Model.User",
      },
      isoCode: { name: "iso_code", type: "String", required: !0 },
      name: { name: "name", type: "String", required: !0 },
      createdTime: { name: "created_time", type: "DateTime" },
      prefixSymbol: { name: "prefix_symbol", type: "Boolean" },
      modifiedBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "modified_by",
        type: "User.Model.User",
      },
      isBase: { name: "is_base", type: "Boolean" },
      id: { name: "id", type: "Long", primary: !0 },
    },
    "Function.Model.FileBodyWrapper": {
      inputfile: {
        name: "inputFile",
        type: "StreamWrapper.Model.StreamWrapper",
        required: !0,
      },
    },
    "RelatedRecord.Model.ActionWrapper": {
      data: {
        structure_name: "RelatedRecord.Model.ActionResponse",
        name: "data",
        type: "List",
      },
    },
    "Record.Model.Participants": {
      name: { name: "name", type: "String" },
      invited: { name: "invited", type: "Boolean" },
      type: { name: "type", type: "String", required: !0 },
      email: { name: "Email", type: "String" },
      participant: { name: "participant", type: "String", required: !0 },
      status: { name: "status", type: "String" },
    },
    "BulkWrite.Model.CallBack": {
      method: {
        values: ["post"],
        name: "method",
        type: "util.Model.Choice",
        required: !0,
      },
      url: { name: "url", type: "String", required: !0 },
    },
    "CustomView.Model.SharedDetails": {
      name: { name: "name", type: "String" },
      id: { name: "id", type: "Long" },
      type: { name: "type", type: "String" },
      subordinates: { name: "subordinates", type: "Boolean" },
    },
    "Query.Model.ResponseWrapper": {
      data: {
        structure_name: "Record.Model.Record",
        name: "data",
        type: "List",
      },
      info: {
        structure_name: "Record.Model.Info",
        name: "info",
        type: "Record.Model.Info",
      },
    },
    "Currency.Model.Format": {
      thousandSeparator: {
        values: ["Period", "Comma", "Space"],
        name: "thousand_separator",
        type: "util.Model.Choice",
        required: !0,
      },
      decimalPlaces: {
        "required-in-update": !0,
        values: ["0", "2", "3"],
        name: "decimal_places",
        type: "util.Model.Choice",
        required: !0,
      },
      decimalSeparator: {
        values: ["Period", "Comma"],
        name: "decimal_separator",
        type: "util.Model.Choice",
        required: !0,
      },
    },
    "Function.Model.ExecuteFunctionUsingParametersParam": {
      arguments1: { name: "arguments", type: "Map" },
      getCustomFunctionsParam: {
        name: "get_custom_functions_param",
        type: "Map",
      },
      authType: { name: "auth_type", type: "String" },
    },
    "Record.Model.DeletedRecordsWrapper": {
      data: {
        structure_name: "Record.Model.DeletedRecord",
        name: "data",
        type: "List",
      },
      info: {
        structure_name: "Record.Model.Info",
        name: "info",
        type: "Record.Model.Info",
      },
    },
    "Tag.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [
          { name: "created_time", type: "DateTime" },
          { name: "modified_time", type: "DateTime" },
          {
            structure_name: "User.Model.User",
            name: "modified_by",
            type: "User.Model.User",
          },
          { name: "id", type: "Long" },
          {
            structure_name: "User.Model.User",
            name: "created_by",
            type: "User.Model.User",
          },
          { name: "tags", type: "List" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "tags created successfully",
          "tags updated successfully",
          "tags deleted successfully",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Note.Model.ActionWrapper": {
      data: {
        structure_name: "Note.Model.ActionResponse",
        name: "data",
        type: "List",
      },
    },
    "Record.Model.DeleteRecordsParam": {
      ids: { name: "ids", type: "String", required: !0 },
      wfTrigger: { name: "wf_trigger", type: "Boolean" },
    },
    "Tag.Model.ActionWrapper": {
      tags: {
        structure_name: "Tag.Model.ActionResponse",
        name: "tags",
        type: "List",
      },
    },
    "BulkRead.Model.ResponseHandler": {
      classes: [
        "BulkRead.Model.ResponseWrapper",
        "BulkRead.Model.APIException",
        "BulkRead.Model.FileBodyWrapper",
      ],
      interface: !0,
    },
    "Record.Model.LineTax": {
      percentage: { name: "percentage", type: "Double" },
      name: { name: "name", type: "String" },
      id: { name: "id", type: "Long" },
      value: { name: "value", type: "Double" },
    },
    "Module.Model.Territory": {
      name: { name: "name", type: "String" },
      id: { name: "id", type: "Long" },
      subordinates: { name: "subordinates", type: "Boolean" },
    },
    "Field.Model.ToolTip": {
      name: { name: "name", type: "String" },
      value: { name: "value", type: "String" },
    },
    "Field.Model.Crypt": {
      mode: { name: "mode", type: "String" },
      column: { name: "column", type: "String" },
      encfldids: { name: "encFldIds", type: "List" },
      notify: { name: "notify", type: "String" },
      table: { name: "table", type: "String" },
      status: { name: "status", type: "Integer" },
    },
    "BluePrint.Model.ResponseHandler": {
      classes: [
        "BluePrint.Model.ResponseWrapper",
        "BluePrint.Model.APIException",
      ],
      interface: !0,
    },
    "RelatedRecord.Model.BodyWrapper": {
      data: {
        structure_name: "Record.Model.Record",
        name: "data",
        "max-length": 100,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "BulkRead.Model.ActionHandler": {
      classes: ["BulkRead.Model.APIException", "BulkRead.Model.ActionWrapper"],
      interface: !0,
    },
    "BulkWrite.Model.FileBodyWrapper": {
      file: {
        name: "file",
        type: "StreamWrapper.Model.StreamWrapper",
        required: !0,
      },
    },
    "Record.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      duplicateField: { name: "duplicate_field", type: "String" },
      action: {
        values: ["insert", "update"],
        name: "action",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "Modified_Time", type: "DateTime" },
          {
            structure_name: "User.Model.User",
            name: "Modified_By",
            type: "User.Model.User",
          },
          { name: "Created_Time", type: "DateTime" },
          { name: "id", type: "String" },
          {
            structure_name: "User.Model.User",
            name: "Created_By",
            type: "User.Model.User",
          },
          { name: "External_Contact_ID", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "record updated",
          "record deleted",
          "record added",
          "photo uploaded successfully",
          "Photo deleted",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "ShareRecord.Model.SharedThrough": {
      entityName: { name: "entity_name", type: "String" },
      module: {
        lookup: !0,
        structure_name: "Module.Model.Module",
        name: "module",
        type: "Module.Model.Module",
      },
      id: { name: "id", type: "Long" },
    },
    "Attachment.Model.ResponseHandler": {
      classes: [
        "Attachment.Model.APIException",
        "Attachment.Model.ResponseWrapper",
        "Attachment.Model.FileBodyWrapper",
      ],
      interface: !0,
    },
    "RelatedRecord.Model.DelinkRecordsHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
    },
    "Record.Model.ActionWrapper": {
      data: {
        structure_name: "Record.Model.ActionResponse",
        name: "data",
        type: "List",
      },
    },
    "Notification.Model.APIException": {
      code: {
        values: [
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_MODULE",
          "DUPLICATE_DATA",
          "LIMIT_EXCEEDED",
          "MANDATORY_NOT_FOUND",
          "INVALID_DATA",
          "INTERNAL_ERROR",
          "NOT_SUBSCRIBED",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "api_name", type: "String" },
          { name: "expected_data_type", type: "String" },
          { name: "maximum_length", type: "Integer" },
          { name: "param", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "the module name given seems to be invalid",
          "duplicate data",
          "Not subscribed for actions-watch of the given module/channel",
          "required field not found",
          "invalid data",
          "Not subscribed for actions-watch of the given channel",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Record.Model.UpdateRecordsHeader": {
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "Record.Model.MassUpdateSuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [
          { name: "job_id", type: "String" },
          { name: "id", type: "Long" },
          { name: "Modified_Time", type: "DateTime" },
          { name: "Created_Time", type: "DateTime" },
          {
            structure_name: "User.Model.User",
            name: "Modified_By",
            type: "User.Model.User",
          },
          {
            structure_name: "User.Model.User",
            name: "Created_By",
            type: "User.Model.User",
          },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["record updated", "mass update scheduled successfully"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Module.Model.Argument": {
      name: { name: "name", type: "String" },
      value: { name: "value", type: "String" },
    },
    "CustomView.Model.GetCustomViewParam": {
      module: { name: "module", type: "String" },
    },
    "Record.Model.ActionHandler": {
      classes: ["Record.Model.APIException", "Record.Model.ActionWrapper"],
      interface: !0,
    },
    "User.Model.RequestWrapper": {
      users: {
        structure_name: "User.Model.User",
        name: "users",
        "max-length": 1,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "Record.Model.ResponseHandler": {
      classes: [
        "Record.Model.ResponseWrapper",
        "Record.Model.APIException",
        "Record.Model.FileBodyWrapper",
      ],
      interface: !0,
    },
    "RelatedRecord.Model.DelinkRecordsParam": {
      ids: { name: "ids", type: "String", required: !0 },
    },
    "BulkWrite.Model.UploadFileHeader": {
      feature: { values: ["bulk-write"], name: "feature", type: "String" },
      XCRMORG: { name: "X-CRM-ORG", type: "String" },
    },
    "Record.Model.UpdateRecordUsingExternalIDHeader": {
      XEXTERNAL: { name: "X-EXTERNAL", type: "String" },
    },
    "BluePrint.Model.ProcessInfo": {
      apiName: { name: "api_name", type: "String" },
      fieldName: { name: "field_name", type: "String" },
      escalation: { name: "escalation", type: "String" },
      continuous: { name: "continuous", type: "Boolean" },
      fieldLabel: { name: "field_label", type: "String" },
      name: { name: "name", type: "String" },
      isContinuous: { name: "is_continuous", type: "Boolean" },
      id: { name: "id", type: "Long" },
      fieldValue: { name: "field_value", type: "String" },
      fieldId: { name: "field_id", type: "String" },
      columnName: { name: "column_name", type: "String" },
    },
    "Currency.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [{ name: "id", type: "Long" }],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "The multi-currency feature is enabled and given currency is created as the base currency.",
          "The currency created successfully.",
          "The currency updated successfully",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "ContactRole.Model.RecordActionHandler": {
      classes: [
        "ContactRole.Model.RecordActionWrapper",
        "ContactRole.Model.APIException",
      ],
      interface: !0,
    },
    "Currency.Model.APIException": {
      code: {
        values: [
          "OAUTH_SCOPE_MISMATCH",
          "ALREADY_ENABLED",
          "FEATURE_NOT_ENABLED",
          "NOT_ALLOWED",
          "ACTIVE_STATE_LIMIT_EXCEEDED",
          "INTERNAL_ERROR",
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "DUPLICATE_DATA",
          "LIMIT_EXCEEDED",
          "MANDATORY_NOT_FOUND",
          "INVALID_DATA",
          "CURRENCIES_NOT_ENABLED",
          "FEATURE_NOT_SUPPORTED",
          "No Content",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "api_name", type: "String" },
          { name: "json_path", type: "String" },
          { name: "expected_data_type", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one.",
          "The http request method type is not a valid one",
          "The module name given seems to be invalid",
          "The multi-currency is already enabled",
          "Currency name is invalid.",
          "ISO code is invalid.",
          "Currency symbol is invalid.",
          "The multi-currency feature is not available except the Enterprise and higher editions.",
          "Required field not found.",
          "unable to process your request. please verify whether you have entered proper method name",
          " parameter and parameter values.",
          "Currency symbol  is invalid.",
          "Multi currency is not enabled",
          "No Content",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "BulkRead.Model.Query": {
      cvid: { name: "cvid", type: "String" },
      criteria: {
        structure_name: "BulkRead.Model.Criteria",
        name: "criteria",
        type: "BulkRead.Model.Criteria",
      },
      module: { name: "module", type: "String", required: !0 },
      page: { name: "page", type: "Integer" },
      fields: { name: "fields", type: "List" },
    },
    "RelatedRecord.Model.ActionResponse": {
      classes: [
        "RelatedRecord.Model.APIException",
        "RelatedRecord.Model.SuccessResponse",
      ],
      interface: !0,
    },
    "RelatedList.Model.APIException": {
      code: {
        values: ["INVALID_MODULE", "REQUIRED_PARAM_MISSING", "INTERNAL_ERROR"],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [{ name: "param", type: "String" }],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "the module name given seems to be invalid",
          "the given module is not supported in api",
          "One of the expected parameter is missing",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "Attachment.Model.ActionHandler": {
      classes: [
        "Attachment.Model.APIException",
        "Attachment.Model.ActionWrapper",
      ],
      interface: !0,
    },
    "Function.Model.ExecuteFunctionUsingFileHeader": {
      uploadFileHeader: { name: "upload_file_header", type: "Map" },
    },
    "Field.Model.ResponseHandler": {
      classes: ["Field.Model.ResponseWrapper", "Field.Model.APIException"],
      interface: !0,
    },
    "Field.Model.Private": {
      export1: { name: "export", type: "Boolean" },
      restricted: { name: "restricted", type: "Boolean" },
      type: { name: "type", type: "String" },
    },
    "Notification.Model.ActionWrapper": {
      watch: {
        structure_name: "Notification.Model.ActionResponse",
        name: "watch",
        type: "List",
      },
    },
    "Tax.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [
          { name: "id", type: "Long" },
          { name: "name", type: "String" },
          { name: "value", type: "Integer" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["tax added", "record updated", "tax deleted"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Query.Model.ResponseHandler": {
      classes: ["Query.Model.ResponseWrapper", "Query.Model.APIException"],
      interface: !0,
    },
    "Module.Model.GetModulesHeader": {
      IfModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
    },
    "Record.Model.Territory": {
      id: { name: "id", type: "Long" },
      includeChild: { name: "include_child", type: "Boolean" },
    },
    "Field.Model.RelatedDetails": {
      displayLabel: { name: "display_label", type: "String" },
      apiName: { name: "api_name", type: "String" },
      module: {
        structure_name: "Field.Model.Module",
        name: "module",
        type: "Field.Model.Module",
      },
      id: { name: "id", type: "Long" },
      type: { name: "_type", type: "String" },
    },
    "ContactRole.Model.ActionResponse": {
      classes: [
        "ContactRole.Model.SuccessResponse",
        "ContactRole.Model.APIException",
      ],
      interface: !0,
    },
    "File.Model.ActionHandler": {
      classes: ["File.Model.ActionWrapper", "File.Model.APIException"],
      interface: !0,
    },
    "Attachment.Model.FileBodyWrapper": {
      file: {
        name: "file",
        type: "StreamWrapper.Model.StreamWrapper",
        required: !0,
      },
    },
    "Record.Model.LeadConverter": {
      notifyLeadOwner: { name: "notify_lead_owner", type: "Boolean" },
      notifyNewEntityOwner: {
        name: "notify_new_entity_owner",
        type: "Boolean",
      },
      deals: {
        structure_name: "Record.Model.Record",
        module: "Deals",
        name: "Deals",
        type: "Record.Model.Record",
      },
      accounts: { name: "Accounts", type: "String" },
      carryOverTags: {
        structure_name: "Record.Model.CarryOverTags",
        name: "carry_over_tags",
        type: "Record.Model.CarryOverTags",
      },
      overwrite: { name: "overwrite", type: "Boolean" },
      contacts: { name: "Contacts", type: "String" },
      assignTo: { name: "assign_to", type: "String" },
    },
    "BulkRead.Model.SuccessResponse": {
      code: {
        values: ["ADDED_SUCCESSFULLY"],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "id", type: "Long" },
          { name: "operation", type: "String" },
          {
            values: ["COMPLETED", "IN PROGRESS", "ADDED", "FAILURE"],
            name: "state",
            type: "util.Model.Choice",
          },
          {
            structure_name: "User.Model.User",
            name: "created_by",
            type: "User.Model.User",
          },
          { name: "created_time", type: "DateTime" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["Added successfully."],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Attachment.Model.ActionWrapper": {
      data: {
        structure_name: "Attachment.Model.ActionResponse",
        name: "data",
        type: "List",
      },
    },
    "Org.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: { name: "details", type: "Map" },
      message: {
        values: ["photo uploaded successfully"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "User.Model.Info": {
      perPage: { name: "per_page", type: "Integer" },
      moreRecords: { name: "more_records", type: "Boolean" },
      count: { name: "count", type: "Integer" },
      page: { name: "page", type: "Integer" },
    },
    "Tag.Model.ResponseHandler": {
      classes: ["Tag.Model.ResponseWrapper", "Tag.Model.APIException"],
      interface: !0,
    },
    "ContactRole.Model.RecordBodyWrapper": {
      data: {
        structure_name: "ContactRole.Model.ContactRoleWrapper",
        name: "data",
        "max-length": 1,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "BulkRead.Model.ActionWrapper": {
      data: {
        structure_name: "BulkRead.Model.ActionResponse",
        name: "data",
        type: "List",
      },
      info: { name: "info", type: "Map" },
    },
    "BulkWrite.Model.BulkWriteResponse": {
      result: {
        structure_name: "BulkWrite.Model.Result",
        name: "result",
        type: "BulkWrite.Model.Result",
      },
      resource: {
        structure_name: "BulkWrite.Model.Resource",
        name: "resource",
        type: "List",
      },
      createdBy: {
        structure_name: "User.Model.User",
        name: "created_by",
        type: "User.Model.User",
      },
      callback: {
        structure_name: "BulkWrite.Model.CallBack",
        name: "callback",
        type: "BulkWrite.Model.CallBack",
      },
      createdTime: { name: "created_time", type: "DateTime" },
      id: { name: "id", type: "Long" },
      characterEncoding: { name: "character_encoding", type: "String" },
      operation: { name: "operation", type: "String" },
      status: { name: "status", type: "String" },
    },
    "Attachment.Model.SuccessResponse": {
      code: { values: ["SUCCESS"], name: "code", type: "util.Model.Choice" },
      details: {
        keys: [{ name: "id", type: "Long" }],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["attachment uploaded successfully"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Record.Model.GetRecordParam": {
      cvid: { name: "cvid", type: "String" },
      uid: { name: "uid", type: "String" },
      approved: { name: "approved", type: "String" },
      startDateTime: { name: "startDateTime", type: "DateTime" },
      converted: { name: "converted", type: "String" },
      territoryId: { name: "territory_id", type: "String" },
      fields: { name: "fields", type: "String" },
      endDateTime: { name: "endDateTime", type: "DateTime" },
      includeChild: { name: "include_child", type: "String" },
    },
    "RelatedRecord.Model.DeleteRelatedRecordUsingExternalIDHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
    },
    "Tag.Model.Tag": {
      modifiedTime: { name: "modified_time", type: "DateTime" },
      createdBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "created_by",
        type: "User.Model.User",
      },
      name: {
        "required-in-update": !0,
        name: "name",
        type: "String",
        required: !0,
      },
      createdTime: { name: "created_time", type: "DateTime" },
      modifiedBy: {
        lookup: !0,
        structure_name: "User.Model.User",
        name: "modified_by",
        type: "User.Model.User",
      },
      id: { name: "id", type: "Long", primary: !0 },
    },
    "Record.Model.DeletedRecordsHandler": {
      classes: [
        "Record.Model.APIException",
        "Record.Model.DeletedRecordsWrapper",
      ],
      interface: !0,
    },
    "BluePrint.Model.APIException": {
      code: {
        values: [
          "INVALID_TOKEN",
          "INVALID_URL_PATTERN",
          "INVALID_REQUEST_METHOD",
          "INVALID_DATA",
          "RECORD_NOT_IN_PROCESS",
          "INTERNAL_ERROR",
        ],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "api_name", type: "String" },
          { name: "message", type: "String" },
          { name: "expected_data_type", type: "String" },
          { name: "info_message", type: "String" },
          { name: "parent_api_name", type: "String" },
          {
            structure_name: "BluePrint.Model.ValidationError",
            name: "validation_error",
            type: "List",
          },
          { name: "param_name", type: "String" },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: [
          "invalid oauth token",
          "Please check if the URL trying to access is a correct one",
          "The http request method type is not a valid one",
          "invalid transition",
          "invalid data",
          "record not in process",
          "Internal server error occurred.",
        ],
        name: "message",
        type: "util.Model.Choice",
      },
      status: { values: ["error"], name: "status", type: "util.Model.Choice" },
    },
    "CustomView.Model.Criteria": {
      comparator: {
        values: [
          "equal",
          "not_equal",
          "in",
          "not_in",
          "less_than",
          "less_equal",
          "greater_than",
          "greater_equal",
          "contains",
          "not_contains",
          "starts_with",
          "ends_with",
          "between",
          "not_between",
        ],
        name: "comparator",
        type: "util.Model.Choice",
      },
      groupOperator: {
        values: ["and", "or"],
        name: "group_operator",
        type: "util.Model.Choice",
      },
      field: { name: "field", type: "String" },
      value: { name: "value", type: "Object" },
      group: {
        structure_name: "CustomView.Model.Criteria",
        name: "group",
        type: "List",
      },
    },
    "Record.Model.GetRecordUsingExternalIDParam": {
      cvid: { name: "cvid", type: "String" },
      uid: { name: "uid", type: "String" },
      approved: { name: "approved", type: "String" },
      startDateTime: { name: "startDateTime", type: "DateTime" },
      converted: { name: "converted", type: "String" },
      territoryId: { name: "territory_id", type: "String" },
      fields: { name: "fields", type: "String" },
      endDateTime: { name: "endDateTime", type: "DateTime" },
      includeChild: { name: "include_child", type: "String" },
    },
    "User.Model.ActionWrapper": {
      users: {
        structure_name: "User.Model.ActionResponse",
        name: "users",
        type: "List",
      },
    },
    "Note.Model.GetNotesParam": {
      perPage: { name: "per_page", type: "Integer" },
      page: { name: "page", type: "Integer" },
      fields: { name: "fields", type: "String" },
    },
    "Function.Model.ResponseWrapper": {
      classes: [
        "Function.Model.APIException",
        "Function.Model.SuccessResponse",
      ],
      interface: !0,
    },
    "Tag.Model.RecordActionResponse": {
      classes: ["Tag.Model.SuccessResponse", "Tag.Model.APIException"],
      interface: !0,
    },
    "Note.Model.GetNotesHeader": {
      IfModifiedSince: {
        name: "If-Modified-Since",
        type: "DateTime",
        required: !0,
      },
    },
    "Tag.Model.MergeWrapper": {
      tags: {
        structure_name: "Tag.Model.ConflictWrapper",
        name: "tags",
        "max-length": 1,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "Function.Model.BodyWrapper": { body: { name: "body", type: "Map" } },
    "Tax.Model.BodyWrapper": {
      taxes: {
        structure_name: "Tax.Model.Tax",
        name: "taxes",
        "max-length": 100,
        type: "List",
        required: !0,
        "min-length": 1,
      },
    },
    "ContactRole.Model.ResponseHandler": {
      classes: [
        "ContactRole.Model.ResponseWrapper",
        "ContactRole.Model.APIException",
      ],
      interface: !0,
    },
    "Profile.Model.Category": {
      displayLabel: { name: "display_label", type: "String" },
      permissionsDetails: { name: "permissions_details", type: "List" },
      name: { name: "name", type: "String" },
    },
    "Record.Model.LineItemProduct": {
      productCode: { name: "Product_Code", type: "String" },
      name: { name: "name", type: "String" },
      currency: { name: "Currency", type: "String" },
    },
    "ShareRecord.Model.DeleteActionWrapper": {
      share: {
        structure_name: "ShareRecord.Model.DeleteActionResponse",
        name: "share",
        interface: !0,
        type: "ShareRecord.Model.DeleteActionResponse",
      },
    },
    "Variable.Model.Variable": {
      apiName: {
        "required-in-update": !1,
        name: "api_name",
        type: "String",
        primary: !0,
      },
      variableGroup: {
        structure_name: "VariableGroup.Model.VariableGroup",
        "skip-mandatory": !0,
        name: "variable_group",
        type: "VariableGroup.Model.VariableGroup",
        required: !0,
      },
      name: { name: "name", type: "String", required: !0 },
      description: { name: "description", type: "String" },
      id: { name: "id", type: "Long", primary: !0 },
      type: { name: "type", type: "String", required: !0 },
      value: { name: "value", type: "Object" },
    },
    "ShareRecord.Model.ResponseWrapper": {
      share: {
        structure_name: "ShareRecord.Model.ShareRecord",
        name: "share",
        type: "List",
      },
      shareableUser: {
        structure_name: "User.Model.User",
        name: "shareable_user",
        type: "List",
      },
    },
    "Variable.Model.GetVariableForAPINameParam": {
      group: { name: "group", type: "String", required: !0 },
    },
    "Layout.Model.Section": {
      displayLabel: { name: "display_label", type: "String" },
      sequenceNumber: { name: "sequence_number", type: "Integer" },
      issubformsection: { name: "isSubformSection", type: "Boolean" },
      tabTraversal: { name: "tab_traversal", type: "Integer" },
      apiName: { name: "api_name", type: "String" },
      generatedType: { name: "generated_type", type: "String" },
      name: { name: "name", type: "String" },
      columnCount: { name: "column_count", type: "Integer" },
      fields: {
        structure_name: "Field.Model.Field",
        name: "fields",
        type: "List",
      },
      properties: {
        structure_name: "Layout.Model.Properties",
        name: "properties",
        type: "Layout.Model.Properties",
      },
    },
    "User.Model.GetUserHeader": {
      IfModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
    },
    "Record.Model.ActionResponse": {
      classes: ["Record.Model.SuccessResponse", "Record.Model.APIException"],
      interface: !0,
    },
    "Tag.Model.CountWrapper": { count: { name: "count", type: "String" } },
    "Record.Model.SearchRecordsParam": {
      approved: { name: "approved", type: "String" },
      perPage: { name: "per_page", type: "Integer" },
      phone: { name: "phone", type: "String" },
      converted: { name: "converted", type: "String" },
      criteria: { name: "criteria", type: "String" },
      page: { name: "page", type: "Integer" },
      fields: { name: "fields", type: "String" },
      word: { name: "word", type: "String" },
      email: { name: "email", type: "String" },
    },
    "BulkRead.Model.RequestWrapper": {
      query: {
        structure_name: "BulkRead.Model.Query",
        name: "query",
        type: "BulkRead.Model.Query",
        required: !0,
      },
      callback: {
        structure_name: "BulkRead.Model.CallBack",
        name: "callback",
        type: "BulkRead.Model.CallBack",
      },
      fileType: {
        values: ["ics", "csv"],
        name: "file_type",
        type: "util.Model.Choice",
      },
    },
    "User.Model.ResponseWrapper": {
      users: { structure_name: "User.Model.User", name: "users", type: "List" },
      info: {
        structure_name: "User.Model.Info",
        name: "info",
        type: "User.Model.Info",
      },
    },
    "RelatedRecord.Model.GetRelatedRecordUsingExternalIDHeader": {
      xExternal: { name: "X-EXTERNAL", type: "String" },
      IfModifiedSince: { name: "If-Modified-Since", type: "DateTime" },
    },
    "Variable.Model.ResponseHandler": {
      classes: [
        "Variable.Model.ResponseWrapper",
        "Variable.Model.APIException",
      ],
      interface: !0,
    },
    "Module.Model.RelatedListProperties": {
      sortOrder: { name: "sort_order", type: "String" },
      sortBy: { name: "sort_by", type: "String" },
      fields: { name: "fields", type: "List" },
    },
    "RelatedList.Model.RelatedList": {
      displayLabel: { name: "display_label", type: "String" },
      sequenceNumber: { name: "sequence_number", type: "String" },
      apiName: { name: "api_name", type: "String" },
      module: { name: "module", type: "String" },
      name: { name: "name", type: "String" },
      action: { name: "action", type: "String" },
      id: { name: "id", type: "Long", primary: !0 },
      href: { name: "href", type: "String" },
      type: { name: "type", type: "String" },
      connectedmodule: { name: "connectedmodule", type: "String" },
      linkingmodule: { name: "linkingmodule", type: "String" },
    },
    "BulkWrite.Model.SuccessResponse": {
      code: {
        values: ["FILE_UPLOAD_SUCCESS", "SUCCESS"],
        name: "code",
        type: "util.Model.Choice",
      },
      details: {
        keys: [
          { name: "file_id", type: "Long" },
          { name: "created_time", type: "DateTime" },
          { name: "id", type: "Long" },
          {
            structure_name: "User.Model.User",
            name: "created_by",
            type: "User.Model.User",
          },
        ],
        name: "details",
        type: "Map",
      },
      message: {
        values: ["file uploaded.", "success"],
        name: "message",
        type: "util.Model.Choice",
      },
      status: {
        values: ["success"],
        name: "status",
        type: "util.Model.Choice",
      },
    },
    "Org.Model.Org": {
      country: { name: "country", type: "String" },
      city: { name: "city", type: "String" },
      companyName: { name: "company_name", type: "String" },
      description: { name: "description", type: "String" },
      gappsEnabled: { name: "gapps_enabled", type: "Boolean" },
      ziaPortalId: { name: "zia_portal_id", type: "String" },
      employeeCount: { name: "employee_count", type: "String" },
      street: { name: "street", type: "String" },
      countryCode: { name: "country_code", type: "String" },
      currencyLocale: { name: "currency_locale", type: "String" },
      alias: { name: "alias", type: "String" },
      currency: { name: "currency", type: "String" },
      id: { name: "id", type: "Long", primary: !0 },
      state: { name: "state", type: "String" },
      fax: { name: "fax", type: "String" },
      primaryEmail: { name: "primary_email", type: "String" },
      zip: { name: "zip", type: "String" },
      website: { name: "website", type: "String" },
      mobile: { name: "mobile", type: "String" },
      photoId: { name: "photo_id", type: "String" },
      translationEnabled: { name: "translation_enabled", type: "Boolean" },
      currencySymbol: { name: "currency_symbol", type: "String" },
      timeZone: { name: "time_zone", type: "String" },
      privacySettings: { name: "privacy_settings", type: "Boolean" },
      zgid: { name: "zgid", type: "String" },
      licenseDetails: {
        structure_name: "Org.Model.LicenseDetails",
        name: "license_details",
        type: "Org.Model.LicenseDetails",
      },
      mcStatus: { name: "mc_status", type: "Boolean" },
      primaryZuid: { name: "primary_zuid", type: "String" },
      phone: { name: "phone", type: "String" },
      isoCode: { name: "iso_code", type: "String" },
      domainName: { name: "domain_name", type: "String" },
    },
  },
  Constants = {
    TYPE_VS_DATATYPE: new Map([
      ["map", "[object Map]"],
      ["hashmap", "[object Map]"],
      ["string", "[object String]"],
      ["list", "[object Array]"],
      ["long", "[object BigInt]"],
      ["integer", "[object Number]"],
      ["float", "[object Number]"],
      ["double", "[object Number]"],
      ["boolean", "[object Boolean]"],
      ["datetime", "[object Date]"],
      ["date", "[object Date]"],
    ]),
    SPECIAL_TYPES: new Map([
      ["DateTime", "Date"],
      ["Date", "Date"],
      ["Long", "BigInt"],
    ]),
    DEFAULT_MODULENAME_VS_APINAME: new Map([
      ["leads", "Leads"],
      ["contacts", "Contacts"],
      ["accounts", "Accounts"],
      ["deals", "Deals"],
      ["tasks", "Tasks"],
      ["events", "Events"],
      ["activities", "Activities"],
      ["calls", "Calls"],
      ["products", "Products"],
      ["quotes", "Quotes"],
      ["sales_orders", "Sales_Orders"],
      ["purchase_orders", "Purchase_Orders"],
      ["invoices", "Invoices"],
      ["campaigns", "Campaigns"],
      ["vendors", "Vendors"],
      ["price_books", "Price_Books"],
      ["cases", "Cases"],
      ["solutions", "Solutions"],
      ["visits", "Visits"],
      ["approvals", "Approvals"],
      ["notes", "Notes"],
      ["attachments", "Attachments"],
      ["actions_performed", "Actions_Performed"],
    ]),
    OAUTH_HEADER_PREFIX: "Zoho-oauthtoken ",
    AUTHORIZATION: "Authorization",
    ZOHO_SDK: "X-ZOHO-SDK",
    SDK_VERSION: "4.0.0",
    GRANT_TYPE: "grant_type",
    GRANT_TYPE_AUTH_CODE: "authorization_code",
    ACCESS_TOKEN: "access_token",
    EXPIRES_IN: "expires_in",
    EXPIRES_IN_SEC: "expires_in_sec",
    REFRESH_TOKEN: "refresh_token",
    REFRESH_TOKEN_PARAMETER: "refreshToken",
    CLIENT_ID: "client_id",
    CLIENT_SECRET: "client_secret",
    REDIRECT_URL: "redirect_uri",
    CODE: "code",
    REQUEST_METHOD_PUT: "PUT",
    REQUEST_METHOD_DELETE: "DELETE",
    REQUEST_METHOD_GET: "GET",
    REQUEST_METHOD_PATCH: "PATCH",
    REQUEST_METHOD_POST: "POST",
    REQUEST_CATEGORY_READ: "READ",
    REQUEST_CATEGORY_ACTION: "ACTION",
    REQUEST_CATEGORY_UPDATE: "UPDATE",
    REQUEST_CATEGORY_CREATE: "CREATE",
    STORAGE: "storage",
    AUTH_PROCESS: "__auth_process",
    TOKEN_INIT: "__token_init",
    ZES_CLIENT_SCOPE: "zes_client_scope",
    DATA_ACCOUNTS_URL: "data-accounts-url",
    DATA_CLIENT_ID: "data-clientid",
    DATA_SCOPE: "data-scope",
    FULL_GRANT: "full_grant",
    TRUE: "true",
    GRANTED_FOR_SESSION: "granted_for_session",
    REFRESH_URL: "/refresh",
    REDIRECT_FILE: "redirect.html",
    ACCOUNTS_URL: "&response_type=token&state=zohocrmclient&redirect_uri=",
    TOKEN_STORE_ERROR: "TOKEN STORE ERROR",
    GET_TOKEN_ERROR_MISSING_PARAMS:
      "missing auth params[clientId, redirectUri, scope]",
    CRM_ACCESS_TOKEN: "crm_access_token",
    GRANT: "GRANT",
    REFRESH: "REFRESH",
    STRING: "string",
    FIELD: "field",
    EXPECTED_TYPE: "expected-type",
    CLASS: "class",
    TOKEN_ERROR: "TOKEN ERROR",
    STRING_NAMESPACE: "String",
    SCOPE: "scope",
    GET_TOKEN_ERROR: "Exception in getting tokens - OAuthToken ",
    INVALID_CLIENT_ERROR: "INVALID CLIENT ERROR",
    ALL: "all",
    INFO: "info",
    DEBUG: "debug",
    WARN: "warn",
    ERROR: "error",
    OFF: "off",
    ENCODING: "utf8",
    NAME: "name",
    TYPE: "type",
    TYPE_ERROR: "TYPE ERROR",
    VALUES: "values",
    ACCEPTED_VALUES: "accepted-values",
    GIVEN_VALUE: "given-value",
    UNACCEPTED_VALUES_ERROR: "UNACCEPTED VALUES ERROR",
    UNIQUE: "unique",
    UNIQUE_KEY_ERROR: "UNIQUE KEY ERROR",
    MIN_LENGTH: "min-length",
    MAX_LENGTH: "max-length",
    MAXIMUM_LENGTH: "maximum-length",
    MINIMUM_LENGTH: "minimum-length",
    MINIMUM_LENGTH_ERROR: "MINIMUM LENGTH ERROR",
    REGEX: "regex",
    INSTANCE_NUMBER: "instance-number",
    REGEX_MISMATCH_ERROR: "REGEX MISMATCH ERROR",
    ACCEPTED_TYPE: "accepted_type",
    MAXIMUM_LENGTH_ERROR: "MAXIMUM LENGTH ERROR",
    INTERFACE: "interface",
    CLASSES: "classes",
    READ_ONLY: "read-only",
    REQUIRED: "required",
    MANDATORY_VALUE_MISSING_ERROR: "MANDATORY VALUE MISSING ERROR",
    MANDATORY_KEY_MISSING_ERROR: "Value missing for mandatory key: ",
    EXCEPTION_SET_KEY_MODIFIED: "Exception in calling setKeyModified",
    LIST_NAMESPACE: "list",
    MAP_NAMESPACE: "map",
    STRUCTURE_NAME: "structure_name",
    RECORD_NAMESPACE: "Record.Model.Record",
    REMINDAT_NAMESPACE: "Record.Model.RemindAt",
    FIELD_FILE_NAMESPACE: "Record.Model.FileDetails",
    USER_NAMESPACE: "User.Model.User",
    MODULE_NAMESPACE: "Module.Model.Module",
    LAYOUT_NAMESPACE: "Layout.Model.Layout",
    PARTICIPANTS: "Record.Model.Participants",
    KEY_VALUES: "keyValues",
    KEY_MODIFIED: "keyModified",
    KEYS: "keys",
    ARRAY_KEY: "[object Array]",
    MAP_KEY: "[object Map]",
    FUNCTION: "function",
    CLASS_NOT_FOUND: "CLASS NOT FOUND",
    OBJECT_TYPE: "[object Object]",
    OBJECT_KEY: "object",
    STRING_OBJECT_NAME: "[object String]",
    INTEGER_KEY: "[object Integer]",
    INTEGER_NAMESPACE: "Integer",
    CONTENT_DISPOSITION: "content-disposition",
    LONG_NAMESPACE: "Long",
    BOOLEAN_NAMESPACE: "Boolean",
    DATE_NAMESPACE: "Date",
    DATETIME_NAMESPACE: "DateTime",
    FILE_NAMESPACE: "util.StreamWrapper",
    DOUBLE_NAMESPACE: "Double",
    FLOAT_NAMESPACE: "Float",
    OBJECT_NAMESPACE: "Object",
    USER: "user",
    ENVIRONMENT: "environment",
    TOKEN: "token",
    STORE: "store",
    EMAIL_PATTERN:
      /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/,
    EMAIL: "email",
    CHOICE_NAMESPACE: "util.Model.Choice",
    MODULE: "module",
    MODULEPACKAGENAME: "modulePackageName",
    MODULEDETAILS: "moduleDetails",
    PRODUCT_DETAILS: "Product_Details",
    PRICING_DETAILS: "Pricing_Details",
    PARTICIPANT_API_NAME: "Participants",
    INVENTORY_MODULES: [
      "invoices",
      "sales_orders",
      "purchase_orders",
      "quotes",
    ],
    PRICE_BOOKS: "Price_Books",
    EVENTS: "Events",
    LAYOUT: "Layout",
    SUBFORM: "subform",
    LOOKUP: "lookup",
    SE_MODULE: "se_module",
    INVENTORY_LINE_ITEMS: "Record.Model.InventoryLineItems",
    KEYS_TO_SKIP: [
      "Created_Time",
      "Modified_Time",
      "Created_By",
      "Modified_By",
      "Tag",
    ],
    STATE: "state",
    LOCATION: "location",
    API_DOMAIN: "api_domain",
    TOKEN_KEYS: [
      "granted_for_session",
      "access_token",
      "expires_in",
      "expires_in_sec",
      "location",
      "api_domain",
      "state",
      "__token_init",
      "__auth_process",
      "externals",
      "visibility",
      "inherited",
    ],
    INITIALIZATION_ERROR: "Exception in initialization : ",
    CONTENT_TYPE: "Content-Type",
    SET_TO_CONTENT_TYPE: ["/crm/bulk/v2/read", "/crm/bulk/v2/write"],
    SET_API_URL_EXCEPTION: "Exception in setting API URL : ",
    AUTHENTICATION_EXCEPTION: "Exception in authenticating current request : ",
    FORM_REQUEST_EXCEPTION: "Exception in forming request body : ",
    API_CALL_EXCEPTION: "Exception in current API call execution : ",
    HTTP: "http",
    CONTENT_API_URL: "content.zohoapis.com",
    INVALID_URL_ERROR: "Invalid URL Error",
    ARRAY_NAME: "Array",
    NO_CONTENT_STATUS_CODE: 204,
    NOT_MODIFIED_STATUS_CODE: 304,
    LINE_TAX: "$line_tax",
    LINE_TAX_NAMESPACE: "Record.Model.LineTax",
    UNDERSCORE: "_",
    RELATED_LISTS: "Related_Lists",
    API_NAME: "api_name",
    HREF: "href",
    CALLS: "calls",
    CALL_DURATION: "call_duration",
    ACTIVITIES: "Activities",
    COMMENT_NAMESPACE: "Record.Model.Comment",
    SKIP_MANDATORY: "skip-mandatory",
    CANT_DISCLOSE: " ## can't disclose ## ",
    URL_NAME: "URL",
    HEADERS: "HEADERS",
    PARAMS: "PARAMS",
    PROXY_SETTINGS: "Proxy settings - ",
    PROXY_HOST: "Host: ",
    PROXY_PORT: "Port: ",
    PROXY_USER: "User: ",
    SDK_UNINITIALIZATION_MESSAGE: "SDK is UnInitialized",
    SDK_UNINITIALIZATION_ERROR: "SDK UNINITIALIZED ERROR",
    REQUIRED_IN_UPDATE: "required-in-update",
    PRIMARY: "primary",
    FILEBODYWRAPPER: "FileBodyWrapper",
    EXCEPTION_IS_KEY_MODIFIED: "Exception in calling isKeyModified : ",
    FILE_ERROR: "file_error",
    FILE_DOES_NOT_EXISTS: "file does not exists",
    UNSUPPORTED_IN_API: "API UNSUPPORTED OPERATION",
    UNSUPPORTED_IN_API_MESSAGE: " Operation is not supported by API",
    NULL_VALUE: "null",
    NOTES: "Notes",
    ATTACHMENTS: "$attachments",
    ATTACHMENTS_NAMESPACE: "Attachment.Model.Attachment",
    PICKLIST: "picklist",
    CONSENT_NAMESPACE: "Record.Model.Consent",
    HEADER_NULL_ERROR: "NULL HEADER ERROR",
    HEADER_INSTANCE_NULL_ERROR: "Header Instance MUST NOT be null",
    HEADER_NAME_NULL_ERROR: "NULL HEADER NAME ERROR",
    HEADER_NAME_NULL_ERROR_MESSAGE: "Header Name MUST NOT be null",
    NULL_VALUE_ERROR_MESSAGE: " MUST NOT be null",
    SDK_CONFIG_ERROR_MESSAGE: "sdkConfig MUST NOT be null.",
    HEADER_OR_PARAM_NAME: "HEADER OR PARAM",
    CLASS_KEY: "class",
    OBJECT: "Object",
    INITIALIZATION_SUCCESSFUL: "Initialization successful ",
    PACKAGE_NAMESPACE: "Record.Model.",
    COMMENTS: "Comments",
    SOLUTIONS: "Solutions",
    CASES: "Cases",
    FORMULA: "formula",
    ACCOUNTS: "Accounts",
    CRMSDK: "ZohoCRMJSSDK",
    FIELDS_LAST_MODIFIED_TIME: "FIELDS-LAST-MODIFIED-TIME",
    API_EXCEPTION: "API_EXCEPTION",
    DELETE_FIELD_FILE_ERROR:
      "Exception in deleting Current User Fields file : ",
    REFRESH_SINGLE_MODULE_FIELDS_ERROR:
      "Exception in refreshing fields of module : ",
    REFRESH_ALL_MODULE_FIELDS_ERROR:
      "Exception in refreshing fields of all modules : ",
    STREAM_WRAPPER_CLASS: "StreamWrapper.Model.StreamWrapper",
    API_ERROR_RESPONSE: "Error response : ",
    CONTENT_TYPE_HEADER: "content-type",
    FILE_BODY_WRAPPER: "FileBodyWrapper",
    MANDATORY_KEY_ERROR: "Value missing or null for mandatory key(s) :",
    MANDATORY_VALUE_ERROR: "MANDATORY VALUE ERROR",
    PRIMARY_KEY_ERROR: "Value missing or null for required key(s) : ",
    RECURRING_ACTIVITY_NAMESPACE: "Record.Model.RecurringActivity",
    CONSENT_LOOKUP: "consent_lookup",
    PRICINGDETAILS: "Record.Model.PricingDetails",
    HOSTADDRESS: "127.0.0.1",
    LOCALHOST: "localhost",
    APP: "app",
    CONTENT_API: "content.zohoapis",
    ARRAY_BUFFER: "arraybuffer",
    ZIP: "zip",
    EXCEPTION: "EXCEPTION : ",
    IS_GENERATE_REQUEST_BODY: ["PATCH", "POST", "PUT"],
    PHOTO: "photo",
    CRM: "crm",
    API_VERSION: "v2",
    PHOTO_SUPPORTED_MODULES: [
      "leads",
      "contacts",
      "accounts",
      "products",
      "vendors",
    ],
    PHOTO_UPLOAD_ERROR_MESSAGE: "The given module is not supported in API.",
    INVALID_MODULE: "INVALID_MODULE",
    TIME_OUT: "Timed out!!!",
    USER_PROXY: "proxy",
    SDK_MODULE_METADATA: "SDK-MODULE-METADATA",
    REMINDER_NAMESPACE: "Record.Model.Reminder",
    CLIENT_ID_NULL_ERROR_MESSAGE: "ClientID MUST NOT be null",
    REDIRECT_URL_NULL_ERROR_MESSAGE: "Redirect URL MUST NOT be null",
    SCOPE_NULL_ERROR_MESSAGE: "Scope MUST NOT be null",
    OAUTH_MANDATORY_KEYS: ["clientId", "redirectURL", "scope", "accessToken"],
    SKIP_MODULES: ["deals"],
    GENERATED_TYPE: "generated_type",
    GENERATED_TYPE_CUSTOM: "custom",
    UPLOAD_PHOTO_UNSUPPORTED_ERROR: "UPLOAD PHOTO UNSUPPORTED MODULE",
    UPLOAD_PHOTO_UNSUPPORTED_MESSAGE:
      "Photo Upload Operation is not supported by the module: ",
    SWITCH_USER_ERROR: "SWITCH USER ERROR",
    ENVIRONMENT_ERROR_MESSAGE: "Environment MUST NOT be null.",
    TOKEN_ERROR_MESSAGE: "Token MUST NOT be null.",
    SDK_CONFIG: "sdkConfig",
    INITIALIZATION_EXCEPTION: "Exception in initialization : ",
    USER_PROXY_ERROR: "USERPROXY ERROR",
    HOST_ERROR_MESSAGE: "Host MUST NOT be null.",
    PORT_ERROR_MESSAGE: "Port MUST NOT be null.",
    REQUEST_PROXY_ERROR: "REQUEST_PROXY ERROR",
    DATA_TYPE_ERROR: "DATA_TYPE_ERROR",
    BODY: "body",
    FUNCTIONS: "functions",
    FUNCTIONS_PATH: "/actions/execute",
    OWNER_LOOKUP: "ownerlookup",
  },
  ZCRM = {},
  Initializer = {};
async function initializeSDK(
  environment,
  sdkConfig,
  token = null,
  logger = null,
  proxy = null
) {
  let store = new TokenStore();
  try {
    if (
      null === token &&
      null !== document.getElementById(Constants.ZES_CLIENT_SCOPE)
    ) {
      let clientId = document
          .getElementById(Constants.ZES_CLIENT_SCOPE)
          .getAttribute(Constants.DATA_CLIENT_ID),
        scope = document
          .getElementById(Constants.ZES_CLIENT_SCOPE)
          .getAttribute(Constants.DATA_SCOPE);
      var path = window.location.pathname,
        redirect_url = window.location.origin,
        pathSplit = path.split("/"),
        length = pathSplit.length;
      length > 0 && (redirect_url += "/");
      for (var i = 0; i < length - 2; i++)
        "" !== pathSplit[i] &&
          pathSplit[i].trim().length > 0 &&
          !pathSplit[i].endsWith(".html") &&
          (redirect_url += pathSplit[i] + "/");
      (location.hostname !== Constants.HOSTADDRESS &&
        location.hostname !== Constants.LOCALHOST &&
        "" !== location.hostname) ||
        (redirect_url += Constants.APP + "/"),
        redirect_url.endsWith("/") || (redirect_url += "/"),
        (token = new OAuthBuilder()
          .clientId(clientId)
          .scope(scope)
          .redirectURL(redirect_url + Constants.REDIRECT_FILE)
          .build());
    }
    SDKLogger.initialize(logger),
      (Initializer.environment = environment),
      (Initializer.store = store),
      (Initializer.sdkConfig = sdkConfig),
      (Initializer.token = token),
      (Initializer.requestProxy = proxy),
      await Initializer.store.getToken(token),
      SDKLogger.log(
        Levels.INFO,
        Constants.INITIALIZATION_SUCCESSFUL.concat(environment.url).concat(".")
      );
  } catch (e) {
    throw e instanceof SDKException
      ? e
      : new SDKException(Constants.INITIALIZATION_EXCEPTION, e.toString());
  }
}
class Header {
  constructor(name, className = null) {
    (this._name = name), (this._className = className);
  }
  getName() {
    return this._name;
  }
  getClassName() {
    return this._className;
  }
}
class HeaderMap {
  constructor() {
    this._headerMap = new Map();
  }
  getHeaderMap() {
    return this._headerMap;
  }
  setHeaderMap(headerMap) {
    this._headerMap = headerMap;
  }
  async add(header, value) {
    if (null === header)
      throw new SDKException(
        Constants.HEADER_NULL_ERROR,
        Constants.HEADER_INSTANCE_NULL_ERROR
      );
    let headerName = header.getName();
    if (null === headerName)
      throw new SDKException(
        Constants.HEADER_NAME_NULL_ERROR,
        Constants.HEADER_NAME_NULL_ERROR_MESSAGE
      );
    if (null === value)
      throw new SDKException(
        Constants.HEADER_NULL_ERROR,
        headerName + Constants.NULL_VALUE_ERROR_MESSAGE
      );
    let parsedHeaderValue = null;
    if (null !== header.getClassName()) {
      let headerParamValidator = new HeaderParamValidator();
      parsedHeaderValue = await headerParamValidator.validate(header, value);
    } else
      try {
        parsedHeaderValue = await DataTypeConverter.postConvert(
          value,
          value.constructor.name
        );
      } catch (ex) {
        parsedHeaderValue = value;
      }
    if (parsedHeaderValue instanceof Map || Array.isArray(parsedHeaderValue)) {
      let coverterInstance = new JSONConverter(null);
      parsedHeaderValue = JSON.stringify(
        await coverterInstance.redirectorForObjectToJSON(parsedHeaderValue)
      );
    }
    if (
      this._headerMap.has(headerName) &&
      null !== this._headerMap.get(headerName)
    ) {
      let headerValue = this._headerMap.get(headerName);
      (headerValue = headerValue.concat(",", parsedHeaderValue.toString())),
        this._headerMap.set(headerName, headerValue);
    } else this._headerMap.set(headerName, parsedHeaderValue.toString());
  }
}
class Param {
  constructor(name, className = null) {
    (this._name = name), (this._className = className);
  }
  getName() {
    return this._name;
  }
  getClassName() {
    return this._className;
  }
}
class ParameterMap {
  constructor() {
    this._parameterMap = new Map();
  }
  getParameterMap() {
    return this._parameterMap;
  }
  setParameterMap(parameterMap) {
    this._parameterMap = parameterMap;
  }
  async add(param, value) {
    if (null === param)
      throw new SDKException(
        Constants.HEADER_NULL_ERROR,
        Constants.HEADER_INSTANCE_NULL_ERROR
      );
    let paramName = param.getName();
    if (null === paramName)
      throw new SDKException(
        Constants.HEADER_NAME_NULL_ERROR,
        Constants.HEADER_NAME_NULL_ERROR_MESSAGE
      );
    if (null === value)
      throw new SDKException(
        Constants.HEADER_NULL_ERROR,
        paramName + Constants.NULL_VALUE_ERROR_MESSAGE
      );
    let parsedParamValue = null;
    if (null !== param.getClassName()) {
      let headerParamValidator = new HeaderParamValidator();
      parsedParamValue = await headerParamValidator.validate(param, value);
    } else
      try {
        parsedParamValue = await DataTypeConverter.postConvert(
          value,
          value.constructor.name
        );
      } catch (ex) {
        parsedParamValue = value;
      }
    if (parsedParamValue instanceof Map || Array.isArray(parsedParamValue)) {
      let coverterInstance = new JSONConverter(null);
      parsedParamValue = JSON.stringify(
        await coverterInstance.redirectorForObjectToJSON(parsedParamValue)
      );
    }
    if (
      this._parameterMap.has(paramName) &&
      null != this._parameterMap.get(paramName)
    ) {
      let paramValue = this._parameterMap.get(paramName);
      (paramValue = paramValue.concat(",", parsedParamValue.toString())),
        this._parameterMap.set(paramName, paramValue);
    } else this._parameterMap.set(paramName, parsedParamValue.toString());
  }
}
var listener = 0,
  Store = class {
    getToken(token) {}
  };
class TokenStore extends Store {
  async getToken(token) {
    if (
      null !== token &&
      null !== token.getAccessToken() &&
      void 0 != token.getAccessToken()
    )
      return token.setAccessToken(token.getAccessToken()), token;
    0 === listener &&
      (window.addEventListener(
        Constants.STORAGE,
        function (reponse) {
          reponse.key !== Constants.ACCESS_TOKEN ||
            (reponse.oldValue === reponse.newValue &&
              null !== reponse.oldValue) ||
            location.reload(),
            reponse.key === Constants.ACCESS_TOKEN &&
              sessionStorage.removeItem(Constants.AUTH_PROCESS);
        },
        !1
      ),
      (listener = 1),
      sessionStorage.getItem(Constants.AUTH_PROCESS) &&
        sessionStorage.removeItem(Constants.AUTH_PROCESS)),
      Constants.TOKEN_KEYS.forEach(function (k) {
        localStorage.hasOwnProperty(k) &&
          sessionStorage.setItem(k, localStorage[k]),
          localStorage.removeItem(k);
      });
    var valueInStore = sessionStorage.getItem(Constants.ACCESS_TOKEN),
      tokenInit = sessionStorage.getItem(Constants.TOKEN_INIT);
    null !== tokenInit &&
      null !== valueInStore &&
      Date.now() >= parseInt(tokenInit) + 354e4 &&
      ((valueInStore = null),
      sessionStorage.removeItem(Constants.ACCESS_TOKEN));
    var auth_process = sessionStorage.getItem(Constants.AUTH_PROCESS);
    if (
      (null === valueInStore && null === auth_process) ||
      ("undefined" === valueInStore &&
        (null === auth_process || auth_process === Constants.TRUE))
    ) {
      var accountsUrl, clientId, scope, redirectUrl;
      if (
        (null !== Initializer.environment &&
          (accountsUrl = Initializer.environment.getAccountsUrl()),
        null !== token &&
          token.getClientId().length > 0 &&
          ((clientId = token.getClientId()),
          (scope = token.getScope()),
          (redirectUrl = token.getRedirectUrl())),
        null !== document.getElementById(Constants.ZES_CLIENT_SCOPE))
      ) {
        let accounts_url = document
          .getElementById(Constants.ZES_CLIENT_SCOPE)
          .getAttribute(Constants.DATA_ACCOUNTS_URL);
        null !== accounts_url &&
          (accounts_url.includes("/oauth/v2/auth") ||
            (accounts_url += "/oauth/v2/auth"),
          (accountsUrl = accounts_url));
      }
      var fullGrant = sessionStorage.getItem(Constants.FULL_GRANT),
        grantedForSession = sessionStorage.getItem(
          Constants.GRANTED_FOR_SESSION
        );
      if (
        (null !== sessionStorage.getItem(Constants.TOKEN_INIT) &&
          ((null !== fullGrant && Constants.TRUE === fullGrant) ||
            (null !== grantedForSession &&
              Constants.TRUE === grantedForSession)) &&
          (accountsUrl += Constants.REFRESH_URL),
        !clientId || !scope)
      )
        throw new SDKException(
          Constants.TOKEN_STORE_ERROR,
          Constants.GET_TOKEN_ERROR,
          null,
          null
        );
      sessionStorage.setItem(Constants.TOKEN_INIT, Date.now()),
        sessionStorage.removeItem(Constants.ACCESS_TOKEN),
        sessionStorage.setItem(Constants.AUTH_PROCESS, Constants.TRUE),
        window.open(
          accountsUrl +
            "?" +
            Constants.SCOPE +
            "=" +
            scope +
            "&" +
            Constants.CLIENT_ID +
            "=" +
            clientId +
            Constants.ACCOUNTS_URL +
            redirectUrl
        ),
        Constants.TOKEN_KEYS.forEach(function (k) {
          localStorage.hasOwnProperty(k) &&
            sessionStorage.setItem(k, localStorage[k]),
            localStorage.removeItem(k);
        }),
        (valueInStore = sessionStorage.getItem(Constants.ACCESS_TOKEN));
    }
    return (
      null !== token &&
        "undefined" !== valueInStore &&
        token.setAccessToken(valueInStore),
      token
    );
  }
  revokeAccess() {
    sessionStorage.removeItem(Constants.CRM_ACCESS_TOKEN);
  }
}
var Token = class {
  authenticate(urlConnection) {}
};
class OAuthBuilder {
  constructor() {
    (this._clientId = null),
      (this._redirectUrl = null),
      (this._scope = null),
      (this._accessToken = null);
  }
  clientId(clientID) {
    Utility.assertNotNull(
      clientID,
      Constants.TOKEN_ERROR,
      Constants.CLIENT_ID_NULL_ERROR_MESSAGE
    );
    var error = {};
    if (typeof clientID !== Constants.STRING)
      throw (
        ((error[Constants.FIELD] = Constants.CLIENT_ID),
        (error[Constants.EXPECTED_TYPE] = Constants.STRING),
        (error[Constants.CLASS] = OAuthToken.name),
        new SDKException(Constants.TOKEN_ERROR, null, error, null))
      );
    return (this._clientId = clientID), this;
  }
  redirectURL(redirectURL) {
    Utility.assertNotNull(
      redirectURL,
      Constants.TOKEN_ERROR,
      Constants.REDIRECT_URL_NULL_ERROR_MESSAGE
    );
    var error = {};
    if (null != redirectURL && typeof redirectURL !== Constants.STRING)
      throw (
        ((error[Constants.FIELD] = Constants.REDIRECT_URL),
        (error[Constants.EXPECTED_TYPE] = Constants.STRING),
        (error[Constants.CLASS] = OAuthToken.name),
        new SDKException(Constants.TOKEN_ERROR, null, error, null))
      );
    return (this._redirectURL = redirectURL), this;
  }
  scope(scope) {
    Utility.assertNotNull(
      scope,
      Constants.TOKEN_ERROR,
      Constants.SCOPE_NULL_ERROR_MESSAGE
    );
    var error = {};
    if (typeof scope !== Constants.STRING)
      throw (
        ((error[Constants.FIELD] = Constants.SCOPE),
        (error[Constants.EXPECTED_TYPE] = Constants.STRING),
        (error[Constants.CLASS] = OAuthToken.name),
        new SDKException(Constants.TOKEN_ERROR, null, error, null))
      );
    return (this._scope = scope), this;
  }
  accessToken(accessToken) {
    var error = {};
    if (typeof accessToken !== Constants.STRING)
      throw (
        ((error[Constants.FIELD] = Constants.ACCESS_TOKEN),
        (error[Constants.EXPECTED_TYPE] = Constants.STRING),
        (error[Constants.CLASS] = OAuthToken.name),
        new SDKException(Constants.TOKEN_ERROR, null, error, null))
      );
    return (this._accessToken = accessToken), this;
  }
  build() {
    if (
      null == this._clientId &&
      null == this._redirectUrl &&
      null == this._scope &&
      null == this._accessToken
    )
      throw new SDKException(
        Constants.MANDATORY_VALUE_ERROR,
        Constants.MANDATORY_KEY_ERROR,
        Constants.OAUTH_MANDATORY_KEYS
      );
    return new OAuthToken(
      this._clientId,
      this._redirectURL,
      this._scope,
      this._accessToken
    );
  }
}
class OAuthToken extends Token {
  constructor(clientid, redirecturl, scope, accessToken = null) {
    super(),
      (this._clientId = clientid),
      (this._redirectUrl = redirecturl),
      (this._accessToken = accessToken),
      (this._scope = scope);
  }
  getClientId() {
    return this._clientId;
  }
  getRedirectUrl() {
    return this._redirectUrl;
  }
  getAccessToken() {
    return this._accessToken;
  }
  setAccessToken(accessToken) {
    this._accessToken = accessToken;
  }
  getScope() {
    return this._scope;
  }
  async authenticate(urlConnection) {
    try {
      super.authenticate(urlConnection);
      var token = this._accessToken;
      if (null == token || void 0 == token) {
        var oauth_token = await Initializer.store.getToken(this);
        if (null === oauth_token.getAccessToken())
          throw Constants.INVALID_CLIENT_ERROR;
        token = oauth_token.getAccessToken();
      }
      urlConnection.addHeader(
        Constants.AUTHORIZATION,
        Constants.OAUTH_HEADER_PREFIX + token
      );
    } catch (err) {
      throw new SDKException(
        Constants.TOKEN_ERROR,
        Constants.GET_TOKEN_ERROR,
        null,
        err
      );
    }
  }
}
class Choice {
  constructor(value) {
    this._value = value;
  }
  getValue() {
    return this._value;
  }
}
class Utility {
  static async assertNotNull(value, errorCode, errorMessage) {
    if (null == value) throw new SDKException(errorCode, errorMessage);
  }
  static isEmpty(obj) {
    return 0 === Object.keys(obj).length;
  }
  static async fileExistsFlow(moduleAPIName, encodedName, lastModifiedTime) {
    let recordFieldDetailsJson = await LocalCache.get(encodedName);
    if (
      (1 == Initializer.sdkConfig.getAutoRefreshFields() &&
      !Utility.getModifiedModules &&
      (!recordFieldDetailsJson.hasOwnProperty(
        Constants.FIELDS_LAST_MODIFIED_TIME
      ) ||
        Utility.forceRefresh ||
        new Date().getTime() -
          recordFieldDetailsJson[Constants.FIELDS_LAST_MODIFIED_TIME] >
          36e5)
        ? ((Utility.getModifiedModules = !0),
          (lastModifiedTime =
            !this.forceRefresh &&
            recordFieldDetailsJson.hasOwnProperty(
              Constants.FIELDS_LAST_MODIFIED_TIME
            )
              ? recordFieldDetailsJson[Constants.FIELDS_LAST_MODIFIED_TIME]
              : null),
          await Utility.modifyFields(encodedName, lastModifiedTime),
          (Utility.getModifiedModules = !1))
        : 0 == Initializer.sdkConfig.getAutoRefreshFields() &&
          Utility.forceRefresh &&
          !Utility.getModifiedModules &&
          ((this.getModifiedModules = !0),
          await Utility.modifyFields(encodedName, lastModifiedTime),
          (this.getModifiedModules = !1)),
      (recordFieldDetailsJson = await LocalCache.get(encodedName)),
      !(
        null == moduleAPIName ||
        (recordFieldDetailsJson.hasOwnProperty(moduleAPIName.toLowerCase()) &&
          null != recordFieldDetailsJson[moduleAPIName.toLowerCase()])
      ))
    ) {
      await fillDataType(),
        (recordFieldDetailsJson[moduleAPIName.toLowerCase()] = {}),
        await LocalCache.set(encodedName, recordFieldDetailsJson);
      let fieldsDetails = await Utility.getFieldsDetails(moduleAPIName);
      ((recordFieldDetailsJson = await LocalCache.get(encodedName))[
        moduleAPIName.toLowerCase()
      ] = fieldsDetails),
        await LocalCache.set(encodedName, recordFieldDetailsJson);
    }
  }
  static async verifyModuleAPIName(moduleName) {
    if (
      null != moduleName &&
      Constants.DEFAULT_MODULENAME_VS_APINAME.has(moduleName.toLowerCase()) &&
      null !=
        Constants.DEFAULT_MODULENAME_VS_APINAME.get(moduleName.toLowerCase())
    )
      return Constants.DEFAULT_MODULENAME_VS_APINAME.get(
        moduleName.toLowerCase()
      );
    if (Initializer.sdkConfig.getCacheStore()) {
      let encodedName = new Converter().getEncodedFileName();
      if (await LocalCache.exist()) {
        let fieldsJSON = await LocalCache.get(encodedName);
        if (
          fieldsJSON.hasOwnProperty(Constants.SDK_MODULE_METADATA) &&
          fieldsJSON[Constants.SDK_MODULE_METADATA].hasOwnProperty(
            moduleName.toLowerCase()
          )
        ) {
          return fieldsJSON[Constants.SDK_MODULE_METADATA][
            moduleName.toLowerCase()
          ][Constants.API_NAME];
        }
      }
    } else {
      if (CommonAPIHandler.recordFieldDetails.has(moduleName.toLowerCase()))
        return;
      if (
        CommonAPIHandler.recordFieldDetails.has(Constants.SDK_MODULE_METADATA)
      ) {
        let fieldsJSON = CommonAPIHandler.recordFieldDetails.get(
          Constants.SDK_MODULE_METADATA
        );
        if (fieldsJSON.hasOwnProperty(moduleName.toLowerCase())) {
          return fieldsJSON[Constants.SDK_MODULE_METADATA][
            moduleName.toLowerCase()
          ][Constants.API_NAME];
        }
      }
    }
    return moduleName;
  }
  static async setHandlerAPIPath(moduleAPIName, handlerInstance) {
    if (null == handlerInstance) return;
    let apiPath = handlerInstance.getAPIPath();
    if (apiPath.toLowerCase().includes(moduleAPIName.toLowerCase())) {
      let apiPathSplit = apiPath.split("/");
      for (var i = 0; i < apiPathSplit.length; i++)
        apiPathSplit[i].toLowerCase() == moduleAPIName.toLowerCase()
          ? (apiPathSplit[i] = moduleAPIName)
          : Constants.DEFAULT_MODULENAME_VS_APINAME.has(
              apiPathSplit[i].toLowerCase()
            ) &&
            null !=
              Constants.DEFAULT_MODULENAME_VS_APINAME.get(
                apiPathSplit[i].toLowerCase()
              ) &&
            (apiPathSplit[i] = Constants.DEFAULT_MODULENAME_VS_APINAME.get(
              apiPathSplit[i].toLowerCase()
            ));
      (apiPath = apiPathSplit.join("/")), handlerInstance.setAPIPath(apiPath);
    }
  }
  static async getFields(moduleAPIName, handlerInstance = null) {
    (this.moduleAPIName = moduleAPIName),
      await this.getFieldsInfo(this.moduleAPIName, handlerInstance);
  }
  static async getFieldsInfo(moduleAPIName, handlerInstance = null) {
    let encodedName = null;
    await fillDataType();
    try {
      if (
        null != moduleAPIName &&
        null != (await Utility.searchJSONDetails(moduleAPIName))
      )
        return;
      if (
        null != moduleAPIName &&
        void 0 != moduleAPIName &&
        ((moduleAPIName = await Utility.verifyModuleAPIName(moduleAPIName)),
        await Utility.setHandlerAPIPath(moduleAPIName, handlerInstance),
        null != handlerInstance &&
          null == handlerInstance.getModuleAPIName() &&
          !Constants.SKIP_MODULES.includes(moduleAPIName.toLowerCase()))
      )
        return;
      if (Initializer.sdkConfig.getCacheStore())
        if (
          ((encodedName = new Converter().getEncodedFileName()),
          await LocalCache.exist())
        )
          await Utility.fileExistsFlow(moduleAPIName, encodedName, null);
        else if (1 == Initializer.sdkConfig.getAutoRefreshFields()) {
          await fillDataType(),
            (this.apiSupportedModule =
              this.apiSupportedModule.size > 0
                ? this.apiSupportedModule
                : await this.getModules(null));
          let recordFieldDetailsJson = (await LocalCache.exist())
            ? await LocalCache.get(encodedName)
            : {};
          if (
            ((recordFieldDetailsJson[Constants.FIELDS_LAST_MODIFIED_TIME] =
              new Date().getTime()),
            Object.keys(this.apiSupportedModule).length > 0)
          )
            for (let module in this.apiSupportedModule)
              if (!recordFieldDetailsJson.hasOwnProperty(module)) {
                let moduleData = this.apiSupportedModule[module];
                (recordFieldDetailsJson[module] = {}),
                  await LocalCache.set(encodedName, recordFieldDetailsJson);
                let fieldsDetails = await Utility.getFieldsDetails(
                  moduleData[Constants.API_NAME]
                );
                ((recordFieldDetailsJson = await LocalCache.get(encodedName))[
                  module
                ] = fieldsDetails),
                  await LocalCache.set(encodedName, recordFieldDetailsJson);
              }
        } else if (Utility.forceRefresh && !Utility.getModifiedModules) {
          Utility.getModifiedModules = !0;
          let recordFieldDetailsJson = {};
          await LocalCache.set(encodedName, recordFieldDetailsJson),
            await Utility.modifyFields(encodedName, null),
            (Utility.getModifiedModules = !1);
        } else {
          await fillDataType();
          let recordFieldDetailsJson = {};
          (recordFieldDetailsJson[moduleAPIName.toLowerCase()] = {}),
            await LocalCache.set(encodedName, recordFieldDetailsJson);
          let fieldsDetails = await Utility.getFieldsDetails(moduleAPIName);
          ((recordFieldDetailsJson = await LocalCache.get(encodedName))[
            moduleAPIName.toLowerCase()
          ] = fieldsDetails),
            await LocalCache.set(encodedName, recordFieldDetailsJson);
        }
      else {
        if (
          CommonAPIHandler.recordFieldDetails.has(moduleAPIName.toLowerCase())
        )
          return;
        CommonAPIHandler.recordFieldDetails.set(
          moduleAPIName.toLowerCase(),
          {}
        );
        let fieldDetails = await Utility.getFieldsDetails(moduleAPIName);
        CommonAPIHandler.recordFieldDetails.set(
          moduleAPIName.toLowerCase(),
          fieldDetails
        );
      }
    } catch (error) {
      if (Initializer.sdkConfig.getCacheStore() && (await LocalCache.exist())) {
        let recordFieldDetailsJson = await LocalCache.get(encodedName);
        recordFieldDetailsJson.hasOwnProperty(moduleAPIName.toLowerCase()) &&
          delete recordFieldDetailsJson[moduleAPIName.toLowerCase()],
          (Utility.forceRefresh || Utility.getModifiedModules) &&
            ((Utility.getModifiedModules = !1), (Utility.forceRefresh = !1)),
          await LocalCache.set(encodedName, recordFieldDetailsJson);
      }
      throw (
        (error instanceof SDKException ||
          (error = new SDKException(null, null, null, error)),
        SDKLogger.log(Levels.ERROR, Constants.EXCEPTION + error.toString()),
        error)
      );
    }
  }
  static async modifyFields(encodedName, modifiedTime) {
    let modifiedModules = await this.getModules(modifiedTime),
      recordFieldDetailsJson = await LocalCache.get(encodedName);
    if (
      ((recordFieldDetailsJson[Constants.FIELDS_LAST_MODIFIED_TIME] =
        new Date().getTime()),
      await LocalCache.set(encodedName, recordFieldDetailsJson),
      Object.keys(modifiedModules).length > 0)
    ) {
      for (let module in modifiedModules)
        recordFieldDetailsJson.hasOwnProperty(module) &&
          (await this.deleteFields(recordFieldDetailsJson, module));
      await LocalCache.set(encodedName, recordFieldDetailsJson);
      for (let module in modifiedModules) {
        let moduleMeta = modifiedModules[module];
        await Utility.getFieldsInfo(moduleMeta[Constants.API_NAME]);
      }
    }
  }
  static async deleteFields(recordFieldDetailsJson, module) {
    let subformModules = [],
      fieldsJSON = recordFieldDetailsJson[module.toLowerCase()];
    for (let keyName of Object.keys(fieldsJSON))
      if (
        fieldsJSON[keyName].hasOwnProperty(Constants.SUBFORM) &&
        1 == fieldsJSON[keyName][Constants.SUBFORM] &&
        recordFieldDetailsJson.hasOwnProperty(
          fieldsJSON[keyName][Constants.MODULE].toLowerCase()
        )
      ) {
        let subformModuleName = fieldsJSON[keyName][Constants.MODULE];
        subformModules.includes(subformModuleName) ||
          subformModules.push(subformModuleName);
      }
    if (
      (delete recordFieldDetailsJson[module.toLowerCase()],
      subformModules.length > 0)
    )
      for (let subformModule of subformModules)
        await this.deleteFields(recordFieldDetailsJson, subformModule);
  }
  static async getRelatedLists(
    relatedModuleName,
    moduleAPIName,
    commonAPIHandler
  ) {
    try {
      let isnewData = !1,
        key = (
          moduleAPIName +
          Constants.UNDERSCORE +
          Constants.RELATED_LISTS
        ).toLowerCase();
      if ((await fillDataType(), Initializer.sdkConfig.getCacheStore())) {
        var encodedName = new Converter().getEncodedFileName();
        let recordFieldDetailsJSON = null;
        if (
          !(await LocalCache.exist()) ||
          ((await LocalCache.exist()) &&
            (!(await LocalCache.get(encodedName)).hasOwnProperty(key) ||
              null == (await LocalCache.get(encodedName))[key] ||
              (await LocalCache.get(encodedName))[key].length <= 0))
        ) {
          (isnewData = !0),
            (moduleAPIName = await Utility.verifyModuleAPIName(moduleAPIName));
          let relatedListValues = await Utility.getRelatedListDetails(
            moduleAPIName
          );
          ((recordFieldDetailsJSON = (await LocalCache.exist())
            ? await LocalCache.get(encodedName)
            : {})[key] = relatedListValues),
            await LocalCache.set(encodedName, recordFieldDetailsJSON);
        }
        let moduleRelatedList = (recordFieldDetailsJSON = await LocalCache.get(
          encodedName
        )).hasOwnProperty(key)
          ? recordFieldDetailsJSON[key]
          : {};
        (await Utility.checkRelatedListExists(
          relatedModuleName,
          moduleRelatedList,
          commonAPIHandler
        )) ||
          isnewData ||
          (delete recordFieldDetailsJSON[key],
          await LocalCache.set(encodedName, recordFieldDetailsJSON),
          await Utility.getRelatedLists(
            relatedModuleName,
            moduleAPIName,
            commonAPIHandler
          ));
      } else {
        if (
          CommonAPIHandler.recordFieldDetails.size <= 0 ||
          (CommonAPIHandler.recordFieldDetails.size > 0 &&
            (!CommonAPIHandler.recordFieldDetails.has(key) ||
              null == CommonAPIHandler.recordFieldDetails.get(key) ||
              CommonAPIHandler.recordFieldDetails.get(key).length <= 0))
        ) {
          (isnewData = !0),
            (moduleAPIName = await Utility.verifyModuleAPIName(moduleAPIName));
          let relatedListValues = await Utility.getRelatedListDetails(
            moduleAPIName
          );
          CommonAPIHandler.recordFieldDetails.set(key, relatedListValues);
        }
        let moduleRelatedList = CommonAPIHandler.recordFieldDetails.has(key)
          ? CommonAPIHandler.recordFieldDetails.get(key)
          : {};
        (await Utility.checkRelatedListExists(
          relatedModuleName,
          moduleRelatedList,
          commonAPIHandler
        )) ||
          isnewData ||
          (CommonAPIHandler.recordFieldDetails.delete(key),
          await Utility.getRelatedLists(
            relatedModuleName,
            moduleAPIName,
            commonAPIHandler
          ));
      }
    } catch (error) {
      throw (
        (error instanceof SDKException ||
          (error = new SDKException(null, null, null, error)),
        SDKLogger.log(Levels.ERROR, Constants.EXCEPTION + error.toString()),
        error)
      );
    }
  }
  static async checkRelatedListExists(
    relatedModuleName,
    modulerelatedListArray,
    commonAPIHandler
  ) {
    for (let index = 0; index < modulerelatedListArray.length; index++) {
      let relatedListObject = modulerelatedListArray[index];
      if (
        null != relatedListObject[Constants.API_NAME] &&
        relatedListObject[Constants.API_NAME].toLowerCase() ==
          relatedModuleName.toLowerCase()
      ) {
        if (
          relatedListObject[Constants.HREF].toString().toLowerCase() ==
          Constants.NULL_VALUE
        )
          throw new SDKException(
            Constants.UNSUPPORTED_IN_API,
            commonAPIHandler.getHttpMethod() +
              " " +
              commonAPIHandler.getAPIPath() +
              Constants.UNSUPPORTED_IN_API_MESSAGE
          );
        return (
          relatedListObject[Constants.MODULE].toString().toLowerCase() !=
            Constants.NULL_VALUE &&
            (commonAPIHandler.setModuleAPIName(
              relatedListObject[Constants.MODULE]
            ),
            await Utility.getFieldsInfo(
              relatedListObject[Constants.MODULE],
              commonAPIHandler
            )),
          !0
        );
      }
    }
    return !1;
  }
  static async getRelatedListDetails(moduleAPIName) {
    var relatedListArray = [],
      response = await new ZCRM.RelatedList.Operations(
        moduleAPIName
      ).getRelatedLists();
    if (null != response) {
      if (response.getStatusCode() == Constants.NO_CONTENT_STATUS_CODE)
        return relatedListArray;
      let responseObject = await response.getObject();
      if (null == responseObject) {
        let errorResponse = {};
        throw (
          ((errorResponse.code = response.getStatusCode()),
          new SDKException(Constants.API_EXCEPTION, null, errorResponse))
        );
      }
      if (responseObject instanceof ZCRM.RelatedList.Model.ResponseWrapper) {
        let relatedLists = await responseObject.getRelatedLists();
        for (let relatedList of relatedLists) {
          let relatedListDetail = {};
          (relatedListDetail[Constants.API_NAME] =
            await relatedList.getAPIName()),
            (relatedListDetail[Constants.MODULE] =
              null != (await relatedList.getModule())
                ? relatedList.getModule()
                : Constants.NULL_VALUE),
            (relatedListDetail[Constants.NAME] = await relatedList.getName()),
            (relatedListDetail[Constants.HREF] =
              null != (await relatedList.getHref())
                ? relatedList.getHref()
                : Constants.NULL_VALUE),
            relatedListArray.push(relatedListDetail);
        }
      } else if (
        responseObject instanceof ZCRM.RelatedList.Model.APIException
      ) {
        let errorResponse = {};
        throw (
          ((errorResponse.code = await responseObject.getCode().getValue()),
          (errorResponse.status = await responseObject.getStatus().getValue()),
          (errorResponse.message = await responseObject
            .getMessage()
            .getValue()),
          new SDKException(Constants.API_EXCEPTION, null, errorResponse))
        );
      }
    }
    return relatedListArray;
  }
  static async getFieldsDetails(moduleAPIName) {
    var fields = {},
      fieldsDetails = {},
      fieldOperation = new ZCRM.Field.Operations(moduleAPIName),
      response = await fieldOperation.getFields(null);
    if (null != response) {
      if (response.getStatusCode() == Constants.NO_CONTENT_STATUS_CODE)
        return fieldsDetails;
      let responseObject = await response.getObject();
      if (null == responseObject) {
        let errorResponse = {};
        throw (
          ((errorResponse.code = response.getStatusCode()),
          new SDKException(Constants.API_EXCEPTION, null, errorResponse))
        );
      }
      if (responseObject instanceof ZCRM.Field.Model.ResponseWrapper) {
        fields = await responseObject.getFields();
        for (let field of fields) {
          let keyName = await field.getAPIName();
          if (Constants.KEYS_TO_SKIP.includes(keyName)) continue;
          let fieldDetail = {};
          await Utility.setDataType(fieldDetail, field, moduleAPIName),
            (fieldsDetails[field.getAPIName()] = fieldDetail);
        }
        if (Constants.INVENTORY_MODULES.includes(moduleAPIName.toLowerCase())) {
          let fieldDetail = {};
          (fieldDetail.name = Constants.LINE_TAX),
            (fieldDetail.type = Constants.LIST_NAMESPACE),
            (fieldDetail.structure_name = Constants.LINE_TAX_NAMESPACE),
            (fieldsDetails[Constants.LINE_TAX] = fieldDetail);
        }
        if (Constants.NOTES.toLowerCase() == moduleAPIName.toLowerCase()) {
          let fieldDetail = {};
          (fieldDetail.name = Constants.ATTACHMENTS),
            (fieldDetail.type = Constants.LIST_NAMESPACE),
            (fieldDetail.structure_name = Constants.ATTACHMENTS_NAMESPACE),
            (fieldsDetails[Constants.ATTACHMENTS] = fieldDetail);
        }
      } else if (responseObject instanceof ZCRM.Field.Model.APIException) {
        let errorResponse = {};
        (errorResponse.code = await responseObject.getCode().getValue()),
          (errorResponse.status = await responseObject.getStatus().getValue()),
          (errorResponse.message = await responseObject
            .getMessage()
            .getValue());
        let exception = new SDKException(
          Constants.API_EXCEPTION,
          null,
          errorResponse
        );
        if (
          null != this.moduleAPIname &&
          this.moduleAPIName.toLowerCase() == moduleAPIName.toLowerCase()
        )
          throw exception;
        SDKLogger.log(Levels.ERROR, exception.toString());
      }
    }
    return fieldsDetails;
  }
  static async searchJSONDetails(key) {
    key = Constants.PACKAGE_NAMESPACE + key;
    for (let keyInJSON in classDetailMap)
      if (keyInJSON.toLowerCase() === key.toLowerCase()) {
        let returnJSON = {};
        return (
          (returnJSON[Constants.MODULEPACKAGENAME] = keyInJSON),
          (returnJSON[Constants.MODULEDETAILS] = classDetailMap[keyInJSON]),
          returnJSON
        );
      }
    return null;
  }
  static async verifyPhotoSupport(moduleAPIName) {
    try {
      if (
        ((moduleAPIName = await Utility.verifyModuleAPIName(moduleAPIName)),
        Constants.PHOTO_SUPPORTED_MODULES.includes(moduleAPIName.toLowerCase()))
      )
        return !0;
      let modules = await Utility.getModuleNames();
      if (
        modules.hasOwnProperty(moduleAPIName.toLowerCase()) &&
        null != modules[moduleAPIName.toLowerCase()]
      ) {
        let moduleMetaData = modules[moduleAPIName.toLowerCase()];
        if (
          moduleMetaData.hasOwnProperty(Constants.GENERATED_TYPE) &&
          moduleMetaData[Constants.GENERATED_TYPE] !=
            Constants.GENERATED_TYPE_CUSTOM
        )
          throw new SDKException(
            Constants.UPLOAD_PHOTO_UNSUPPORTED_ERROR,
            Constants.UPLOAD_PHOTO_UNSUPPORTED_MESSAGE + moduleAPIName
          );
      }
    } catch (error) {
      throw (
        (error instanceof SDKException ||
          (error = new SDKException(null, null, null, error)),
        Logger.error(Constants.EXCEPTION, error),
        error)
      );
    }
    return !0;
  }
  static async getModuleNames() {
    let moduleData = {};
    if (Initializer.sdkConfig.getCacheStore()) {
      let encodedName = new Converter().getEncodedFileName();
      if (!(await LocalCache.exist()))
        return (
          (moduleData = await Utility.getModules(null)),
          await Utility.writeModuleMetaData(encodedName, moduleData),
          moduleData
        );
      if (await LocalCache.exist()) {
        let recordFieldDetailsJson = await LocalCache.get(encodedName);
        if (
          !recordFieldDetailsJson.hasOwnProperty(
            Constants.SDK_MODULE_METADATA
          ) ||
          (recordFieldDetailsJson.hasOwnProperty(
            Constants.SDK_MODULE_METADATA
          ) &&
            (null == recordFieldDetailsJson[Constants.SDK_MODULE_METADATA] ||
              Object.keys(recordFieldDetailsJson[Constants.SDK_MODULE_METADATA])
                .length <= 0))
        )
          return (
            (moduleData = await Utility.getModules(null)),
            await Utility.writeModuleMetaData(encodedName, moduleData),
            moduleData
          );
      }
      return (await LocalCache.get(encodedName))[Constants.SDK_MODULE_METADATA];
    }
    return CommonAPIHandler.recordFieldDetails.size <= 0
      ? moduleData
      : !CommonAPIHandler.recordFieldDetails.has(
          Constants.SDK_MODULE_METADATA
        ) ||
        (CommonAPIHandler.recordFieldDetails.has(
          Constants.SDK_MODULE_METADATA
        ) &&
          (null ==
            CommonAPIHandler.recordFieldDetails.get(
              Constants.SDK_MODULE_METADATA
            ) ||
            Object.keys(
              CommonAPIHandler.recordFieldDetails.get(
                Constants.SDK_MODULE_METADATA
              )
            ).length <= 0))
      ? ((moduleData = await Utility.getModules(null)),
        CommonAPIHandler.recordFieldDetails.set(
          Constants.SDK_MODULE_METADATA,
          moduleData
        ),
        moduleData)
      : CommonAPIHandler.recordFieldDetails.get(Constants.SDK_MODULE_METADATA);
  }
  static async writeModuleMetaData(encodedName, moduleData) {
    let fieldDetailsJSON = (await LocalCache.exist())
      ? await LocalCache.get(encodedName)
      : {};
    (fieldDetailsJSON[Constants.SDK_MODULE_METADATA] = moduleData),
      await LocalCache.set(encodedName, fieldDetailsJSON);
  }
  static async getModules(header) {
    let apiNames = {},
      headerMap = new HeaderMap();
    null !== header &&
      (await headerMap.add(
        ZCRM.Module.Model.GetModulesHeader.IF_MODIFIED_SINCE,
        new Date(header)
      ));
    let response = await new ZCRM.Module.Operations().getModules(headerMap);
    if (null !== response) {
      if (
        [
          Constants.NO_CONTENT_STATUS_CODE,
          Constants.NOT_MODIFIED_STATUS_CODE,
        ].includes(response.getStatusCode())
      )
        return apiNames;
      let responseObject = await response.getObject();
      if (null === responseObject) {
        let errorResponse = {};
        throw (
          ((errorResponse.code = response.getStatusCode()),
          new SDKException(Constants.API_EXCEPTION, null, errorResponse, null))
        );
      }
      if (responseObject instanceof ZCRM.Module.Model.ResponseWrapper) {
        responseObject.getModules().forEach(async (module) => {
          if (1 == module.getAPISupported()) {
            let moduleDetails = {};
            (moduleDetails[Constants.API_NAME] = await module.getAPIName()),
              (moduleDetails[Constants.GENERATED_TYPE] = await module
                .getGeneratedType()
                .getValue()),
              (apiNames[await module.getAPIName().toLowerCase()] =
                moduleDetails);
          }
        });
      } else if (responseObject instanceof ZCRM.Module.Model.APIException) {
        let errorResponse = {};
        throw (
          ((errorResponse.code = responseObject.getCode().getValue()),
          (errorResponse.status = responseObject.getStatus().getValue()),
          (errorResponse.message = responseObject.getMessage().getValue()),
          new SDKException(Constants.API_EXCEPTION, null, errorResponse))
        );
      }
    }
    if (null == header)
      try {
        if (Initializer.sdkConfig.getCacheStore()) {
          let encodedName = new Converter().getEncodedFileName();
          await Utility.writeModuleMetaData(encodedName, apiNames);
        } else
          CommonAPIHandler.recordFieldDetails.set(
            Constants.SDK_MODULE_METADATA,
            apiNames
          );
      } catch (error) {
        throw (
          (error instanceof SDKException ||
            (error = new SDKException(null, null, null, error)),
          Logger.error(Constants.EXCEPTION, error),
          error)
        );
      }
    return apiNames;
  }
  static async refreshModules() {
    (Utility.forceRefresh = !0),
      await Utility.getFieldsInfo(null),
      (Utility.forceRefresh = !1);
  }
  static async getJSONObject(json, key) {
    return json.has(key) ? json.get(key) : null;
  }
  static async setDataType(fieldDetail, field, moduleAPIName) {
    var apiType = field.getDataType(),
      keyName = field.getAPIName(),
      module = "";
    if (
      (null === field.getSystemMandatory() ||
        !0 !== field.getSystemMandatory() ||
        (moduleAPIName.toLowerCase() === Constants.CALLS &&
          keyName.toLowerCase() === Constants.CALL_DURATION) ||
        (fieldDetail.required = !0),
      keyName.toLowerCase() === Constants.PRODUCT_DETAILS.toLowerCase() &&
        Constants.INVENTORY_MODULES.includes(moduleAPIName.toLowerCase()))
    )
      return (
        (fieldDetail.name = keyName),
        (fieldDetail.type = Constants.LIST_NAMESPACE),
        (fieldDetail.structure_name = Constants.INVENTORY_LINE_ITEMS),
        void (fieldDetail[Constants.SKIP_MANDATORY] = !0)
      );
    if (
      keyName.toLowerCase() === Constants.PRICING_DETAILS.toLowerCase() &&
      moduleAPIName.toLowerCase() == Constants.PRICE_BOOKS.toLowerCase()
    )
      return (
        (fieldDetail.name = keyName),
        (fieldDetail.type = Constants.LIST_NAMESPACE),
        (fieldDetail.structure_name = Constants.PRICINGDETAILS),
        void (fieldDetail[Constants.SKIP_MANDATORY] = !0)
      );
    if (
      keyName.toLowerCase() === Constants.PARTICIPANT_API_NAME.toLowerCase() &&
      (moduleAPIName.toLowerCase() === Constants.EVENTS.toLowerCase() ||
        moduleAPIName.toLowerCase() === Constants.ACTIVITIES.toLowerCase())
    )
      return (
        (fieldDetail.name = keyName),
        (fieldDetail.type = Constants.LIST_NAMESPACE),
        (fieldDetail.structure_name = Constants.PARTICIPANTS),
        void (fieldDetail[Constants.SKIP_MANDATORY] = !0)
      );
    if (
      keyName.toLowerCase() === Constants.COMMENTS.toLowerCase() &&
      (moduleAPIName.toLowerCase() === Constants.SOLUTIONS.toLowerCase() ||
        moduleAPIName.toLowerCase() === Constants.CASES.toLowerCase())
    )
      return (
        (fieldDetail.name = keyName),
        (fieldDetail.type = Constants.LIST_NAMESPACE),
        (fieldDetail.structure_name = Constants.COMMENT_NAMESPACE),
        void (fieldDetail[Constants.LOOKUP] = !0)
      );
    if (keyName.toLowerCase() === Constants.LAYOUT.toLowerCase())
      return (
        (fieldDetail.name = keyName),
        (fieldDetail.type = Constants.LAYOUT_NAMESPACE),
        (fieldDetail.structure_name = Constants.LAYOUT_NAMESPACE),
        void (fieldDetail[Constants.LOOKUP] = !0)
      );
    if (Utility.apiTypeVsdataType.has(apiType))
      fieldDetail.type = Utility.apiTypeVsdataType.get(apiType);
    else {
      if (apiType.toLowerCase() !== Constants.FORMULA.toLowerCase()) return;
      if (null !== field.getFormula()) {
        let returnType = field.getFormula().getReturnType();
        Utility.apiTypeVsdataType.has(returnType) &&
          null !== Utility.apiTypeVsdataType.get(returnType) &&
          (fieldDetail.type = Utility.apiTypeVsdataType.get(returnType));
      }
      fieldDetail[Constants.READ_ONLY] = !0;
    }
    if (
      (apiType.toLowerCase().includes(Constants.LOOKUP) &&
        (fieldDetail[Constants.LOOKUP] = !0),
      (apiType.toLowerCase() !== Constants.CONSENT_LOOKUP &&
        apiType.toLowerCase() != Constants.OWNER_LOOKUP) ||
        (fieldDetail[Constants.SKIP_MANDATORY] = !0),
      Utility.apiTypeVsStructureName.has(apiType) &&
        (fieldDetail.structure_name =
          Utility.apiTypeVsStructureName.get(apiType)),
      apiType.toLowerCase() === Constants.PICKLIST &&
        null !== field.getPickListValues() &&
        field.getPickListValues().length > 0)
    ) {
      let values = [];
      (fieldDetail[Constants.PICKLIST] = !0),
        field
          .getPickListValues()
          .every((x) => values.push(x.getDisplayValue())),
        (fieldDetail.values = values);
    }
    apiType.toLowerCase() === Constants.SUBFORM.toLowerCase() &&
      null !== field.getSubform() &&
      ((module = field.getSubform().getModule()),
      (fieldDetail[Constants.MODULE] = module),
      (fieldDetail[Constants.SKIP_MANDATORY] = !0),
      (fieldDetail[Constants.SUBFORM] = !0)),
      apiType === Constants.LOOKUP &&
        (null !== field.getLookup() &&
          (null !== (module = field.getLookup().getModule()) &&
          module !== Constants.SE_MODULE
            ? ((fieldDetail.module = module),
              module.toLowerCase() !== Constants.ACCOUNTS.toLowerCase() ||
                field.getCustomField() ||
                (fieldDetail[Constants.SKIP_MANDATORY] = !0))
            : (module = "")),
        (fieldDetail.lookup = !0)),
      module.length > 0 && (await Utility.getFieldsInfo(module)),
      (fieldDetail.name = keyName);
  }
  static checkInteger(value) {
    return parseInt(value) === value;
  }
}
async function fillDataType() {
  if (
    Utility.apiTypeVsdataType.size > 0 &&
    Utility.apiTypeVsStructureName.size > 0
  )
    return;
  let fieldAPINamesString = [
      "textarea",
      "text",
      "website",
      "email",
      "phone",
      "mediumtext",
      "multiselectlookup",
      "profileimage",
      "autonumber",
    ],
    fieldAPINamesInteger = ["integer"],
    fieldAPINamesBoolean = ["boolean"],
    fieldAPINamesLong = ["long", "bigint"],
    fieldAPINamesDouble = ["double", "percent", "lookup", "currency"],
    fieldAPINamesFile = ["imageupload"],
    fieldAPINamesFieldFile = ["fileupload"],
    fieldAPINamesDateTime = ["datetime", "event_reminder"],
    fieldAPINamesDate = ["date"],
    fieldAPINamesLookup = ["lookup"],
    fieldAPINamesPickList = ["picklist"],
    fieldAPINamesMultiSelectPickList = ["multiselectpicklist"],
    fieldAPINamesSubForm = ["subform"],
    fieldAPINamesOwnerLookUp = ["ownerlookup", "userlookup"],
    fieldAPINamesMultiUserLookUp = ["multiuserlookup"],
    fieldAPINamesMultiModuleLookUp = ["multimodulelookup"],
    fieldAPINameTaskRemindAt = ["ALARM"],
    fieldAPINameRecurringActivity = ["RRULE"],
    fieldAPINameReminder = ["multireminder"],
    fieldAPINameConsentLookUp = ["consent_lookup"];
  for (let fieldAPIName of fieldAPINamesString)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.STRING_NAMESPACE);
  for (let fieldAPIName of fieldAPINamesInteger)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.INTEGER_NAMESPACE);
  for (let fieldAPIName of fieldAPINamesBoolean)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.BOOLEAN_NAMESPACE);
  for (let fieldAPIName of fieldAPINamesLong)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.LONG_NAMESPACE);
  for (let fieldAPIName of fieldAPINamesDouble)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.DOUBLE_NAMESPACE);
  for (let fieldAPIName of fieldAPINamesFile)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.FILE_NAMESPACE);
  for (let fieldAPIName of fieldAPINamesDateTime)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.DATETIME_NAMESPACE);
  for (let fieldAPIName of fieldAPINamesDate)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.DATE_NAMESPACE);
  for (let fieldAPIName of fieldAPINamesLookup)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.RECORD_NAMESPACE),
      Utility.apiTypeVsStructureName.set(
        fieldAPIName,
        Constants.RECORD_NAMESPACE
      );
  for (let fieldAPIName of fieldAPINamesPickList)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.CHOICE_NAMESPACE);
  for (let fieldAPIName of fieldAPINamesMultiSelectPickList)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.LIST_NAMESPACE),
      Utility.apiTypeVsStructureName.set(
        fieldAPIName,
        Constants.CHOICE_NAMESPACE
      );
  for (let fieldAPIName of fieldAPINamesSubForm)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.LIST_NAMESPACE),
      Utility.apiTypeVsStructureName.set(
        fieldAPIName,
        Constants.RECORD_NAMESPACE
      );
  for (let fieldAPIName of fieldAPINamesOwnerLookUp)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.USER_NAMESPACE),
      Utility.apiTypeVsStructureName.set(
        fieldAPIName,
        Constants.USER_NAMESPACE
      );
  for (let fieldAPIName of fieldAPINamesMultiUserLookUp)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.LIST_NAMESPACE),
      Utility.apiTypeVsStructureName.set(
        fieldAPIName,
        Constants.USER_NAMESPACE
      );
  for (let fieldAPIName of fieldAPINamesMultiModuleLookUp)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.LIST_NAMESPACE),
      Utility.apiTypeVsStructureName.set(
        fieldAPIName,
        Constants.MODULE_NAMESPACE
      );
  for (let fieldAPIName of fieldAPINamesFieldFile)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.LIST_NAMESPACE),
      Utility.apiTypeVsStructureName.set(
        fieldAPIName,
        Constants.FIELD_FILE_NAMESPACE
      );
  for (let fieldAPIName of fieldAPINameTaskRemindAt)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.REMINDAT_NAMESPACE),
      Utility.apiTypeVsStructureName.set(
        fieldAPIName,
        Constants.REMINDAT_NAMESPACE
      );
  for (let fieldAPIName of fieldAPINameRecurringActivity)
    Utility.apiTypeVsdataType.set(
      fieldAPIName,
      Constants.RECURRING_ACTIVITY_NAMESPACE
    ),
      Utility.apiTypeVsStructureName.set(
        fieldAPIName,
        Constants.RECURRING_ACTIVITY_NAMESPACE
      );
  for (let fieldAPIName of fieldAPINameReminder)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.LIST_NAMESPACE),
      Utility.apiTypeVsStructureName.set(
        fieldAPIName,
        Constants.REMINDER_NAMESPACE
      );
  for (let fieldAPIName of fieldAPINameConsentLookUp)
    Utility.apiTypeVsdataType.set(fieldAPIName, Constants.CONSENT_NAMESPACE),
      Utility.apiTypeVsStructureName.set(
        fieldAPIName,
        Constants.CONSENT_NAMESPACE
      );
}
(Utility.apiTypeVsdataType = new Map()),
  (Utility.apiTypeVsStructureName = new Map()),
  (Utility.getModifiedModules = !1),
  (Utility.forceRefresh = !1),
  (Utility.apiSupportedModule = new Map()),
  (Utility.moduleAPIName = null);
class ModuleFieldsHandler {
  static async deleteFieldsFile() {
    try {
      let encodedFileName = await new Converter().getEncodedFileName();
      await LocalCache.removeKey(encodedFileName);
    } catch (error) {
      let exception = new SDKException(null, null, null, error);
      throw (
        (SDKLogger.log(
          Levels.ERROR,
          Constants.DELETE_FIELD_FILE_ERROR,
          exception
        ),
        exception)
      );
    }
  }
  static async deleteFields(module) {
    try {
      let encodedFileName = await new Converter().getEncodedFileName(),
        recordFieldDetailsJson = await LocalCache.get(encodedFileName);
      recordFieldDetailsJson.hasOwnProperty(module.toLowerCase()) &&
        (await Utility.deleteFields(recordFieldDetailsJson, module),
        await LocalCache.set(encodedFileName, recordFieldDetailsJson));
    } catch (error) {
      throw new SDKException(null, null, null, error);
    }
  }
  static async refreshFields(module) {
    try {
      await ModuleFieldsHandler.deleteFields(module),
        await Utility.getFieldsInfo(module);
    } catch (error) {
      throw (
        (error instanceof SDKException ||
          (error = new SDKException(null, null, null, error)),
        SDKLogger.log(
          Levels.ERROR,
          Constants.REFRESH_SINGLE_MODULE_FIELDS_ERROR + module,
          error
        ),
        error)
      );
    }
  }
  static async refreshAllModules() {
    try {
      await Utility.refreshModules();
    } catch (error) {
      throw (
        (error instanceof SDKException ||
          (error = new SDKException(null, null, null, error)),
        SDKLogger.log(
          Levels.ERROR,
          Constants.REFRESH_ALL_MODULE_FIELDS_ERROR,
          error
        ),
        error)
      );
    }
  }
}
class HeaderParamValidator {
  async validate(headerparam, value) {
    let name = headerparam.getName(),
      className = headerparam.getClassName(),
      typeDetail = null;
    if (
      (classDetailMap.hasOwnProperty(className) &&
        (typeDetail = await this.getKeyJSONDetails(
          name,
          classDetailMap[className]
        )),
      null != typeDetail)
    ) {
      if (!(await this.checkDataType(typeDetail, value))) {
        let detailsJO = {};
        throw (
          ((detailsJO[
            null != className && className.endsWith("param")
              ? "PARAMETER"
              : "HEADER"
          ] = name),
          (detailsJO[Constants.CLASS_KEY] = className),
          (detailsJO[Constants.ACCEPTED_TYPE] =
            Constants.SPECIAL_TYPES.hasOwnProperty(typeDetail[Constants.TYPE])
              ? Constants.SPECIAL_TYPES.get(typeDetail[Constants.TYPE])
              : typeDetail[Constants.TYPE]),
          new SDKException(Constants.TYPE_ERROR, null, detailsJO))
        );
      }
      value = await DataTypeConverter.postConvert(
        value,
        typeDetail[Constants.TYPE]
      );
    }
    return value;
  }
  async getKeyJSONDetails(name, jsonDetails) {
    let keyArray = Array.from(Object.keys(jsonDetails));
    for (let index = 0; index < keyArray.length; index++) {
      const key = keyArray[index];
      let detail = await jsonDetails[key];
      if (
        detail.hasOwnProperty(Constants.NAME) &&
        name.toLowerCase() === detail[Constants.NAME].toLowerCase()
      )
        return detail;
    }
    return {};
  }
  checkDataType(keyDetail, value) {
    let type = keyDetail[Constants.TYPE],
      dataType = Constants.SPECIAL_TYPES.has(type)
        ? Constants.SPECIAL_TYPES.get(type)
        : type;
    if (
      null !== dataType &&
      Constants.TYPE_VS_DATATYPE.has(dataType.toLowerCase())
    ) {
      if (type === Constants.INTEGER_NAMESPACE)
        return Utility.checkInteger(value);
      if (
        Object.prototype.toString.call(value) !==
        Constants.TYPE_VS_DATATYPE.get(type.toLowerCase())
      )
        return !1;
    }
    return !0;
  }
}
var Converter = class {
  constructor(commonAPIHandler) {
    this.commonAPIHandler = commonAPIHandler;
  }
  getResponse(response, pack) {}
  formRequest(requestObject, pack, instanceNumber, memberDetail) {}
  appendToRequest(requestBase) {}
  getWrappedResponse(response, pack) {}
  valueChecker(
    className,
    memberName,
    keyDetails,
    value,
    uniqueValuesMap,
    instanceNumber
  ) {
    var detailsJO = {},
      name = keyDetails[Constants.NAME],
      type = keyDetails[Constants.TYPE],
      valueType = Object.prototype.toString.call(value);
    let check = !0,
      givenType = null;
    if (Constants.TYPE_VS_DATATYPE.has(type.toLowerCase()))
      if (
        Array.isArray(value) &&
        value.length > 0 &&
        keyDetails.hasOwnProperty(Constants.STRUCTURE_NAME)
      ) {
        let expectedStructure = keyDetails[Constants.STRUCTURE_NAME],
          index = 0;
        for (let data of value) {
          if (
            ((className = Object.prototype.toString.call(data)) ==
            Constants.OBJECT_TYPE
              ? ((className = data.constructor.name),
                (check = expectedStructure.includes(className)))
              : (check = className === expectedStructure),
            !check)
          ) {
            (instanceNumber = index),
              (type = Constants.ARRAY_NAME + "(" + expectedStructure + ")"),
              (givenType = Constants.ARRAY_NAME + "(" + className + ")");
            break;
          }
          index += 1;
        }
      } else
        null != value &&
          ((check =
            valueType == Constants.TYPE_VS_DATATYPE.get(type.toLowerCase())) &&
            type == Constants.INTEGER_NAMESPACE &&
            (check = Utility.checkInteger(value)),
          (givenType = Object.getPrototypeOf(value).constructor.name));
    else if (null != value && type.toLowerCase() !== Constants.OBJECT_KEY) {
      let expectedStructure = keyDetails[Constants.TYPE];
      (className = Object.prototype.toString.call(value)) ==
      Constants.OBJECT_TYPE
        ? ((className = value.constructor.name),
          (check = expectedStructure.includes(className)))
        : (check = className === expectedStructure),
        check ||
          ((type = expectedStructure), (givenType = value.constructor.name));
    }
    if (!check && null !== value)
      throw (
        ((detailsJO.field = memberName),
        (detailsJO.class = className),
        (detailsJO.expected_type = Constants.SPECIAL_TYPES.has(type)
          ? Constants.SPECIAL_TYPES.get(type)
          : type),
        (detailsJO.given_type = givenType),
        null != instanceNumber && (detailsJO.index = instanceNumber),
        new SDKException(Constants.TYPE_ERROR, null, detailsJO))
      );
    if (
      keyDetails.hasOwnProperty(Constants.VALUES) &&
      (!keyDetails.hasOwnProperty(Constants.PICKLIST) ||
        (keyDetails[Constants.PICKLIST] &&
          1 == Initializer.sdkConfig.getPickListValidation()))
    ) {
      let valuesJA = keyDetails[Constants.VALUES];
      if (
        (value instanceof Choice && (value = value.getValue()),
        !valuesJA.includes(value))
      )
        throw (
          ((detailsJO.field = memberName),
          (detailsJO.class = className),
          null != instanceNumber && (detailsJO.index = instanceNumber),
          (detailsJO.given_value = value),
          (detailsJO.accepted_values = valuesJA),
          new SDKException(Constants.UNACCEPTED_VALUES_ERROR, null, detailsJO))
        );
    }
    if (keyDetails.hasOwnProperty(Constants.UNIQUE)) {
      let valuesArray = uniqueValuesMap[name];
      if (null != valuesArray && valuesArray.includes(value))
        throw (
          ((detailsJO.field = memberName),
          (detailsJO.class = className),
          (detailsJO.first_index = valuesArray.indexOf(value)),
          (detailsJO.next_index = instanceNumber),
          new SDKException(Constants.UNIQUE_KEY_ERROR, null, detailsJO))
        );
      null == valuesArray && (valuesArray = []),
        valuesArray.push(value),
        (uniqueValuesMap[name] = valuesArray);
    }
    if (
      keyDetails.hasOwnProperty(Constants.MIN_LENGTH) ||
      keyDetails.hasOwnProperty(Constants.MAX_LENGTH)
    ) {
      let count = value.toString().length;
      if (
        (Array.isArray(value) && (count = value.length),
        keyDetails.hasOwnProperty(Constants.MAX_LENGTH) &&
          count > keyDetails[Constants.MAX_LENGTH])
      )
        throw (
          ((detailsJO.field = memberName),
          (detailsJO.class = className),
          (detailsJO.given_length = count),
          (detailsJO.maximum_length = keyDetails[Constants.MAX_LENGTH]),
          new SDKException(Constants.MAXIMUM_LENGTH_ERROR, null, detailsJO))
        );
      if (
        keyDetails.hasOwnProperty(Constants.MIN_LENGTH) &&
        count < keyDetails[Constants.MIN_LENGTH]
      )
        throw (
          ((detailsJO.field = memberName),
          (detailsJO.class = className),
          (detailsJO.given_length = count),
          (detailsJO.minimum_length = keyDetails[Constants.MIN_LENGTH]),
          new SDKException(Constants.MINIMUM_LENGTH_ERROR, null, detailsJO))
        );
    }
    if (
      keyDetails.hasOwnProperty(Constants.REGEX) &&
      !keyDetails[Constants.REGEX].match(value)
    )
      throw (
        ((detailsJO.field = memberName),
        (detailsJO.class = className),
        null != instanceNumber && (detailsJO.index = instanceNumber),
        new SDKException(Constants.REGEX_MISMATCH_ERROR, null, detailsJO))
      );
    return !0;
  }
  getEncodedFileName() {
    let clientId = "",
      url = Initializer.environment.getUrl();
    return (
      null !== Initializer.token &&
        Initializer.token.getClientId().length > 0 &&
        (clientId = Initializer.token.getClientId()),
      null !== document.getElementById(Constants.ZES_CLIENT_SCOPE) &&
        (clientId = document
          .getElementById(Constants.ZES_CLIENT_SCOPE)
          .getAttribute(Constants.DATA_CLIENT_ID)),
      btoa(clientId + url)
    );
  }
};
class JSONConverter extends Converter {
  constructor(commonAPIHandler) {
    super(commonAPIHandler), (this.uniqueValuesMap = {});
  }
  appendToRequest(request) {
    return (
      super.appendToRequest(request),
      JSON.stringify(request.getRequestBody()) || null
    );
  }
  async formRequest(requestInstance, pack, instanceNumber, classMemberDetail) {
    super.formRequest(requestInstance, pack, instanceNumber, classMemberDetail);
    var classDetail = classDetailMap[pack];
    if (
      classDetail.hasOwnProperty(Constants.INTERFACE) &&
      classDetail[Constants.INTERFACE]
    ) {
      var classes = classDetail[Constants.CLASSES],
        baseName = pack.split("/").slice(0, -1);
      let className = await this.getFileName(requestInstance.constructor.name);
      baseName.push(className);
      let requestObjectClassName = baseName.join("/");
      for (let className1 of classes)
        if (className1.toLowerCase() == requestObjectClassName.toLowerCase()) {
          classDetail = classDetailMap[requestObjectClassName];
          break;
        }
    }
    if (requestInstance instanceof ZCRM.Record.Model.Record) {
      let moduleAPIName = this.commonAPIHandler.getModuleAPIName(),
        returnJSON = await this.isRecordRequest(
          requestInstance,
          classDetail,
          instanceNumber,
          classMemberDetail
        );
      return this.commonAPIHandler.setModuleAPIName(moduleAPIName), returnJSON;
    }
    return await this.isNotRecordRequest(
      requestInstance,
      classDetail,
      instanceNumber,
      classMemberDetail
    );
  }
  async isNotRecordRequest(
    requestInstance,
    classDetail,
    instanceNumber,
    classMemberDetail
  ) {
    let requestJSON = {},
      requiredKeys = new Map(),
      primaryKeys = new Map(),
      requiredInUpdateKeys = new Map(),
      lookUp = !1,
      skipMandatory = !1,
      classMemberName = null;
    null != classMemberDetail &&
      ((lookUp =
        !!classMemberDetail.hasOwnProperty(Constants.LOOKUP) &&
        classMemberDetail[Constants.LOOKUP]),
      (skipMandatory =
        !!classMemberDetail.hasOwnProperty(Constants.SKIP_MANDATORY) &&
        classMemberDetail[Constants.SKIP_MANDATORY]),
      (classMemberName = this.buildName(classMemberDetail[Constants.NAME])));
    for (let memberName in classDetail) {
      var modification = null,
        memberDetail = classDetail[memberName];
      if (
        (!memberDetail.hasOwnProperty(Constants.READ_ONLY) ||
          "true" !== memberDetail[Constants.READ_ONLY]) &&
        memberDetail.hasOwnProperty(Constants.NAME)
      ) {
        var keyName = memberDetail[Constants.NAME];
        try {
          modification = requestInstance.isKeyModified(keyName);
        } catch (ex) {
          throw new SDKException(
            Constants.EXCEPTION_IS_KEY_MODIFIED,
            null,
            null,
            ex
          );
        }
        memberDetail.hasOwnProperty(Constants.REQUIRED) &&
          1 == memberDetail[Constants.REQUIRED] &&
          requiredKeys.set(keyName, !0),
          !memberDetail.hasOwnProperty(Constants.PRIMARY) ||
            1 != memberDetail[Constants.PRIMARY] ||
            (memberDetail.hasOwnProperty(Constants.REQUIRED_IN_UPDATE) &&
              1 != memberDetail[Constants.REQUIRED_IN_UPDATE]) ||
            primaryKeys.set(keyName, !0),
          memberDetail.hasOwnProperty(Constants.REQUIRED_IN_UPDATE) &&
            1 == memberDetail[Constants.REQUIRED_IN_UPDATE] &&
            requiredInUpdateKeys.set(keyName, !0);
        var fieldValue = null;
        if (
          null != modification &&
          0 != parseInt(modification) &&
          ((fieldValue = Reflect.get(requestInstance, memberName)),
          await this.valueChecker(
            requestInstance.constructor.name,
            memberName,
            memberDetail,
            fieldValue,
            this.uniqueValuesMap,
            instanceNumber
          ))
        )
          if (
            (null != fieldValue &&
              (requiredKeys.delete(keyName),
              primaryKeys.delete(keyName),
              requiredInUpdateKeys.delete(keyName)),
            requestInstance instanceof ZCRM.Record.Model.FileDetails)
          )
            requestJSON[keyName.toLowerCase()] =
              null == fieldValue || "null" == fieldValue ? null : fieldValue;
          else {
            if (
              keyName.toLowerCase() == Constants.BODY &&
              this.commonAPIHandler
                .getAPIPath()
                .includes(Constants.FUNCTIONS_PATH) &&
              this.commonAPIHandler.getAPIPath().includes(Constants.FUNCTIONS)
            )
              return await this.setData(memberDetail, fieldValue);
            requestJSON[keyName] = await this.setData(memberDetail, fieldValue);
          }
      }
    }
    if (
      skipMandatory ||
      (await this.checkException(
        classMemberName,
        requestInstance,
        instanceNumber,
        lookUp,
        requiredKeys,
        primaryKeys,
        requiredInUpdateKeys
      ))
    )
      return requestJSON;
  }
  async checkException(
    memberName,
    requestInstance,
    instanceNumber,
    lookUp,
    requiredKeys,
    primaryKeys,
    requiredInUpdateKeys
  ) {
    if (
      requiredInUpdateKeys.size > 0 &&
      null != this.commonAPIHandler.getCategoryMethod() &&
      this.commonAPIHandler.getCategoryMethod().toLowerCase() ==
        Constants.REQUEST_CATEGORY_UPDATE.toLowerCase()
    ) {
      let error = {};
      throw (
        ((error.field = memberName),
        (error.type = requestInstance.constructor.name),
        (error.keys = Array.from(requiredInUpdateKeys.keys()).toString()),
        null != instanceNumber && (error.instance_number = instanceNumber),
        new SDKException(
          Constants.MANDATORY_VALUE_ERROR,
          Constants.MANDATORY_KEY_ERROR,
          error,
          null
        ))
      );
    }
    if (
      null != this.commonAPIHandler.isMandatoryChecker() &&
      this.commonAPIHandler.isMandatoryChecker()
    ) {
      if (
        this.commonAPIHandler.getCategoryMethod().toLowerCase() ==
        Constants.REQUEST_CATEGORY_CREATE.toLowerCase()
      )
        if (lookUp) {
          if (primaryKeys.size > 0) {
            let error = {};
            throw (
              ((error.field = memberName),
              (error.type = requestInstance.constructor.name),
              (error.keys = Array.from(primaryKeys.keys()).toString()),
              null != instanceNumber &&
                (error.instance_number = instanceNumber),
              new SDKException(
                Constants.MANDATORY_VALUE_ERROR,
                Constants.PRIMARY_KEY_ERROR,
                error,
                null
              ))
            );
          }
        } else if (requiredKeys.size > 0) {
          let error = {};
          throw (
            ((error.field = memberName),
            (error.type = requestInstance.constructor.name),
            (error.keys = Array.from(requiredKeys.keys()).toString()),
            null != instanceNumber && (error.instance_number = instanceNumber),
            new SDKException(
              Constants.MANDATORY_VALUE_ERROR,
              Constants.MANDATORY_KEY_ERROR,
              error,
              null
            ))
          );
        }
      if (
        this.commonAPIHandler.getCategoryMethod().toUpperCase() ==
          Constants.REQUEST_CATEGORY_UPDATE &&
        primaryKeys.size > 0
      ) {
        let error = {};
        throw (
          ((error.field = memberName),
          (error.type = requestInstance.constructor.name),
          (error.keys = Array.from(primaryKeys.keys()).toString()),
          null != instanceNumber && (error.instance_number = instanceNumber),
          new SDKException(
            Constants.MANDATORY_VALUE_ERROR,
            Constants.PRIMARY_KEY_ERROR,
            error,
            null
          ))
        );
      }
    } else if (
      lookUp &&
      this.commonAPIHandler.getCategoryMethod().toLowerCase() ==
        Constants.REQUEST_CATEGORY_UPDATE.toLowerCase() &&
      primaryKeys.size > 0
    ) {
      let error = {};
      throw (
        ((error.field = memberName),
        (error.type = requestInstance.constructor.name),
        (error.keys = Array.from(primaryKeys.keys()).toString()),
        null != instanceNumber && (error.instance_number = instanceNumber),
        new SDKException(
          Constants.MANDATORY_VALUE_ERROR,
          Constants.PRIMARY_KEY_ERROR,
          error,
          null
        ))
      );
    }
    return !0;
  }
  async isRecordRequest(
    recordInstance,
    classDetail,
    instanceNumber,
    classMemberDetail
  ) {
    var requestJSON = {},
      moduleDetail = {},
      lookUp = !1,
      skipMandatory = !1,
      classMemberName = null;
    null != classMemberDetail &&
      ((lookUp =
        !!classMemberDetail.hasOwnProperty(Constants.LOOKUP) &&
        classMemberDetail[Constants.LOOKUP]),
      (skipMandatory =
        !!classMemberDetail.hasOwnProperty(Constants.SKIP_MANDATORY) &&
        classMemberDetail[Constants.SKIP_MANDATORY]),
      (classMemberName = this.buildName(classMemberDetail[Constants.NAME])));
    var moduleAPIName = this.commonAPIHandler.getModuleAPIName();
    if (null != moduleAPIName) {
      this.commonAPIHandler.setModuleAPIName(null);
      let fullDetail = await Utility.searchJSONDetails(moduleAPIName);
      moduleDetail =
        null != fullDetail
          ? fullDetail[Constants.MODULEDETAILS]
          : await this.getModuleDetailFromUserSpecJSON(moduleAPIName);
    } else
      (moduleDetail = classDetail),
        (classDetail = classDetailMap[Constants.RECORD_NAMESPACE]);
    "Record" ===
      Object.getPrototypeOf(Object.getPrototypeOf(recordInstance)).constructor
        .name &&
      Object.setPrototypeOf(recordInstance, ZCRM.Record.Model.Record.prototype),
      null == moduleDetail && (moduleDetail = {});
    var keyValues = new Map();
    keyValues = Reflect.get(recordInstance, Constants.KEY_VALUES);
    var keyModified = new Map();
    keyModified = Reflect.get(recordInstance, Constants.KEY_MODIFIED);
    var requiredKeys = new Map(),
      primaryKeys = new Map();
    if (!skipMandatory) {
      for (let keyName of Object.keys(moduleDetail)) {
        let keyDetail = moduleDetail[keyName],
          name = keyDetail[Constants.NAME];
        null != keyDetail &&
          keyDetail.hasOwnProperty(Constants.REQUIRED) &&
          1 == keyDetail[Constants.REQUIRED] &&
          requiredKeys.set(name, !0),
          null != keyDetail &&
            keyDetail.hasOwnProperty(Constants.PRIMARY) &&
            1 == keyDetail[Constants.PRIMARY] &&
            primaryKeys.set(name, !0);
      }
      for (let keyName of Object.keys(classDetail)) {
        let keyDetail = classDetail[keyName],
          name = keyDetail[Constants.NAME];
        null != keyDetail &&
          keyDetail.hasOwnProperty(Constants.REQUIRED) &&
          1 == keyDetail[Constants.REQUIRED] &&
          requiredKeys.set(name, !0),
          null != keyDetail &&
            keyDetail.hasOwnProperty(Constants.PRIMARY) &&
            1 == keyDetail[Constants.PRIMARY] &&
            primaryKeys.set(name, !0);
      }
    }
    for (let keyName of Array.from(keyModified.keys())) {
      if (1 != keyModified.get(keyName)) continue;
      let keyDetail = {},
        keyValue = keyValues.has(keyName) ? keyValues.get(keyName) : null,
        jsonValue = null;
      null != keyValue &&
        (requiredKeys.delete(keyName), primaryKeys.delete(keyName));
      let memberName = this.buildName(keyName);
      if (
        (null != moduleDetail &&
        Object.keys(moduleDetail).length > 0 &&
        (moduleDetail.hasOwnProperty(keyName) ||
          moduleDetail.hasOwnProperty(memberName))
          ? (keyDetail = moduleDetail.hasOwnProperty(keyName)
              ? moduleDetail[keyName]
              : moduleDetail[memberName])
          : classDetail.hasOwnProperty(memberName) &&
            (keyDetail = classDetail[memberName]),
        Object.keys(keyDetail).length > 0)
      ) {
        if (
          (keyDetail.hasOwnProperty(Constants.READ_ONLY) &&
            (1 == keyDetail[Constants.READ_ONLY] ||
              "true" == keyDetail[Constants.READ_ONLY])) ||
          !keyDetail.hasOwnProperty(Constants.NAME)
        )
          continue;
        (await this.valueChecker(
          recordInstance.constructor.name,
          keyName,
          keyDetail,
          keyValue,
          this.uniqueValuesMap,
          instanceNumber
        )) && (jsonValue = await this.setData(keyDetail, keyValue));
      } else jsonValue = await this.redirectorForObjectToJSON(keyValue);
      requestJSON[keyName] = jsonValue;
    }
    if (
      skipMandatory ||
      (await this.checkException(
        classMemberName,
        recordInstance,
        instanceNumber,
        lookUp,
        requiredKeys,
        primaryKeys,
        new Map()
      ))
    )
      return requestJSON;
  }
  async setData(memberDetail, fieldValue) {
    if (null != fieldValue) {
      let type = memberDetail[Constants.TYPE].toString();
      return type.toLowerCase() === Constants.LIST_NAMESPACE.toLowerCase()
        ? await this.setJSONArray(fieldValue, memberDetail)
        : type.toLowerCase() === Constants.MAP_NAMESPACE.toLowerCase()
        ? await this.setJSONObject(fieldValue, memberDetail)
        : type.toLowerCase() === Constants.CHOICE_NAMESPACE.toLowerCase() ||
          (memberDetail.hasOwnProperty(Constants.STRUCTURE_NAME) &&
            memberDetail[Constants.STRUCTURE_NAME].toLowerCase() ==
              Constants.CHOICE_NAMESPACE.toLowerCase())
        ? fieldValue.getValue()
        : memberDetail.hasOwnProperty(Constants.STRUCTURE_NAME) &&
          memberDetail.hasOwnProperty(Constants.MODULE)
        ? await this.isRecordRequest(
            fieldValue,
            await this.getModuleDetailFromUserSpecJSON(
              memberDetail[Constants.MODULE]
            ),
            null,
            memberDetail
          )
        : memberDetail.hasOwnProperty(Constants.STRUCTURE_NAME)
        ? await this.formRequest(
            fieldValue,
            memberDetail[Constants.STRUCTURE_NAME],
            null,
            memberDetail
          )
        : await DataTypeConverter.postConvert(fieldValue, type);
    }
    return null;
  }
  async setJSONObject(fieldValue, memberDetail) {
    var jsonObject = {},
      requestObject = fieldValue;
    if (Array.from(requestObject.keys()).length > 0)
      if (
        null == memberDetail ||
        (null != memberDetail && !memberDetail.hasOwnProperty(Constants.KEYS))
      )
        for (let key of Array.from(requestObject.keys()))
          jsonObject[key] = await this.redirectorForObjectToJSON(
            requestObject.get(key)
          );
      else if (
        null !== memberDetail &&
        memberDetail.hasOwnProperty(Constants.KEYS)
      ) {
        var keysDetail = memberDetail[Constants.KEYS];
        for (let keyIndex = 0; keyIndex < keysDetail.length; keyIndex++) {
          let keyDetail = keysDetail[keyIndex],
            keyName = keyDetail[Constants.NAME],
            keyValue = null;
          requestObject.has(keyName) &&
            null != requestObject.get(keyName) &&
            ((keyValue = await this.setData(
              keyDetail,
              requestObject.get(keyName)
            )),
            (jsonObject[keyName] = keyValue));
        }
      }
    return jsonObject;
  }
  async setJSONArray(fieldValue, memberDetail) {
    var jsonArray = [],
      requestObjects = fieldValue;
    if (requestObjects.length > 0)
      if (
        null == memberDetail ||
        (null != memberDetail &&
          !memberDetail.hasOwnProperty(Constants.STRUCTURE_NAME))
      )
        for (let request of requestObjects)
          jsonArray.push(await this.redirectorForObjectToJSON(request));
      else {
        let pack = memberDetail[Constants.STRUCTURE_NAME].toString();
        if (pack == Constants.CHOICE_NAMESPACE)
          for (let request of requestObjects)
            jsonArray.push(request.getValue());
        else if (
          memberDetail.hasOwnProperty(Constants.MODULE) &&
          null != memberDetail[Constants.MODULE]
        ) {
          let instanceCount = 0;
          for (let request of requestObjects)
            jsonArray.push(
              await this.isRecordRequest(
                request,
                await this.getModuleDetailFromUserSpecJSON(
                  memberDetail[Constants.MODULE]
                ),
                instanceCount,
                memberDetail
              )
            ),
              instanceCount++;
        } else {
          let instanceCount = 0;
          for (let request of requestObjects)
            jsonArray.push(
              await this.formRequest(request, pack, instanceCount, memberDetail)
            ),
              instanceCount++;
        }
      }
    return jsonArray;
  }
  async redirectorForObjectToJSON(request) {
    return Array.isArray(request)
      ? await this.setJSONArray(request, null)
      : request instanceof Map
      ? await this.setJSONObject(request, null)
      : request;
  }
  async getWrappedResponse(response, pack) {
    if ((super.getWrappedResponse(response, pack), null != response.response)) {
      let responseObject = response.response;
      if (responseObject.valueOf() instanceof ArrayBuffer) {
        let binary = "",
          bytes = new Uint8Array(responseObject),
          len = bytes.byteLength;
        for (var i = 0; i < len; i++)
          binary += await String.fromCharCode(bytes[i]);
        responseObject = binary;
      }
      if (
        null != responseObject &&
        "" != responseObject.toString() &&
        Object.keys(responseObject).length > 0
      )
        return await this.getResponse(JSON.parse(responseObject), pack);
    }
    return null;
  }
  async getResponse(response, packageName) {
    super.getResponse(response, packageName);
    var instance = null;
    if (
      null == response ||
      "" == response ||
      0 === Object.keys(response).length
    )
      return instance;
    var responseJson = response,
      classDetail = classDetailMap[packageName];
    if (
      classDetail.hasOwnProperty(Constants.INTERFACE) &&
      classDetail[Constants.INTERFACE]
    ) {
      let classes = classDetail[Constants.CLASSES];
      instance = await this.findMatch(classes, responseJson);
    } else {
      if (
        (instance = new (this.stringToFunction(packageName))()) instanceof
        ZCRM.Record.Model.Record
      ) {
        let moduleAPIName = this.commonAPIHandler.getModuleAPIName();
        (instance = await this.isRecordResponse(
          responseJson,
          classDetail,
          packageName
        )),
          this.commonAPIHandler.setModuleAPIName(moduleAPIName);
      } else
        instance = await this.notRecordResponse(
          instance,
          responseJson,
          classDetail
        );
    }
    return instance;
  }
  async notRecordResponse(instance, responseJson, classDetail) {
    for (let memberName in classDetail) {
      let keyDetail = classDetail[memberName],
        keyName = keyDetail.hasOwnProperty(Constants.NAME)
          ? keyDetail[Constants.NAME]
          : null;
      if (
        null != keyName &&
        responseJson.hasOwnProperty(keyName) &&
        null !== responseJson[keyName]
      ) {
        let keyData = responseJson[keyName],
          memberValue = await this.getData(keyData, keyDetail);
        Reflect.set(instance, memberName, memberValue);
      }
    }
    return instance;
  }
  async isRecordResponse(responseJson, classDetail, pack) {
    let recordInstance = new (this.stringToFunction(pack))(),
      moduleAPIName = this.commonAPIHandler.getModuleAPIName(),
      moduleDetail = {};
    if (null != moduleAPIName) {
      this.commonAPIHandler.setModuleAPIName(null);
      let fullDetail = await Utility.searchJSONDetails(moduleAPIName);
      if (null != fullDetail) {
        (moduleDetail = fullDetail[Constants.MODULEDETAILS]),
          (recordInstance = new (this.stringToFunction(
            fullDetail[Constants.MODULEPACKAGENAME]
          ))());
      } else
        moduleDetail = await this.getModuleDetailFromUserSpecJSON(
          moduleAPIName
        );
    }
    null == moduleDetail && (moduleDetail = {});
    for (let key in classDetail) moduleDetail[key] = classDetail[key];
    let recordDetail = classDetailMap[Constants.RECORD_NAMESPACE];
    var keyValues = new Map();
    for (let keyName in responseJson) {
      let memberName = this.buildName(keyName),
        keyDetail = {};
      null != moduleDetail &&
      Object.keys(moduleDetail).length > 0 &&
      (moduleDetail.hasOwnProperty(keyName) ||
        moduleDetail.hasOwnProperty(memberName))
        ? (keyDetail = moduleDetail.hasOwnProperty(keyName)
            ? moduleDetail[keyName]
            : moduleDetail[memberName])
        : recordDetail.hasOwnProperty(memberName) &&
          (keyDetail = recordDetail[memberName]);
      let keyValue = null,
        keyData = responseJson[keyName];
      null != keyDetail && Object.keys(keyDetail).length > 0
        ? ((keyName = keyDetail[Constants.NAME]),
          (keyValue = await this.getData(keyData, keyDetail)))
        : (keyValue = await this.redirectorForJSONToObject(keyData)),
        keyValues.set(keyName, keyValue);
    }
    return (
      Reflect.set(recordInstance, Constants.KEY_VALUES, keyValues),
      recordInstance
    );
  }
  async getData(keyData, memberDetail) {
    let memberValue = null;
    if (null != keyData) {
      let type = memberDetail[Constants.TYPE].toString();
      memberValue =
        type.toLowerCase() === Constants.LIST_NAMESPACE.toLowerCase()
          ? await this.getCollectionsData(keyData, memberDetail)
          : type.toLowerCase() === Constants.MAP_NAMESPACE.toLowerCase()
          ? await this.getMapData(keyData, memberDetail)
          : type === Constants.CHOICE_NAMESPACE ||
            (memberDetail.hasOwnProperty(Constants.STRUCTURE_NAME) &&
              memberDetail[Constants.STRUCTURE_NAME].toLowerCase() ===
                Constants.CHOICE_NAMESPACE.toLowerCase())
          ? new Choice(keyData)
          : memberDetail.hasOwnProperty(Constants.STRUCTURE_NAME) &&
            memberDetail.hasOwnProperty(Constants.MODULE)
          ? await this.isRecordResponse(
              keyData,
              await this.getModuleDetailFromUserSpecJSON(
                memberDetail[Constants.MODULE]
              ),
              memberDetail[Constants.STRUCTURE_NAME]
            )
          : memberDetail.hasOwnProperty(Constants.STRUCTURE_NAME)
          ? await this.getResponse(
              keyData,
              memberDetail[Constants.STRUCTURE_NAME]
            )
          : await DataTypeConverter.preConvert(keyData, type);
    }
    return memberValue;
  }
  async getMapData(response, memberDetail) {
    var mapInstance = new Map();
    if (Object.keys(response).length > 0)
      if (
        null == memberDetail ||
        (null != memberDetail && !memberDetail.hasOwnProperty(Constants.KEYS))
      )
        for (let key in response)
          mapInstance.set(
            key,
            await this.redirectorForJSONToObject(response[key])
          );
      else if (memberDetail.hasOwnProperty(Constants.KEYS)) {
        var keysDetail = memberDetail[Constants.KEYS];
        for (let keyIndex = 0; keyIndex < keysDetail.length; keyIndex++) {
          var keyDetail = keysDetail[keyIndex],
            keyName = keyDetail[Constants.NAME],
            keyValue = null;
          response.hasOwnProperty(keyName) &&
            null != response[keyName] &&
            ((keyValue = await this.getData(response[keyName], keyDetail)),
            mapInstance.set(keyName, keyValue));
        }
      }
    return mapInstance;
  }
  async getCollectionsData(responses, memberDetail) {
    var values = new Array();
    if (responses.length > 0)
      if (
        null == memberDetail ||
        (null != memberDetail &&
          !memberDetail.hasOwnProperty(Constants.STRUCTURE_NAME))
      )
        for (let response of responses)
          values.push(await this.redirectorForJSONToObject(response));
      else {
        let pack = memberDetail[Constants.STRUCTURE_NAME];
        if (pack == Constants.CHOICE_NAMESPACE)
          for (let response of responses) values.push(new Choice(response));
        else if (
          memberDetail.hasOwnProperty(Constants.MODULE) &&
          null != memberDetail[Constants.MODULE]
        )
          for (let response of responses)
            values.push(
              await this.isRecordResponse(
                response,
                await this.getModuleDetailFromUserSpecJSON(
                  memberDetail[Constants.MODULE]
                ),
                pack
              )
            );
        else
          for (let response of responses)
            values.push(await this.getResponse(response, pack));
      }
    return values;
  }
  async getModuleDetailFromUserSpecJSON(module) {
    let moduleDetail = {};
    if (Initializer.sdkConfig.getCacheStore()) {
      var converterInstance = new Converter(),
        encodedName = await converterInstance.getEncodedFileName();
      if (await LocalCache.exist()) {
        let recordFieldDetailsJson = await LocalCache.get(encodedName);
        recordFieldDetailsJson.hasOwnProperty(module.toLowerCase()) &&
          (moduleDetail = recordFieldDetailsJson[module.toLowerCase()]);
      }
    } else {
      let json = CommonAPIHandler.recordFieldDetails;
      moduleDetail = await Utility.getJSONObject(json, module.toLowerCase());
    }
    return moduleDetail;
  }
  async redirectorForJSONToObject(keyData) {
    let type = Object.prototype.toString.call(keyData);
    return type === Constants.OBJECT_TYPE
      ? await this.getMapData(keyData, null)
      : type === Constants.ARRAY_KEY
      ? await this.getCollectionsData(keyData, null)
      : keyData;
  }
  async findMatch(classes, responseJson) {
    let pack = "",
      ratio = 0;
    for (let className of classes) {
      var matchRatio = await this.findRatio(className, responseJson);
      if (1 === matchRatio) {
        (pack = className), (ratio = 1);
        break;
      }
      matchRatio > ratio && ((pack = className), (ratio = matchRatio));
    }
    return await this.getResponse(responseJson, pack);
  }
  findRatio(className, responseJson) {
    var classDetail = classDetailMap[className],
      totalPoints = Array.from(Object.keys(classDetail)).length,
      matches = 0;
    if (0 == totalPoints) return 0;
    for (let memberName in classDetail) {
      var memberDetail = classDetail[memberName],
        keyName = memberDetail.hasOwnProperty(Constants.NAME)
          ? memberDetail[Constants.NAME]
          : null;
      if (
        null != keyName &&
        responseJson.hasOwnProperty(keyName) &&
        null != responseJson[keyName]
      ) {
        var keyData = responseJson[keyName];
        let type = Object.prototype.toString.call(keyData),
          structureName = memberDetail.hasOwnProperty(Constants.STRUCTURE_NAME)
            ? memberDetail[Constants.STRUCTURE_NAME]
            : null;
        if (
          (type.toLowerCase() == Constants.OBJECT_TYPE.toLowerCase() &&
            (type = Constants.MAP_KEY),
          Constants.TYPE_VS_DATATYPE.has(
            memberDetail[Constants.TYPE].toLowerCase()
          ) &&
            Constants.TYPE_VS_DATATYPE.get(
              memberDetail[Constants.TYPE].toLowerCase()
            ) == type)
        )
          matches++;
        else if (
          memberDetail[Constants.TYPE].toLowerCase() ==
          Constants.CHOICE_NAMESPACE.toLowerCase()
        ) {
          let values = memberDetail[Constants.VALUES];
          for (let value of values)
            if (keyData == value) {
              matches++;
              break;
            }
        }
        if (
          null != structureName &&
          structureName == memberDetail[Constants.TYPE]
        )
          if (memberDetail.hasOwnProperty(Constants.VALUES)) {
            let values = memberDetail[Constants.VALUES];
            for (let value of values)
              if (keyData == value) {
                matches++;
                break;
              }
          } else matches++;
      }
    }
    return matches / totalPoints;
  }
  buildName(memberName) {
    let name = memberName.toLowerCase().split("_");
    name.length;
    var sdkName = name[0];
    sdkName = sdkName[0].toLowerCase() + sdkName.slice(1);
    for (var nameIndex = 1; nameIndex < name.length; nameIndex++) {
      var fieldName = name[nameIndex],
        firstLetterUppercase = "";
      fieldName.length > 0 &&
        (firstLetterUppercase =
          fieldName[0].toUpperCase() + fieldName.slice(1)),
        (sdkName = sdkName.concat(firstLetterUppercase));
    }
    return sdkName;
  }
  stringToFunction(str) {
    for (
      var arr = (str = "ZCRM." + str).split("."),
        fn = window || this,
        i = 0,
        len = arr.length;
      i < len;
      i++
    )
      fn = fn[arr[i]];
    if (typeof fn !== Constants.FUNCTION)
      throw new SDKException(Constants.CLASS_NOT_FOUND, null, null, null);
    return fn;
  }
  getFileName(name) {
    let fileName = [],
      nameParts = name.split(/([A-Z][a-z]+)/).filter(function (e) {
        return e;
      });
    fileName.push(nameParts[0].toLowerCase());
    for (let i = 1; i < nameParts.length; i++)
      fileName.push(nameParts[i].toLowerCase());
    return fileName.join("_");
  }
}
class XMLConverter extends Converter {
  constructor(commonAPIHandler) {
    super(commonAPIHandler), (this.uniqueValuesMap = {});
  }
  formRequest(requestObject, pack, instanceNumber) {
    super.formRequest(requestObject, pack, instanceNumber);
  }
  appendToRequest(request) {
    super.appendToRequest(request);
  }
  getWrappedResponse(response, pack) {
    super.getWrappedResponse(response, pack);
  }
  getResponse(response, pack) {
    super.getResponse(response, pack);
  }
}
class Downloader extends Converter {
  constructor(commonApiHandler) {
    super(commonApiHandler), (this.uniqueValuesMap = {});
  }
  appendToRequest(request) {
    super.appendToRequest(request);
  }
  formRequest(requestObject, pack, instanceNumber) {
    super.formRequest(requestObject, pack, instanceNumber);
  }
  async getWrappedResponse(response, pack) {
    return (
      super.getWrappedResponse(response, pack),
      await this.getResponse(response, pack)
    );
  }
  async getResponse(response, pack) {
    super.getResponse(response, pack);
    var instance = null,
      recordJsonDetails = classDetailMap[pack];
    if (
      recordJsonDetails.hasOwnProperty(Constants.INTERFACE) &&
      recordJsonDetails[Constants.INTERFACE]
    ) {
      let classes = recordJsonDetails[Constants.CLASSES];
      for (let index = 0; index < classes.length; index++) {
        let className = classes[index];
        if (
          className
            .toString()
            .toLowerCase()
            .includes(Constants.FILE_BODY_WRAPPER.toLowerCase())
        )
          return await this.getResponse(response, className);
      }
    } else {
      instance = new (await this.stringToFunction(pack))();
      for (let memberName in recordJsonDetails) {
        var instanceValue = null;
        if (
          recordJsonDetails[memberName][Constants.TYPE] ===
          Constants.STREAM_WRAPPER_CLASS
        ) {
          var filename;
          if (
            response
              .getAllResponseHeaders()
              .indexOf(Constants.CONTENT_DISPOSITION) >= 0
          ) {
            var disposition = response.getResponseHeader(
              Constants.CONTENT_DISPOSITION
            );
            if (disposition && -1 !== disposition.indexOf("attachment")) {
              var matches = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/.exec(
                disposition
              );
              null != matches &&
                matches[1] &&
                (filename = (filename = matches[1].replace(
                  /['"]/g,
                  ""
                )).replace("UTF-8", ""));
            }
          }
          var mimeType = response.getResponseHeader(
            Constants.CONTENT_TYPE_HEADER.toLowerCase()
          );
          void 0 != mimeType && null != mimeType
            ? mimeType.includes(";") && (mimeType = mimeType.split(";")[0])
            : (mimeType = "text/plain");
          let blob = new Blob([response.response], {
            type: mimeType.toString(),
          });
          instanceValue = new StreamWrapper.Model.StreamWrapper(filename, blob);
        }
        Reflect.set(instance, memberName, instanceValue);
      }
    }
    return instance;
  }
  stringToFunction(str) {
    for (
      var arr = (str = "ZCRM." + str).split("."),
        fn = window || this,
        i = 0,
        len = arr.length;
      i < len;
      i++
    )
      fn = fn[arr[i]];
    if (typeof fn !== Constants.FUNCTION)
      throw new SDKException(Constants.CLASS_NOT_FOUND, null, null, null);
    return fn;
  }
}
class FormDataConverter extends Converter {
  constructor(commonApiHandler) {
    super(commonApiHandler), (this.uniqueValuesMap = {});
  }
  async appendToRequest(requestBase) {
    super.appendToRequest(requestBase);
    var formDataRequestBody = new FormData();
    return (
      await this.addFileBody(requestBase.getRequestBody(), formDataRequestBody),
      formDataRequestBody
    );
  }
  async addFileBody(requestObject, formData) {
    let requestKeys = Object.keys(requestObject);
    for (let key of requestKeys) {
      let value = requestObject[key],
        type = Object.prototype.toString.call(value);
      if (Array.isArray(value))
        for (let fileObject of value)
          fileObject instanceof StreamWrapper.Model.StreamWrapper
            ? formData.append(
                key,
                new Blob([fileObject.getStream()]),
                fileObject.getName()
              )
            : formData.append(key, fileObject);
      else
        value instanceof StreamWrapper.Model.StreamWrapper
          ? formData.append(key, new Blob([value.getStream()]), value.getName())
          : null != value &&
            type == Constants.OBJECT_TYPE &&
            Object.keys(value).length > 0
          ? await this.addFileBody(value, formData)
          : formData.append(key, value);
    }
  }
  async formRequest(requestInstance, pack, instanceNumber, classMemberDetail) {
    super.formRequest(requestInstance, pack, instanceNumber);
    var classDetail = classDetailMap[pack],
      request = {};
    if (
      classDetail.hasOwnProperty(Constants.INTERFACE) &&
      classDetail[Constants.INTERFACE]
    ) {
      var classes = classDetail[Constants.CLASSES],
        baseName = pack.split("/").slice(0, -1);
      let className = await this.getFileName(requestInstance.constructor.name);
      baseName.push(className);
      let requestObjectClassName = baseName.join("/");
      for (let classname of classes)
        if (classname.toLowerCase() == requestObjectClassName.toLowerCase()) {
          classDetail = classDetailMap[requestObjectClassName];
          break;
        }
    }
    for (let memberName in classDetail) {
      var modification = null,
        memberDetail = classDetail[memberName];
      if (
        (!memberDetail.hasOwnProperty(Constants.READ_ONLY) ||
          memberDetail[Constants.READ_ONLY] != Constants.TRUE) &&
        memberDetail.hasOwnProperty(Constants.NAME)
      ) {
        try {
          modification = requestInstance.isKeyModified(
            memberDetail[Constants.NAME]
          );
        } catch (e) {
          throw new SDKException(
            Constants.EXCEPTION_IS_KEY_MODIFIED,
            null,
            null,
            e
          );
        }
        if (
          (null == modification || 0 === modification) &&
          memberDetail.hasOwnProperty(Constants.REQUIRED) &&
          memberDetail[Constants.REQUIRED] == Constants.TRUE
        )
          throw new SDKException(
            Constants.MANDATORY_VALUE_MISSING_ERROR,
            Constants.MANDATORY_KEY_MISSING_ERROR + memberName
          );
        var fieldValue = Reflect.get(requestInstance, memberName);
        if (
          null != modification &&
          0 !== modification &&
          !0 ===
            (await this.valueChecker(
              requestInstance.constructor.name,
              memberName,
              memberDetail,
              fieldValue,
              this.uniqueValuesMap,
              instanceNumber
            ))
        ) {
          var keyName = memberDetail[Constants.NAME],
            type = memberDetail[Constants.TYPE];
          type.toLowerCase() == Constants.LIST_NAMESPACE.toLowerCase()
            ? (request[keyName] = await this.setJSONArray(
                fieldValue,
                memberDetail
              ))
            : type.toLowerCase() == Constants.MAP_NAMESPACE.toLowerCase()
            ? (request[keyName] = await this.setJSONObject(
                fieldValue,
                memberDetail
              ))
            : memberDetail.hasOwnProperty(Constants.STRUCTURE_NAME)
            ? (request[keyName] = await this.formRequest(
                fieldValue,
                memberDetail[Constants.STRUCTURE_NAME],
                0,
                memberDetail
              ))
            : (request[keyName] = fieldValue);
        }
      }
    }
    return request;
  }
  getFileName(name) {
    let fileName = [],
      nameParts = name.split(/([A-Z][a-z]+)/).filter(function (e) {
        return e;
      });
    fileName.push(nameParts[0].toLowerCase());
    for (let i = 1; i < nameParts.length; i++)
      fileName.push(nameParts[i].toLowerCase());
    return fileName.join("_");
  }
  async setJSONObject(fieldValue, memberDetail) {
    var jsonObject = {},
      requestObject = fieldValue;
    if (null == memberDetail)
      for (let key of Array.from(requestObject.keys()))
        jsonObject[key] = await this.redirectorForObjectToJSON(
          requestObject.get(key)
        );
    else if (memberDetail.hasOwnProperty(Constants.KEYS)) {
      var keysDetail = memberDetail[Constants.KEYS];
      for (let keyIndex = 0; keyIndex < keysDetail.length; keyIndex++) {
        let keyDetail = keysDetail[keyIndex],
          keyName = keyDetail[Constants.NAME],
          keyValue = null;
        requestObject.hasOwnProperty(keyName) &&
          null != requestObject[keyName] &&
          (keyDetail.hasOwnProperty(Constants.STRUCTURE_NAME)
            ? ((keyValue = await this.formRequest(
                requestObject[keyName],
                keyDetail[Constants.STRUCTURE_NAME],
                0,
                memberDetail
              )),
              (jsonObject[keyName] = keyValue))
            : (jsonObject[keyName] = await this.redirectorForObjectToJSON(
                requestObject[keyName]
              )));
      }
    } else
      for (let key of Array.from(requestObject.keys()))
        jsonObject[key] = await this.redirectorForObjectToJSON(
          requestObject.get(key)
        );
    return jsonObject;
  }
  async setJSONArray(fieldValue, memberDetail) {
    var jsonArray = [],
      requestObjects = fieldValue;
    if (null == memberDetail)
      for (let request of requestObjects)
        jsonArray.push(await this.redirectorForObjectToJSON(request));
    else if (memberDetail.hasOwnProperty(Constants.STRUCTURE_NAME)) {
      let instanceCount = 0,
        pack = memberDetail[Constants.STRUCTURE_NAME];
      for (let request of requestObjects)
        jsonArray.push(
          await this.formRequest(request, pack, instanceCount++, memberDetail)
        );
    } else
      for (let request of requestObjects)
        jsonArray.push(await this.redirectorForObjectToJSON(request));
    return jsonArray;
  }
  redirectorForObjectToJSON(request) {
    let type = Object.prototype.toString.call(request);
    return type.toLowerCase() == Constants.ARRAY_KEY.toLowerCase()
      ? this.setJSONArray(request, null)
      : type.toLowerCase() == Constants.MAP_KEY.toLowerCase()
      ? this.setJSONObject(request, null)
      : request;
  }
  getWrappedResponse(response, pack) {
    super.getWrappedResponse(response, pack);
  }
  getResponse(responseJson, pack) {
    super.getResponse(responseJson, pack);
  }
}
var LocalCache = {
  data: {},
  remove: async function () {
    "caches" in window && (await caches.delete(Constants.CRMSDK));
  },
  exist: async function () {
    if ("caches" in window) return await caches.has(Constants.CRMSDK);
  },
  get: async function (userKey) {
    let request = "/" + userKey + ".json",
      response = await caches.match(request);
    return void 0 != response ? await response.json() : {};
  },
  set: async function (userKey, value) {
    if ("caches" in window) {
      let cache = await caches.open(Constants.CRMSDK),
        request = "/" + userKey + ".json";
      await cache.put(request, new Response(JSON.stringify(value)));
    }
  },
  removeKey: async function (userKey) {
    if ("caches" in window) {
      let cache = await caches.open(Constants.CRMSDK),
        request = "/" + userKey + ".json";
      await cache.delete(request);
    }
  },
};
class CommonAPIHandler {
  constructor() {
    (this._apiPath = null),
      (this._param = new ParameterMap()),
      (this._header = new HeaderMap()),
      (this._request = null),
      (this._httpMethod = null),
      (this._moduleAPIName = null),
      (this._contentType = null),
      (this._categoryMethod = null),
      (this._mandatoryChecker = null);
  }
  setContentType(contentType) {
    this._contentType = contentType;
  }
  setAPIPath(apiPath) {
    this._apiPath = apiPath;
  }
  async addParam(paramInstance, paramValue) {
    null != paramValue &&
      (null == this._param && (this._param = new ParameterMap()),
      await this._param.add(paramInstance, paramValue));
  }
  async addHeader(headerInstance, headerValue) {
    null != headerValue &&
      (null == this._header && (this._header = new HeaderMap()),
      await this._header.add(headerInstance, headerValue));
  }
  setParam(param) {
    if (null != param)
      if (
        null != this._param.getParameterMap() &&
        this._param.getParameterMap().size > 0
      )
        for (let key of param.getParameterMap().keys())
          this._param
            .getParameterMap()
            .set(key, param.getParameterMap().get(key));
      else this._param = param;
  }
  getModuleAPIName() {
    return this._moduleAPIName;
  }
  setModuleAPIName(moduleAPIName) {
    this._moduleAPIName = moduleAPIName;
  }
  setHeader(header) {
    if (null != header)
      if (
        null != this._header.getHeaderMap() &&
        this._header.getHeaderMap().size > 0
      )
        for (let key of header.getHeaderMap().keys())
          this._header.getHeaderMap().set(key, header.getHeaderMap().get(key));
      else this._header = header;
  }
  setRequest(request) {
    this._request = request;
  }
  setHttpMethod(httpMethod) {
    this._httpMethod = httpMethod;
  }
  isMandatoryChecker() {
    return this._mandatoryChecker;
  }
  setMandatoryChecker(mandatoryChecker) {
    this._mandatoryChecker = mandatoryChecker;
  }
  getHttpMethod() {
    return this._httpMethod;
  }
  getCategoryMethod() {
    return this._categoryMethod;
  }
  setCategoryMethod(category) {
    this._categoryMethod = category;
  }
  getAPIPath() {
    return this._apiPath;
  }
  async apiCall(className, encodeType) {
    if (null == Initializer)
      throw new SDKException(
        Constants.SDK_UNINITIALIZATION_ERROR,
        Constants.SDK_UNINITIALIZATION_MESSAGE
      );
    var connector = new APIHTTPConnector();
    try {
      await this.setAPIUrl(connector);
    } catch (error) {
      throw (
        (error instanceof SDKException ||
          (error = new SDKException(null, null, null, error)),
        SDKLogger.log(
          Levels.ERROR,
          Constants.SET_API_URL_EXCEPTION + error.toString()
        ),
        error)
      );
    }
    connector.setRequestMethod(this._httpMethod),
      connector.setContentType(this._contentType),
      null != this._header &&
        this._header.getHeaderMap().size > 0 &&
        connector.setHeaders(this._header.getHeaderMap()),
      null != this._param &&
        this._param.getParameterMap().size > 0 &&
        connector.setParams(this._param.getParameterMap());
    try {
      await Initializer.token.authenticate(connector);
    } catch (error) {
      throw (
        (error instanceof SDKException ||
          (error = new SDKException(null, null, null, error)),
        SDKLogger.log(
          Levels.ERROR,
          Constants.AUTHENTICATION_EXCEPTION + error.toString()
        ),
        error)
      );
    }
    var returnObject = null,
      convertInstance = null;
    if (
      null != this._contentType &&
      Constants.IS_GENERATE_REQUEST_BODY.includes(
        this._httpMethod.toUpperCase()
      )
    ) {
      let request = null;
      var requestClassName = className.split(".");
      requestClassName[requestClassName.length - 1] =
        this._request.constructor.name;
      try {
        (convertInstance = await this.getConverterClassInstance(
          this._contentType.toLowerCase()
        )),
          (request = await convertInstance.formRequest(
            this._request,
            requestClassName.join("."),
            null,
            null
          ));
      } catch (error) {
        throw (
          (error instanceof SDKException ||
            (error = new SDKException(null, null, null, error)),
          SDKLogger.log(
            Levels.ERROR,
            Constants.FORM_REQUEST_EXCEPTION + error.toString()
          ),
          error)
        );
      }
      connector.setRequestBody(request);
    }
    try {
      let response = await connector.fireRequest(convertInstance);
      var statusCode = response.status,
        headerMap = await this.getHeaders(
          await response.getAllResponseHeaders()
        );
      if (
        headerMap.hasOwnProperty(Constants.CONTENT_TYPE_HEADER.toLowerCase())
      ) {
        var mimeType = headerMap[Constants.CONTENT_TYPE_HEADER];
        void 0 != mimeType &&
          null != mimeType &&
          (mimeType.includes(";") && (mimeType = mimeType.split(";")[0]),
          (convertInstance = await this.getConverterClassInstance(
            mimeType.toLowerCase()
          )),
          (returnObject = await convertInstance.getWrappedResponse(
            response,
            className
          )));
      } else
        SDKLogger.log(
          Levels.ERROR,
          Constants.API_ERROR_RESPONSE + statusCode.toString()
        );
      return new APIResponse(headerMap, statusCode, returnObject);
    } catch (error) {
      throw (
        (error instanceof SDKException ||
          (error = new SDKException(null, null, null, error)),
        SDKLogger.log(
          Levels.ERROR,
          Constants.API_CALL_EXCEPTION + error.toString()
        ),
        error)
      );
    }
  }
  async getHeaders(headers) {
    var arr = headers.trim().split(/[\r\n]+/),
      headerMap = new Map();
    return (
      arr.forEach(function (line) {
        var parts = line.split(": "),
          header = parts.shift(),
          value = parts.join(": ");
        headerMap[header] = value;
      }),
      headerMap
    );
  }
  async getConverterClassInstance(encodeType) {
    switch (encodeType) {
      case "application/json":
      case "text/plain":
      case "application/ld+json":
        return new JSONConverter(this);
      case "application/xml":
      case "text/xml":
        return new XMLConverter(this);
      case "multipart/form-data":
        return new FormDataConverter(this);
      case "image/png":
      case "image/jpeg":
      case "image/gif":
      case "image/tiff":
      case "image/svg+xml":
      case "image/bmp":
      case "image/webp":
      case "text/csv":
      case "text/html":
      case "text/css":
      case "text/javascript":
      case "text/calendar":
      case "application/x-download":
      case "application/zip":
      case "application/pdf":
      case "application/java-archive":
      case "application/javascript":
      case "application/octet-stream":
      case "application/xhtml+xml":
      case "application/x-bzip":
      case "application/msword":
      case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      case "application/gzip":
      case "application/x-httpd-php":
      case "application/vnd.ms-powerpoint":
      case "application/vnd.rar":
      case "application/x-sh":
      case "application/x-tar":
      case "application/vnd.ms-excel":
      case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      case "application/x-7z-compressed":
      case "audio/mpeg":
      case "audio/x-ms-wma":
      case "audio/vnd.rn-realaudio":
      case "audio/x-wav":
      case "audio/3gpp":
      case "audio/3gpp2":
      case "video/mpeg":
      case "video/mp4":
      case "video/webm":
      case "video/3gpp":
      case "video/3gpp2":
      case "font/ttf":
        return new Downloader(this);
    }
    return null;
  }
  async setAPIUrl(connector) {
    var apiPath = "";
    if (this._apiPath.toString().includes(Constants.HTTP))
      if (this._apiPath.includes(Constants.CONTENT_API_URL)) {
        apiPath = apiPath.concat(Initializer.environment.getFileUploadUrl());
        try {
          const myURL = new URL(this._apiPath);
          apiPath = apiPath.concat(myURL.pathname);
        } catch (error) {
          throw new SDKException(
            Constants.INVALID_URL_ERROR,
            null,
            null,
            error
          );
        }
      } else
        "/" == this._apiPath.substring(0, 1) &&
          (this._apiPath = this._apiPath.substring(1)),
          (apiPath = apiPath.concat(this._apiPath));
    else
      apiPath = (apiPath = Initializer.environment.getUrl()).concat(
        this._apiPath
      );
    connector.setUrl(apiPath);
  }
}
CommonAPIHandler.recordFieldDetails = new Map();
class APIHTTPConnector {
  constructor() {
    (this._url = null),
      (this._requestMethod = null),
      (this._headers = new Map()),
      (this._parameters = new Map()),
      (this._requestBody = {}),
      (this._contentType = null);
  }
  getContentType() {
    return this._contentType;
  }
  setContentType(contentType) {
    this._contentType = contentType;
  }
  setUrl(url) {
    this._url = url;
  }
  setRequestMethod(httpMethod) {
    this._requestMethod = httpMethod;
  }
  getHeaders() {
    return this._headers;
  }
  setHeaders(headers) {
    this._headers = headers;
  }
  addHeader(headerName, headerValue) {
    this._headers.set(headerName, headerValue);
  }
  getParams() {
    return this._parameters;
  }
  setParams(params) {
    this._parameters = params;
  }
  addParam(paramName, paramValue) {
    this._parameters.set(paramName, paramValue);
  }
  setRequestBody(requestBody) {
    this._requestBody = requestBody;
  }
  getRequestBody() {
    return this._requestBody;
  }
  async fireRequest(converterInstance) {
    var apiHeaders = {},
      modifiedRequestBody = "";
    null != this._contentType && (await this.setContentTypeHeader()),
      this._headers &&
        this._headers.forEach(function (value, key) {
          apiHeaders[key] = value;
        });
    var baseUrl = this._url;
    null != this._parameters &&
      this._parameters.size > 0 &&
      (baseUrl = await this.setQueryParams(this._parameters)),
      Array.from(Object.keys(this._requestBody)).length > 0 &&
        (modifiedRequestBody = await converterInstance.appendToRequest(
          this,
          null
        ));
    let proxy = {};
    null != Initializer.requestProxy &&
      ((proxy.host = Initializer.requestProxy.getHost()),
      (proxy.port = Initializer.requestProxy.getPort()),
      SDKLogger.log(
        Levels.INFO,
        await this.proxyLog(Initializer.requestProxy)
      ));
    var requestObj = {
      uri: baseUrl,
      method: this._requestMethod,
      headers: apiHeaders,
      body: modifiedRequestBody,
      encoding: Constants.ENCODING,
      requestProxy: proxy,
    };
    return (
      SDKLogger.log(Levels.INFO, await this.toString()),
      await new APIHTTPConnector().makeAPICall(requestObj)
    );
  }
  async makeAPICall(requestDetails) {
    return new Promise(function (resolve, reject) {
      var body, xhr, i;
      for (i in ((xhr = new XMLHttpRequest(requestDetails.requestProxy)),
      requestDetails.uri.includes(Constants.CONTENT_API) ||
        requestDetails.uri.includes(Constants.ZIP) ||
        (xhr.withCredentials = !0),
      xhr.open(requestDetails.method, requestDetails.uri, !0),
      (xhr.responseType = Constants.ARRAY_BUFFER),
      requestDetails.headers))
        xhr.setRequestHeader(i, requestDetails.headers[i]);
      (body = requestDetails.body || null),
        (xhr.timeout = Initializer.sdkConfig.getTimeout()),
        xhr.send(body),
        (xhr.onreadystatechange = function () {
          4 == xhr.readyState && resolve(xhr);
        }),
        (xhr.ontimeout = function () {
          SDKLogger.log(Levels.ERROR, Constants.TIME_OUT);
        });
    });
  }
  async setQueryParams(parameters) {
    var params;
    return (
      parameters.forEach(function (value, key) {
        parameters.has(key) &&
          (params = params
            ? params + key + "=" + encodeURI(value) + "&"
            : key + "=" + encodeURI(value) + "&");
      }),
      this._url + "?" + params.substring(0, params.length - 1)
    );
  }
  async setContentTypeHeader() {
    let apiURL = this._url,
      __contentType = this._contentType;
    for (let url of Constants.SET_TO_CONTENT_TYPE)
      if (apiURL.includes(url))
        return void this.addHeader(Constants.CONTENT_TYPE, __contentType);
  }
  toString() {
    let headers = new Map(this._headers);
    headers.set(Constants.AUTHORIZATION, Constants.CANT_DISCLOSE);
    let headerMapString = JSON.stringify(headers, (key, value) =>
        value instanceof Map ? [...value] : value
      ),
      paramMapString = JSON.stringify(this._parameters, (key, value) =>
        value instanceof Map ? [...value] : value
      );
    return (
      this._requestMethod +
      " - " +
      Constants.URL_NAME +
      " = " +
      this._url +
      " , " +
      Constants.HEADERS +
      " = " +
      headerMapString +
      " , " +
      Constants.PARAMS +
      " = " +
      paramMapString +
      "."
    );
  }
  async proxyLog(requestProxy) {
    return Constants.PROXY_SETTINGS.concat(Constants.PROXY_HOST)
      .concat(requestProxy.getHost())
      .concat(" , ")
      .concat(Constants.PROXY_PORT)
      .concat(requestProxy.getPort().toString());
  }
}
class DataTypeConverter {
  static init() {
    if (
      0 == DataTypeConverter.preConverterMap.size ||
      0 == DataTypeConverter.postConverterMap.size
    ) {
      var string = (obj) => obj.toString(),
        integer = (obj) => parseInt(obj),
        bool = (obj) => Boolean(obj),
        double = (obj) => parseFloat(obj.toString());
      this.addToMap(Constants.STRING_NAMESPACE, string, string),
        this.addToMap(Constants.INTEGER_NAMESPACE, integer, integer),
        this.addToMap(
          Constants.LONG_NAMESPACE,
          (obj) =>
            obj.toString() != Constants.NULL_VALUE ? BigInt(obj) : null,
          (obj) => obj.toString()
        ),
        this.addToMap(Constants.BOOLEAN_NAMESPACE, bool, bool),
        this.addToMap(
          Constants.DATE_NAMESPACE,
          (obj) => new Date(obj),
          (obj) => obj.toISOString().split("T")[0]
        ),
        this.addToMap(
          Constants.DATETIME_NAMESPACE,
          (obj) => new Date(obj),
          (obj) => obj.toISOString().split(".")[0] + "Z"
        ),
        this.addToMap(Constants.DOUBLE_NAMESPACE, double, double),
        this.addToMap(Constants.FLOAT_NAMESPACE, double, double),
        this.addToMap(
          Constants.OBJECT_NAMESPACE,
          (obj) => this.preConvertObjectData(obj),
          (obj) => this.postConvertObjectData(obj)
        );
    }
  }
  static preConvertObjectData(obj) {
    return obj;
  }
  static postConvertObjectData(obj) {
    if (Array.isArray(obj)) {
      let list = [];
      for (let data of obj)
        data instanceof Date
          ? 0 == data.getHours() &&
            0 == data.getMinutes() &&
            0 == data.getSeconds()
            ? list.push(this.postConvert(data, Constants.DATE_NAMESPACE))
            : list.push(this.postConvert(data, Constants.DATETIME_NAMESPACE))
          : data instanceof Map
          ? this.postConvertObjectData(data)
          : list.push(data);
      return list;
    }
    if (obj instanceof Map) {
      let requestObject = {};
      for (let key of Array.from(obj.keys())) {
        let value = obj.get(key);
        Array.isArray(value)
          ? (requestObject[key] = this.postConvertObjectData(value))
          : value instanceof Date
          ? 0 == value.getHours() &&
            0 == value.getMinutes() &&
            0 == value.getSeconds()
            ? (requestObject[key] = this.postConvert(
                value,
                Constants.DATE_NAMESPACE
              ))
            : (requestObject[key] = this.postConvert(
                value,
                Constants.DATETIME_NAMESPACE
              ))
          : value instanceof Map
          ? (requestObject[key] = this.postConvertObjectData(value))
          : (requestObject[key] = value);
      }
      return requestObject;
    }
    return obj instanceof Date
      ? 0 == obj.getHours() && 0 == obj.getMinutes() && 0 == obj.getSeconds()
        ? this.postConvert(obj, Constants.DATE_NAMESPACE)
        : this.postConvert(obj, Constants.DATETIME_NAMESPACE)
      : obj;
  }
  static addToMap(name, preConverter, postConverter) {
    DataTypeConverter.preConverterMap.set(name, preConverter),
      DataTypeConverter.postConverterMap.set(name, postConverter);
  }
  static preConvert(obj, type) {
    return (
      this.init(),
      DataTypeConverter.preConverterMap.has(type)
        ? DataTypeConverter.preConverterMap.get(type)(obj)
        : obj
    );
  }
  static postConvert(obj, type) {
    return (
      this.init(),
      DataTypeConverter.postConverterMap.has(type)
        ? DataTypeConverter.postConverterMap.get(type)(obj)
        : obj
    );
  }
}
(DataTypeConverter.preConverterMap = new Map()),
  (DataTypeConverter.postConverterMap = new Map());
var StreamWrapper = {
  Model: {
    StreamWrapper: class {
      constructor(name = null, stream = null) {
        (this._name = null), (this._stream = null);
        try {
          (async () => {
            (this._name = null !== name ? name : stream.name),
              (this._stream = stream);
          })();
        } catch (e) {
          throw new SDKException(
            Constants.FILE_ERROR,
            Constants.FILE_DOES_NOT_EXISTS
          );
        }
      }
      getName() {
        return this._name;
      }
      setName(name) {
        this._name = name;
      }
      getStream() {
        return this._stream;
      }
      setStream(stream) {
        this._stream = stream;
      }
    },
  },
};
class APIResponse {
  constructor(headers, statusCode, dataObject) {
    (this._headers = headers),
      (this._statusCode = statusCode),
      (this._dataObject = dataObject);
  }
  getHeaders() {
    return this._headers;
  }
  getStatusCode() {
    return this._statusCode;
  }
  getObject() {
    return this._dataObject;
  }
}
var Environment = class {
    constructor(url, accountsUrl, fileUploadUrl) {
      (this.url = url),
        (this.accountsUrl = accountsUrl),
        (this.fileUploadUrl = fileUploadUrl);
    }
    getUrl() {
      return this.url;
    }
    getAccountsUrl() {
      return this.accountsUrl;
    }
    getFileUploadUrl() {
      return this.fileUploadUrl;
    }
  },
  DataCenter = {
    AU: {
      PRODUCTION: function () {
        return new Environment(
          "https://www.zohoapis.com.au",
          DataCenter.AU.getIAMUrl(),
          DataCenter.AU.getFileUploadUrl()
        );
      },
      SANDBOX: function () {
        return new Environment(
          "https://sandbox.zohoapis.com.au",
          DataCenter.AU.getIAMUrl(),
          DataCenter.AU.getFileUploadUrl()
        );
      },
      DEVELOPER: function () {
        return new Environment(
          "https://developer.zohoapis.com.au",
          DataCenter.AU.getIAMUrl(),
          DataCenter.AU.getFileUploadUrl()
        );
      },
      getIAMUrl: () => "https://accounts.zoho.com.au/oauth/v2/auth",
      getFileUploadUrl: () => "https://content.zohoapis.com.au",
    },
    CN: {
      PRODUCTION: function () {
        return new Environment(
          "https://www.zohoapis.com.cn",
          DataCenter.CN.getIAMUrl(),
          DataCenter.CN.getFileUploadUrl()
        );
      },
      SANDBOX: function () {
        return new Environment(
          "https://sandbox.zohoapis.com.cn",
          DataCenter.CN.getIAMUrl(),
          DataCenter.CN.getFileUploadUrl()
        );
      },
      DEVELOPER: function () {
        return new Environment(
          "https://developer.zohoapis.com.cn",
          DataCenter.CN.getIAMUrl(),
          DataCenter.CN.getFileUploadUrl()
        );
      },
      getIAMUrl: () => "https://accounts.zoho.com.cn/oauth/v2/auth",
      getFileUploadUrl: () => "https://content.zohoapis.com.cn",
    },
    EU: {
      PRODUCTION: function () {
        return new Environment(
          "https://www.zohoapis.eu",
          DataCenter.EU.getIAMUrl(),
          DataCenter.EU.getFileUploadUrl()
        );
      },
      SANDBOX: function () {
        return new Environment(
          "https://sandbox.zohoapis.eu",
          DataCenter.EU.getIAMUrl(),
          DataCenter.EU.getFileUploadUrl()
        );
      },
      DEVELOPER: function () {
        return new Environment(
          "https://developer.zohoapis.eu",
          DataCenter.EU.getIAMUrl(),
          DataCenter.EU.getFileUploadUrl()
        );
      },
      getIAMUrl: () => "https://accounts.zoho.eu/oauth/v2/auth",
      getFileUploadUrl: () => "https://content.zohoapis.eu",
    },
    IN: {
      PRODUCTION: function () {
        return new Environment(
          "https://www.zohoapis.in",
          DataCenter.IN.getIAMUrl(),
          DataCenter.IN.getFileUploadUrl()
        );
      },
      SANDBOX: function () {
        return new Environment(
          "https://sandbox.zohoapis.in",
          DataCenter.IN.getIAMUrl(),
          DataCenter.IN.getFileUploadUrl()
        );
      },
      DEVELOPER: function () {
        return new Environment(
          "https://developer.zohoapis.in",
          DataCenter.IN.getIAMUrl(),
          DataCenter.IN.getFileUploadUrl()
        );
      },
      getIAMUrl: () => "https://accounts.zoho.in/oauth/v2/auth",
      getFileUploadUrl: () => "https://content.zohoapis.in",
    },
    US: {
      PRODUCTION: function () {
        return new Environment(
          "https://www.zohoapis.com",
          DataCenter.US.getIAMUrl(),
          DataCenter.US.getFileUploadUrl()
        );
      },
      SANDBOX: function () {
        return new Environment(
          "https://sandbox.zohoapis.com",
          DataCenter.US.getIAMUrl(),
          DataCenter.US.getFileUploadUrl()
        );
      },
      DEVELOPER: function () {
        return new Environment(
          "https://developer.zohoapis.com",
          DataCenter.US.getIAMUrl(),
          DataCenter.US.getFileUploadUrl()
        );
      },
      getIAMUrl: () => "https://accounts.zoho.com/oauth/v2/auth",
      getFileUploadUrl: () => "https://content.zohoapis.com",
    },
    JP: {
      PRODUCTION: function () {
        return new Environment(
          "https://www.zohoapis.jp",
          DataCenter.JP.getIAMUrl(),
          DataCenter.JP.getFileUploadUrl()
        );
      },
      SANDBOX: function () {
        return new Environment(
          "https://sandbox.zohoapis.jp",
          DataCenter.JP.getIAMUrl(),
          DataCenter.JP.getFileUploadUrl()
        );
      },
      DEVELOPER: function () {
        return new Environment(
          "https://developer.zohoapis.jp",
          DataCenter.JP.getIAMUrl(),
          DataCenter.JP.getFileUploadUrl()
        );
      },
      getIAMUrl: () => "https://accounts.zoho.jp/oauth/v2/auth",
      getFileUploadUrl: () => "https://content.zohoapis.jp",
    },
  };
(ZCRM.Currency = {
  Model: {
    ActionHandler: class {
      constructor() {}
    },
    ActionResponse: class {
      constructor() {}
    },
    BaseCurrencyActionHandler: class {
      constructor() {}
    },
    ResponseHandler: class {
      constructor() {}
    },
    Currency: class {
      constructor() {
        (this.symbol = null),
          (this.createdTime = null),
          (this.isActive = null),
          (this.exchangeRate = null),
          (this.format = null),
          (this.createdBy = null),
          (this.prefixSymbol = null),
          (this.isBase = null),
          (this.modifiedTime = null),
          (this.name = null),
          (this.modifiedBy = null),
          (this.id = null),
          (this.isoCode = null),
          (this.keyModified = new Map());
      }
      getSymbol() {
        return this.symbol;
      }
      setSymbol(symbol) {
        if (
          null != symbol &&
          "[object String]" != Object.prototype.toString.call(symbol)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: symbol EXPECTED TYPE: String",
            null,
            null
          );
        (this.symbol = symbol), this.keyModified.set("symbol", 1);
      }
      getCreatedTime() {
        return this.createdTime;
      }
      setCreatedTime(createdTime) {
        if (null != createdTime && !(createdTime instanceof Date))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: createdTime EXPECTED TYPE: Date",
            null,
            null
          );
        (this.createdTime = createdTime),
          this.keyModified.set("created_time", 1);
      }
      getIsActive() {
        return this.isActive;
      }
      setIsActive(isActive) {
        if (
          null != isActive &&
          "[object Boolean]" != Object.prototype.toString.call(isActive)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: isActive EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.isActive = isActive), this.keyModified.set("is_active", 1);
      }
      getExchangeRate() {
        return this.exchangeRate;
      }
      setExchangeRate(exchangeRate) {
        if (
          null != exchangeRate &&
          "[object String]" != Object.prototype.toString.call(exchangeRate)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: exchangeRate EXPECTED TYPE: String",
            null,
            null
          );
        (this.exchangeRate = exchangeRate),
          this.keyModified.set("exchange_rate", 1);
      }
      getFormat() {
        return this.format;
      }
      setFormat(format) {
        if (null != format && !(format instanceof ZCRM.Currency.Model.Format))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: format EXPECTED TYPE: Format",
            null,
            null
          );
        (this.format = format), this.keyModified.set("format", 1);
      }
      getCreatedBy() {
        return this.createdBy;
      }
      setCreatedBy(createdBy) {
        if (null != createdBy && !(createdBy instanceof ZCRM.User.Model.User))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: createdBy EXPECTED TYPE: User",
            null,
            null
          );
        (this.createdBy = createdBy), this.keyModified.set("created_by", 1);
      }
      getPrefixSymbol() {
        return this.prefixSymbol;
      }
      setPrefixSymbol(prefixSymbol) {
        if (
          null != prefixSymbol &&
          "[object Boolean]" != Object.prototype.toString.call(prefixSymbol)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: prefixSymbol EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.prefixSymbol = prefixSymbol),
          this.keyModified.set("prefix_symbol", 1);
      }
      getIsBase() {
        return this.isBase;
      }
      setIsBase(isBase) {
        if (
          null != isBase &&
          "[object Boolean]" != Object.prototype.toString.call(isBase)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: isBase EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.isBase = isBase), this.keyModified.set("is_base", 1);
      }
      getModifiedTime() {
        return this.modifiedTime;
      }
      setModifiedTime(modifiedTime) {
        if (null != modifiedTime && !(modifiedTime instanceof Date))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modifiedTime EXPECTED TYPE: Date",
            null,
            null
          );
        (this.modifiedTime = modifiedTime),
          this.keyModified.set("modified_time", 1);
      }
      getName() {
        return this.name;
      }
      setName(name) {
        if (
          null != name &&
          "[object String]" != Object.prototype.toString.call(name)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: name EXPECTED TYPE: String",
            null,
            null
          );
        (this.name = name), this.keyModified.set("name", 1);
      }
      getModifiedBy() {
        return this.modifiedBy;
      }
      setModifiedBy(modifiedBy) {
        if (null != modifiedBy && !(modifiedBy instanceof ZCRM.User.Model.User))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modifiedBy EXPECTED TYPE: User",
            null,
            null
          );
        (this.modifiedBy = modifiedBy), this.keyModified.set("modified_by", 1);
      }
      getId() {
        return this.id;
      }
      setId(id) {
        if (
          null != id &&
          "[object BigInt]" != Object.prototype.toString.call(id)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        (this.id = id), this.keyModified.set("id", 1);
      }
      getIsoCode() {
        return this.isoCode;
      }
      setIsoCode(isoCode) {
        if (
          null != isoCode &&
          "[object String]" != Object.prototype.toString.call(isoCode)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: isoCode EXPECTED TYPE: String",
            null,
            null
          );
        (this.isoCode = isoCode), this.keyModified.set("iso_code", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    ResponseWrapper: class {
      constructor() {
        (this.currencies = null), (this.keyModified = new Map());
      }
      getCurrencies() {
        return this.currencies;
      }
      setCurrencies(currencies) {
        if (
          null != currencies &&
          "[object Array]" != Object.prototype.toString.call(currencies)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: currencies EXPECTED TYPE: Array",
            null,
            null
          );
        (this.currencies = currencies), this.keyModified.set("currencies", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    SuccessResponse: class {
      constructor() {
        (this.status = null),
          (this.code = null),
          (this.message = null),
          (this.details = null),
          (this.keyModified = new Map());
      }
      getStatus() {
        return this.status;
      }
      setStatus(status) {
        if (null != status && !(status instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: status EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.status = status), this.keyModified.set("status", 1);
      }
      getCode() {
        return this.code;
      }
      setCode(code) {
        if (null != code && !(code instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: code EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.code = code), this.keyModified.set("code", 1);
      }
      getMessage() {
        return this.message;
      }
      setMessage(message) {
        if (null != message && !(message instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: message EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.message = message), this.keyModified.set("message", 1);
      }
      getDetails() {
        return this.details;
      }
      setDetails(details) {
        if (
          null != details &&
          "[object Map]" != Object.prototype.toString.call(details)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: details EXPECTED TYPE: Map",
            null,
            null
          );
        (this.details = details), this.keyModified.set("details", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    BaseCurrencyWrapper: class {
      constructor() {
        (this.baseCurrency = null), (this.keyModified = new Map());
      }
      getBaseCurrency() {
        return this.baseCurrency;
      }
      setBaseCurrency(baseCurrency) {
        if (
          null != baseCurrency &&
          !(baseCurrency instanceof ZCRM.Currency.Model.Currency)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: baseCurrency EXPECTED TYPE: Currency",
            null,
            null
          );
        (this.baseCurrency = baseCurrency),
          this.keyModified.set("base_currency", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    ActionWrapper: class {
      constructor() {
        (this.currencies = null), (this.keyModified = new Map());
      }
      getCurrencies() {
        return this.currencies;
      }
      setCurrencies(currencies) {
        if (
          null != currencies &&
          "[object Array]" != Object.prototype.toString.call(currencies)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: currencies EXPECTED TYPE: Array",
            null,
            null
          );
        (this.currencies = currencies), this.keyModified.set("currencies", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    APIException: class {
      constructor() {
        (this.status = null),
          (this.code = null),
          (this.message = null),
          (this.details = null),
          (this.keyModified = new Map());
      }
      getStatus() {
        return this.status;
      }
      setStatus(status) {
        if (null != status && !(status instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: status EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.status = status), this.keyModified.set("status", 1);
      }
      getCode() {
        return this.code;
      }
      setCode(code) {
        if (null != code && !(code instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: code EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.code = code), this.keyModified.set("code", 1);
      }
      getMessage() {
        return this.message;
      }
      setMessage(message) {
        if (null != message && !(message instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: message EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.message = message), this.keyModified.set("message", 1);
      }
      getDetails() {
        return this.details;
      }
      setDetails(details) {
        if (
          null != details &&
          "[object Map]" != Object.prototype.toString.call(details)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: details EXPECTED TYPE: Map",
            null,
            null
          );
        (this.details = details), this.keyModified.set("details", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    BodyWrapper: class {
      constructor() {
        (this.currencies = null), (this.keyModified = new Map());
      }
      getCurrencies() {
        return this.currencies;
      }
      setCurrencies(currencies) {
        if (
          null != currencies &&
          "[object Array]" != Object.prototype.toString.call(currencies)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: currencies EXPECTED TYPE: Array",
            null,
            null
          );
        (this.currencies = currencies), this.keyModified.set("currencies", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    Format: class {
      constructor() {
        (this.decimalSeparator = null),
          (this.thousandSeparator = null),
          (this.decimalPlaces = null),
          (this.keyModified = new Map());
      }
      getDecimalSeparator() {
        return this.decimalSeparator;
      }
      setDecimalSeparator(decimalSeparator) {
        if (null != decimalSeparator && !(decimalSeparator instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: decimalSeparator EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.decimalSeparator = decimalSeparator),
          this.keyModified.set("decimal_separator", 1);
      }
      getThousandSeparator() {
        return this.thousandSeparator;
      }
      setThousandSeparator(thousandSeparator) {
        if (null != thousandSeparator && !(thousandSeparator instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: thousandSeparator EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.thousandSeparator = thousandSeparator),
          this.keyModified.set("thousand_separator", 1);
      }
      getDecimalPlaces() {
        return this.decimalPlaces;
      }
      setDecimalPlaces(decimalPlaces) {
        if (null != decimalPlaces && !(decimalPlaces instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: decimalPlaces EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.decimalPlaces = decimalPlaces),
          this.keyModified.set("decimal_places", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    BaseCurrencyActionWrapper: class {
      constructor() {
        (this.baseCurrency = null), (this.keyModified = new Map());
      }
      getBaseCurrency() {
        return this.baseCurrency;
      }
      setBaseCurrency(baseCurrency) {
        (this.baseCurrency = baseCurrency),
          this.keyModified.set("base_currency", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
  },
  Operations: class {
    constructor() {}
    async getCurrencies() {
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/org/currencies")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
        handlerInstance.apiCall(
          "Currency.Model.ResponseHandler",
          "application/json"
        )
      );
    }
    async addCurrencies(request) {
      if (
        null != request &&
        !(request instanceof ZCRM.Currency.Model.BodyWrapper)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: request EXPECTED TYPE: BodyWrapper",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/org/currencies")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
        handlerInstance.setContentType("application/json"),
        handlerInstance.setRequest(request),
        handlerInstance.setMandatoryChecker(!0),
        handlerInstance.apiCall(
          "Currency.Model.ActionHandler",
          "application/json"
        )
      );
    }
    async updateCurrencies(request) {
      if (
        null != request &&
        !(request instanceof ZCRM.Currency.Model.BodyWrapper)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: request EXPECTED TYPE: BodyWrapper",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/org/currencies")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
        handlerInstance.setContentType("application/json"),
        handlerInstance.setRequest(request),
        handlerInstance.setMandatoryChecker(!0),
        handlerInstance.apiCall(
          "Currency.Model.ActionHandler",
          "application/json"
        )
      );
    }
    async enableMultipleCurrencies(request) {
      if (
        null != request &&
        !(request instanceof ZCRM.Currency.Model.BaseCurrencyWrapper)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: request EXPECTED TYPE: BaseCurrencyWrapper",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/org/currencies/actions/enable")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
        handlerInstance.setContentType("application/json"),
        handlerInstance.setRequest(request),
        handlerInstance.setMandatoryChecker(!0),
        handlerInstance.apiCall(
          "Currency.Model.BaseCurrencyActionHandler",
          "application/json"
        )
      );
    }
    async updateBaseCurrency(request) {
      if (
        null != request &&
        !(request instanceof ZCRM.Currency.Model.BaseCurrencyWrapper)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: request EXPECTED TYPE: BaseCurrencyWrapper",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/org/currencies/actions/enable")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
        handlerInstance.setContentType("application/json"),
        handlerInstance.setRequest(request),
        handlerInstance.setMandatoryChecker(!0),
        handlerInstance.apiCall(
          "Currency.Model.BaseCurrencyActionHandler",
          "application/json"
        )
      );
    }
    async getCurrency(id) {
      if ("[object BigInt]" != Object.prototype.toString.call(id))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: id EXPECTED TYPE: BigInt",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = (apiPath = apiPath.concat("/crm/v2/org/currencies/")).concat(
          id.toString()
        )),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
        handlerInstance.apiCall(
          "Currency.Model.ResponseHandler",
          "application/json"
        )
      );
    }
    async updateCurrency(id, request) {
      if ("[object BigInt]" != Object.prototype.toString.call(id))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: id EXPECTED TYPE: BigInt",
          null,
          null
        );
      if (
        null != request &&
        !(request instanceof ZCRM.Currency.Model.BodyWrapper)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: request EXPECTED TYPE: BodyWrapper",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = (apiPath = apiPath.concat("/crm/v2/org/currencies/")).concat(
          id.toString()
        )),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
        handlerInstance.setContentType("application/json"),
        handlerInstance.setRequest(request),
        handlerInstance.apiCall(
          "Currency.Model.ActionHandler",
          "application/json"
        )
      );
    }
  },
}),
  (ZCRM.Territory = {
    Model: {
      ResponseHandler: class {
        constructor() {}
      },
      Territory: class {
        constructor() {
          (this.createdTime = null),
            (this.modifiedTime = null),
            (this.manager = null),
            (this.parentId = null),
            (this.criteria = null),
            (this.name = null),
            (this.modifiedBy = null),
            (this.description = null),
            (this.id = null),
            (this.createdBy = null),
            (this.keyModified = new Map());
        }
        getCreatedTime() {
          return this.createdTime;
        }
        setCreatedTime(createdTime) {
          if (null != createdTime && !(createdTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.createdTime = createdTime),
            this.keyModified.set("created_time", 1);
        }
        getModifiedTime() {
          return this.modifiedTime;
        }
        setModifiedTime(modifiedTime) {
          if (null != modifiedTime && !(modifiedTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.modifiedTime = modifiedTime),
            this.keyModified.set("modified_time", 1);
        }
        getManager() {
          return this.manager;
        }
        setManager(manager) {
          if (null != manager && !(manager instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: manager EXPECTED TYPE: User",
              null,
              null
            );
          (this.manager = manager), this.keyModified.set("manager", 1);
        }
        getParentId() {
          return this.parentId;
        }
        setParentId(parentId) {
          if (
            null != parentId &&
            "[object String]" != Object.prototype.toString.call(parentId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: parentId EXPECTED TYPE: String",
              null,
              null
            );
          (this.parentId = parentId), this.keyModified.set("parent_id", 1);
        }
        getCriteria() {
          return this.criteria;
        }
        setCriteria(criteria) {
          if (
            null != criteria &&
            !(criteria instanceof ZCRM.CustomView.Model.Criteria)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: criteria EXPECTED TYPE: Criteria",
              null,
              null
            );
          (this.criteria = criteria), this.keyModified.set("criteria", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getModifiedBy() {
          return this.modifiedBy;
        }
        setModifiedBy(modifiedBy) {
          if (
            null != modifiedBy &&
            !(modifiedBy instanceof ZCRM.User.Model.User)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.modifiedBy = modifiedBy),
            this.keyModified.set("modified_by", 1);
        }
        getDescription() {
          return this.description;
        }
        setDescription(description) {
          if (
            null != description &&
            "[object String]" != Object.prototype.toString.call(description)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: description EXPECTED TYPE: String",
              null,
              null
            );
          (this.description = description),
            this.keyModified.set("description", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getCreatedBy() {
          return this.createdBy;
        }
        setCreatedBy(createdBy) {
          if (null != createdBy && !(createdBy instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.createdBy = createdBy), this.keyModified.set("created_by", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.code = null),
            (this.status = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.territories = null), (this.keyModified = new Map());
        }
        getTerritories() {
          return this.territories;
        }
        setTerritories(territories) {
          if (
            null != territories &&
            "[object Array]" != Object.prototype.toString.call(territories)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: territories EXPECTED TYPE: Array",
              null,
              null
            );
          (this.territories = territories),
            this.keyModified.set("territories", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
    },
    Operations: class {
      constructor() {}
      async getTerritories() {
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/territories")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "Territory.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async getTerritory(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/territories/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "Territory.Model.ResponseHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.Record = {
    Model: {
      ResponseHandler: class {
        constructor() {}
      },
      ConvertActionResponse: class {
        constructor() {}
      },
      ConvertActionHandler: class {
        constructor() {}
      },
      ActionHandler: class {
        constructor() {}
      },
      DownloadHandler: class {
        constructor() {}
      },
      MassUpdateResponseHandler: class {
        constructor() {}
      },
      MassUpdateResponse: class {
        constructor() {}
      },
      ActionResponse: class {
        constructor() {}
      },
      MassUpdateActionHandler: class {
        constructor() {}
      },
      MassUpdateActionResponse: class {
        constructor() {}
      },
      FileHandler: class {
        constructor() {}
      },
      DeletedRecordsHandler: class {
        constructor() {}
      },
      ResponseWrapper: class {
        constructor() {
          (this.data = null),
            (this.info = null),
            (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (null != info && !(info instanceof ZCRM.Record.Model.Info))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Info",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.duplicateField = null),
            (this.action = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getDuplicateField() {
          return this.duplicateField;
        }
        setDuplicateField(duplicateField) {
          if (
            null != duplicateField &&
            "[object String]" != Object.prototype.toString.call(duplicateField)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: duplicateField EXPECTED TYPE: String",
              null,
              null
            );
          (this.duplicateField = duplicateField),
            this.keyModified.set("duplicate_field", 1);
        }
        getAction() {
          return this.action;
        }
        setAction(action) {
          if (null != action && !(action instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: action EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.action = action), this.keyModified.set("action", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ConvertActionWrapper: class {
        constructor() {
          (this.data = null), (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      MassUpdateBodyWrapper: class {
        constructor() {
          (this.data = null),
            (this.cvid = null),
            (this.ids = null),
            (this.territory = null),
            (this.overWrite = null),
            (this.criteria = null),
            (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getCvid() {
          return this.cvid;
        }
        setCvid(cvid) {
          if (
            null != cvid &&
            "[object String]" != Object.prototype.toString.call(cvid)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: cvid EXPECTED TYPE: String",
              null,
              null
            );
          (this.cvid = cvid), this.keyModified.set("cvid", 1);
        }
        getIds() {
          return this.ids;
        }
        setIds(ids) {
          if (
            null != ids &&
            "[object Array]" != Object.prototype.toString.call(ids)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: ids EXPECTED TYPE: Array",
              null,
              null
            );
          (this.ids = ids), this.keyModified.set("ids", 1);
        }
        getTerritory() {
          return this.territory;
        }
        setTerritory(territory) {
          if (
            null != territory &&
            !(territory instanceof ZCRM.Record.Model.Territory)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: territory EXPECTED TYPE: Territory",
              null,
              null
            );
          (this.territory = territory), this.keyModified.set("territory", 1);
        }
        getOverWrite() {
          return this.overWrite;
        }
        setOverWrite(overWrite) {
          if (
            null != overWrite &&
            "[object Boolean]" != Object.prototype.toString.call(overWrite)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: overWrite EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.overWrite = overWrite), this.keyModified.set("over_write", 1);
        }
        getCriteria() {
          return this.criteria;
        }
        setCriteria(criteria) {
          if (
            null != criteria &&
            "[object Array]" != Object.prototype.toString.call(criteria)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: criteria EXPECTED TYPE: Array",
              null,
              null
            );
          (this.criteria = criteria), this.keyModified.set("criteria", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Territory: class {
        constructor() {
          (this.id = null),
            (this.includeChild = null),
            (this.keyModified = new Map());
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getIncludeChild() {
          return this.includeChild;
        }
        setIncludeChild(includeChild) {
          if (
            null != includeChild &&
            "[object Boolean]" != Object.prototype.toString.call(includeChild)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: includeChild EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.includeChild = includeChild),
            this.keyModified.set("include_child", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessfulConvert: class {
        constructor() {
          (this.contacts = null),
            (this.deals = null),
            (this.accounts = null),
            (this.keyModified = new Map());
        }
        getContacts() {
          return this.contacts;
        }
        setContacts(contacts) {
          if (
            null != contacts &&
            "[object String]" != Object.prototype.toString.call(contacts)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: contacts EXPECTED TYPE: String",
              null,
              null
            );
          (this.contacts = contacts), this.keyModified.set("Contacts", 1);
        }
        getDeals() {
          return this.deals;
        }
        setDeals(deals) {
          if (
            null != deals &&
            "[object String]" != Object.prototype.toString.call(deals)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: deals EXPECTED TYPE: String",
              null,
              null
            );
          (this.deals = deals), this.keyModified.set("Deals", 1);
        }
        getAccounts() {
          return this.accounts;
        }
        setAccounts(accounts) {
          if (
            null != accounts &&
            "[object String]" != Object.prototype.toString.call(accounts)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: accounts EXPECTED TYPE: String",
              null,
              null
            );
          (this.accounts = accounts), this.keyModified.set("Accounts", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      LeadConverter: class {
        constructor() {
          (this.overwrite = null),
            (this.notifyLeadOwner = null),
            (this.notifyNewEntityOwner = null),
            (this.accounts = null),
            (this.contacts = null),
            (this.assignTo = null),
            (this.deals = null),
            (this.carryOverTags = null),
            (this.keyModified = new Map());
        }
        getOverwrite() {
          return this.overwrite;
        }
        setOverwrite(overwrite) {
          if (
            null != overwrite &&
            "[object Boolean]" != Object.prototype.toString.call(overwrite)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: overwrite EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.overwrite = overwrite), this.keyModified.set("overwrite", 1);
        }
        getNotifyLeadOwner() {
          return this.notifyLeadOwner;
        }
        setNotifyLeadOwner(notifyLeadOwner) {
          if (
            null != notifyLeadOwner &&
            "[object Boolean]" !=
              Object.prototype.toString.call(notifyLeadOwner)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: notifyLeadOwner EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.notifyLeadOwner = notifyLeadOwner),
            this.keyModified.set("notify_lead_owner", 1);
        }
        getNotifyNewEntityOwner() {
          return this.notifyNewEntityOwner;
        }
        setNotifyNewEntityOwner(notifyNewEntityOwner) {
          if (
            null != notifyNewEntityOwner &&
            "[object Boolean]" !=
              Object.prototype.toString.call(notifyNewEntityOwner)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: notifyNewEntityOwner EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.notifyNewEntityOwner = notifyNewEntityOwner),
            this.keyModified.set("notify_new_entity_owner", 1);
        }
        getAccounts() {
          return this.accounts;
        }
        setAccounts(accounts) {
          if (
            null != accounts &&
            "[object String]" != Object.prototype.toString.call(accounts)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: accounts EXPECTED TYPE: String",
              null,
              null
            );
          (this.accounts = accounts), this.keyModified.set("Accounts", 1);
        }
        getContacts() {
          return this.contacts;
        }
        setContacts(contacts) {
          if (
            null != contacts &&
            "[object String]" != Object.prototype.toString.call(contacts)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: contacts EXPECTED TYPE: String",
              null,
              null
            );
          (this.contacts = contacts), this.keyModified.set("Contacts", 1);
        }
        getAssignTo() {
          return this.assignTo;
        }
        setAssignTo(assignTo) {
          if (
            null != assignTo &&
            "[object String]" != Object.prototype.toString.call(assignTo)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: assignTo EXPECTED TYPE: String",
              null,
              null
            );
          (this.assignTo = assignTo), this.keyModified.set("assign_to", 1);
        }
        getDeals() {
          return this.deals;
        }
        setDeals(deals) {
          if (null != deals && !(deals instanceof ZCRM.Record.Model.Record))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: deals EXPECTED TYPE: Record",
              null,
              null
            );
          (this.deals = deals), this.keyModified.set("Deals", 1);
        }
        getCarryOverTags() {
          return this.carryOverTags;
        }
        setCarryOverTags(carryOverTags) {
          if (
            null != carryOverTags &&
            !(carryOverTags instanceof ZCRM.Record.Model.CarryOverTags)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: carryOverTags EXPECTED TYPE: CarryOverTags",
              null,
              null
            );
          (this.carryOverTags = carryOverTags),
            this.keyModified.set("carry_over_tags", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.data = null),
            (this.trigger = null),
            (this.process = null),
            (this.duplicateCheckFields = null),
            (this.wfTrigger = null),
            (this.larId = null),
            (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getTrigger() {
          return this.trigger;
        }
        setTrigger(trigger) {
          if (
            null != trigger &&
            "[object Array]" != Object.prototype.toString.call(trigger)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: trigger EXPECTED TYPE: Array",
              null,
              null
            );
          (this.trigger = trigger), this.keyModified.set("trigger", 1);
        }
        getProcess() {
          return this.process;
        }
        setProcess(process) {
          if (
            null != process &&
            "[object Array]" != Object.prototype.toString.call(process)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: process EXPECTED TYPE: Array",
              null,
              null
            );
          (this.process = process), this.keyModified.set("process", 1);
        }
        getDuplicateCheckFields() {
          return this.duplicateCheckFields;
        }
        setDuplicateCheckFields(duplicateCheckFields) {
          if (
            null != duplicateCheckFields &&
            "[object Array]" !=
              Object.prototype.toString.call(duplicateCheckFields)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: duplicateCheckFields EXPECTED TYPE: Array",
              null,
              null
            );
          (this.duplicateCheckFields = duplicateCheckFields),
            this.keyModified.set("duplicate_check_fields", 1);
        }
        getWfTrigger() {
          return this.wfTrigger;
        }
        setWfTrigger(wfTrigger) {
          if (
            null != wfTrigger &&
            "[object String]" != Object.prototype.toString.call(wfTrigger)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: wfTrigger EXPECTED TYPE: String",
              null,
              null
            );
          (this.wfTrigger = wfTrigger), this.keyModified.set("wf_trigger", 1);
        }
        getLarId() {
          return this.larId;
        }
        setLarId(larId) {
          if (
            null != larId &&
            "[object String]" != Object.prototype.toString.call(larId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: larId EXPECTED TYPE: String",
              null,
              null
            );
          (this.larId = larId), this.keyModified.set("lar_id", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Criteria: class {
        constructor() {
          (this.comparator = null),
            (this.field = null),
            (this.value = null),
            (this.groupOperator = null),
            (this.group = null),
            (this.keyModified = new Map());
        }
        getComparator() {
          return this.comparator;
        }
        setComparator(comparator) {
          if (null != comparator && !(comparator instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: comparator EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.comparator = comparator), this.keyModified.set("comparator", 1);
        }
        getField() {
          return this.field;
        }
        setField(field) {
          if (
            null != field &&
            "[object String]" != Object.prototype.toString.call(field)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: field EXPECTED TYPE: String",
              null,
              null
            );
          (this.field = field), this.keyModified.set("field", 1);
        }
        getValue() {
          return this.value;
        }
        setValue(value) {
          (this.value = value), this.keyModified.set("value", 1);
        }
        getGroupOperator() {
          return this.groupOperator;
        }
        setGroupOperator(groupOperator) {
          if (null != groupOperator && !(groupOperator instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: groupOperator EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.groupOperator = groupOperator),
            this.keyModified.set("group_operator", 1);
        }
        getGroup() {
          return this.group;
        }
        setGroup(group) {
          if (
            null != group &&
            "[object Array]" != Object.prototype.toString.call(group)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: group EXPECTED TYPE: Array",
              null,
              null
            );
          (this.group = group), this.keyModified.set("group", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      MassUpdateActionWrapper: class {
        constructor() {
          (this.data = null), (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Info: class {
        constructor() {
          (this.perPage = null),
            (this.count = null),
            (this.page = null),
            (this.moreRecords = null),
            (this.keyModified = new Map());
        }
        getPerPage() {
          return this.perPage;
        }
        setPerPage(perPage) {
          if (
            null != perPage &&
            "[object Number]" != Object.prototype.toString.call(perPage)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: perPage EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.perPage = perPage), this.keyModified.set("per_page", 1);
        }
        getCount() {
          return this.count;
        }
        setCount(count) {
          if (
            null != count &&
            "[object Number]" != Object.prototype.toString.call(count)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: count EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.count = count), this.keyModified.set("count", 1);
        }
        getPage() {
          return this.page;
        }
        setPage(page) {
          if (
            null != page &&
            "[object Number]" != Object.prototype.toString.call(page)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: page EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.page = page), this.keyModified.set("page", 1);
        }
        getMoreRecords() {
          return this.moreRecords;
        }
        setMoreRecords(moreRecords) {
          if (
            null != moreRecords &&
            "[object Boolean]" != Object.prototype.toString.call(moreRecords)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: moreRecords EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.moreRecords = moreRecords),
            this.keyModified.set("more_records", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      FileBodyWrapper: class {
        constructor() {
          (this.file = null), (this.keyModified = new Map());
        }
        getFile() {
          return this.file;
        }
        setFile(file) {
          if (
            null != file &&
            !(file instanceof StreamWrapper.Model.StreamWrapper)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: file EXPECTED TYPE: StreamWrapper",
              null,
              null
            );
          (this.file = file), this.keyModified.set("file", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      MassUpdate: class {
        constructor() {
          (this.status = null),
            (this.failedCount = null),
            (this.updatedCount = null),
            (this.notUpdatedCount = null),
            (this.totalCount = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("Status", 1);
        }
        getFailedCount() {
          return this.failedCount;
        }
        setFailedCount(failedCount) {
          if (
            null != failedCount &&
            "[object Number]" != Object.prototype.toString.call(failedCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: failedCount EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.failedCount = failedCount),
            this.keyModified.set("Failed_Count", 1);
        }
        getUpdatedCount() {
          return this.updatedCount;
        }
        setUpdatedCount(updatedCount) {
          if (
            null != updatedCount &&
            "[object Number]" != Object.prototype.toString.call(updatedCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: updatedCount EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.updatedCount = updatedCount),
            this.keyModified.set("Updated_Count", 1);
        }
        getNotUpdatedCount() {
          return this.notUpdatedCount;
        }
        setNotUpdatedCount(notUpdatedCount) {
          if (
            null != notUpdatedCount &&
            "[object Number]" != Object.prototype.toString.call(notUpdatedCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: notUpdatedCount EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.notUpdatedCount = notUpdatedCount),
            this.keyModified.set("Not_Updated_Count", 1);
        }
        getTotalCount() {
          return this.totalCount;
        }
        setTotalCount(totalCount) {
          if (
            null != totalCount &&
            "[object Number]" != Object.prototype.toString.call(totalCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: totalCount EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.totalCount = totalCount),
            this.keyModified.set("Total_Count", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Field: class {
        constructor(apiName) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          this.apiName = apiName;
        }
        getAPIName() {
          return this.apiName;
        }
      },
      ActionWrapper: class {
        constructor() {
          (this.data = null), (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Record: class {
        constructor() {
          (this.keyValues = new Map()), (this.keyModified = new Map());
        }
        getId() {
          return this.getKeyValue("id");
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          this.addKeyValue("id", id);
        }
        getCreatedBy() {
          return this.getKeyValue("Created_By");
        }
        setCreatedBy(createdBy) {
          if (null != createdBy && !(createdBy instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdBy EXPECTED TYPE: User",
              null,
              null
            );
          this.addKeyValue("Created_By", createdBy);
        }
        getCreatedTime() {
          return this.getKeyValue("Created_Time");
        }
        setCreatedTime(createdTime) {
          if (null != createdTime && !(createdTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdTime EXPECTED TYPE: Date",
              null,
              null
            );
          this.addKeyValue("Created_Time", createdTime);
        }
        getModifiedBy() {
          return this.getKeyValue("Modified_By");
        }
        setModifiedBy(modifiedBy) {
          if (
            null != modifiedBy &&
            !(modifiedBy instanceof ZCRM.User.Model.User)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedBy EXPECTED TYPE: User",
              null,
              null
            );
          this.addKeyValue("Modified_By", modifiedBy);
        }
        getModifiedTime() {
          return this.getKeyValue("Modified_Time");
        }
        setModifiedTime(modifiedTime) {
          if (null != modifiedTime && !(modifiedTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedTime EXPECTED TYPE: Date",
              null,
              null
            );
          this.addKeyValue("Modified_Time", modifiedTime);
        }
        getTag() {
          return this.getKeyValue("Tag");
        }
        setTag(tag) {
          if (
            null != tag &&
            "[object Array]" != Object.prototype.toString.call(tag)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: tag EXPECTED TYPE: Array",
              null,
              null
            );
          this.addKeyValue("Tag", tag);
        }
        addFieldValue(field, value) {
          if (null != field && !(field instanceof ZCRM.Record.Model.Field))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: field EXPECTED TYPE: Field",
              null,
              null
            );
          this.addKeyValue(field.getAPIName(), value);
        }
        addKeyValue(apiName, value) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          this.keyValues.set(apiName, value), this.keyModified.set(apiName, 1);
        }
        getKeyValue(apiName) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyValues.has(apiName)
            ? this.keyValues.get(apiName)
            : null;
        }
        getKeyValues() {
          return this.keyValues;
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RemindAt: class {
        constructor() {
          (this.alarm = null), (this.keyModified = new Map());
        }
        getAlarm() {
          return this.alarm;
        }
        setAlarm(alarm) {
          if (
            null != alarm &&
            "[object String]" != Object.prototype.toString.call(alarm)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: alarm EXPECTED TYPE: String",
              null,
              null
            );
          (this.alarm = alarm), this.keyModified.set("ALARM", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ConvertBodyWrapper: class {
        constructor() {
          (this.data = null), (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      MassUpdateResponseWrapper: class {
        constructor() {
          (this.data = null), (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      FileDetails: class {
        constructor() {
          (this.extn = null),
            (this.isPreviewAvailable = null),
            (this.downloadUrl = null),
            (this.deleteUrl = null),
            (this.entityId = null),
            (this.mode = null),
            (this.originalSizeByte = null),
            (this.previewUrl = null),
            (this.fileName = null),
            (this.fileId = null),
            (this.attachmentId = null),
            (this.fileSize = null),
            (this.creatorId = null),
            (this.linkDocs = null),
            (this.delete1 = null),
            (this.keyModified = new Map());
        }
        getExtn() {
          return this.extn;
        }
        setExtn(extn) {
          if (
            null != extn &&
            "[object String]" != Object.prototype.toString.call(extn)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: extn EXPECTED TYPE: String",
              null,
              null
            );
          (this.extn = extn), this.keyModified.set("extn", 1);
        }
        getIsPreviewAvailable() {
          return this.isPreviewAvailable;
        }
        setIsPreviewAvailable(isPreviewAvailable) {
          if (
            null != isPreviewAvailable &&
            "[object Boolean]" !=
              Object.prototype.toString.call(isPreviewAvailable)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: isPreviewAvailable EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.isPreviewAvailable = isPreviewAvailable),
            this.keyModified.set("is_Preview_Available", 1);
        }
        getDownloadUrl() {
          return this.downloadUrl;
        }
        setDownloadUrl(downloadUrl) {
          if (
            null != downloadUrl &&
            "[object String]" != Object.prototype.toString.call(downloadUrl)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: downloadUrl EXPECTED TYPE: String",
              null,
              null
            );
          (this.downloadUrl = downloadUrl),
            this.keyModified.set("download_Url", 1);
        }
        getDeleteUrl() {
          return this.deleteUrl;
        }
        setDeleteUrl(deleteUrl) {
          if (
            null != deleteUrl &&
            "[object String]" != Object.prototype.toString.call(deleteUrl)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: deleteUrl EXPECTED TYPE: String",
              null,
              null
            );
          (this.deleteUrl = deleteUrl), this.keyModified.set("delete_Url", 1);
        }
        getEntityId() {
          return this.entityId;
        }
        setEntityId(entityId) {
          if (
            null != entityId &&
            "[object String]" != Object.prototype.toString.call(entityId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: entityId EXPECTED TYPE: String",
              null,
              null
            );
          (this.entityId = entityId), this.keyModified.set("entity_Id", 1);
        }
        getMode() {
          return this.mode;
        }
        setMode(mode) {
          if (
            null != mode &&
            "[object String]" != Object.prototype.toString.call(mode)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: mode EXPECTED TYPE: String",
              null,
              null
            );
          (this.mode = mode), this.keyModified.set("mode", 1);
        }
        getOriginalSizeByte() {
          return this.originalSizeByte;
        }
        setOriginalSizeByte(originalSizeByte) {
          if (
            null != originalSizeByte &&
            "[object String]" !=
              Object.prototype.toString.call(originalSizeByte)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: originalSizeByte EXPECTED TYPE: String",
              null,
              null
            );
          (this.originalSizeByte = originalSizeByte),
            this.keyModified.set("original_Size_Byte", 1);
        }
        getPreviewUrl() {
          return this.previewUrl;
        }
        setPreviewUrl(previewUrl) {
          if (
            null != previewUrl &&
            "[object String]" != Object.prototype.toString.call(previewUrl)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: previewUrl EXPECTED TYPE: String",
              null,
              null
            );
          (this.previewUrl = previewUrl),
            this.keyModified.set("preview_Url", 1);
        }
        getFileName() {
          return this.fileName;
        }
        setFileName(fileName) {
          if (
            null != fileName &&
            "[object String]" != Object.prototype.toString.call(fileName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fileName EXPECTED TYPE: String",
              null,
              null
            );
          (this.fileName = fileName), this.keyModified.set("file_Name", 1);
        }
        getFileId() {
          return this.fileId;
        }
        setFileId(fileId) {
          if (
            null != fileId &&
            "[object String]" != Object.prototype.toString.call(fileId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fileId EXPECTED TYPE: String",
              null,
              null
            );
          (this.fileId = fileId), this.keyModified.set("file_Id", 1);
        }
        getAttachmentId() {
          return this.attachmentId;
        }
        setAttachmentId(attachmentId) {
          if (
            null != attachmentId &&
            "[object String]" != Object.prototype.toString.call(attachmentId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: attachmentId EXPECTED TYPE: String",
              null,
              null
            );
          (this.attachmentId = attachmentId),
            this.keyModified.set("attachment_Id", 1);
        }
        getFileSize() {
          return this.fileSize;
        }
        setFileSize(fileSize) {
          if (
            null != fileSize &&
            "[object String]" != Object.prototype.toString.call(fileSize)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fileSize EXPECTED TYPE: String",
              null,
              null
            );
          (this.fileSize = fileSize), this.keyModified.set("file_Size", 1);
        }
        getCreatorId() {
          return this.creatorId;
        }
        setCreatorId(creatorId) {
          if (
            null != creatorId &&
            "[object String]" != Object.prototype.toString.call(creatorId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: creatorId EXPECTED TYPE: String",
              null,
              null
            );
          (this.creatorId = creatorId), this.keyModified.set("creator_Id", 1);
        }
        getLinkDocs() {
          return this.linkDocs;
        }
        setLinkDocs(linkDocs) {
          if (
            null != linkDocs &&
            "[object Number]" != Object.prototype.toString.call(linkDocs)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: linkDocs EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.linkDocs = linkDocs), this.keyModified.set("link_Docs", 1);
        }
        getDelete() {
          return this.delete1;
        }
        setDelete(delete1) {
          if (
            null != delete1 &&
            "[object String]" != Object.prototype.toString.call(delete1)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: delete1 EXPECTED TYPE: String",
              null,
              null
            );
          (this.delete1 = delete1), this.keyModified.set("_delete", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Options: class {
        constructor() {}
      },
      Reminder: class {
        constructor() {
          (this.period = null),
            (this.unit = null),
            (this.keyModified = new Map());
        }
        getPeriod() {
          return this.period;
        }
        setPeriod(period) {
          if (
            null != period &&
            "[object String]" != Object.prototype.toString.call(period)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: period EXPECTED TYPE: String",
              null,
              null
            );
          (this.period = period), this.keyModified.set("period", 1);
        }
        getUnit() {
          return this.unit;
        }
        setUnit(unit) {
          if (
            null != unit &&
            "[object String]" != Object.prototype.toString.call(unit)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: unit EXPECTED TYPE: String",
              null,
              null
            );
          (this.unit = unit), this.keyModified.set("unit", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      DeletedRecordsWrapper: class {
        constructor() {
          (this.data = null),
            (this.info = null),
            (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (null != info && !(info instanceof ZCRM.Record.Model.Info))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Info",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      DeletedRecord: class {
        constructor() {
          (this.deletedBy = null),
            (this.id = null),
            (this.displayName = null),
            (this.type = null),
            (this.createdBy = null),
            (this.deletedTime = null),
            (this.keyModified = new Map());
        }
        getDeletedBy() {
          return this.deletedBy;
        }
        setDeletedBy(deletedBy) {
          if (null != deletedBy && !(deletedBy instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: deletedBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.deletedBy = deletedBy), this.keyModified.set("deleted_by", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getDisplayName() {
          return this.displayName;
        }
        setDisplayName(displayName) {
          if (
            null != displayName &&
            "[object String]" != Object.prototype.toString.call(displayName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: displayName EXPECTED TYPE: String",
              null,
              null
            );
          (this.displayName = displayName),
            this.keyModified.set("display_name", 1);
        }
        getType() {
          return this.type;
        }
        setType(type) {
          if (
            null != type &&
            "[object String]" != Object.prototype.toString.call(type)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: type EXPECTED TYPE: String",
              null,
              null
            );
          (this.type = type), this.keyModified.set("type", 1);
        }
        getCreatedBy() {
          return this.createdBy;
        }
        setCreatedBy(createdBy) {
          if (null != createdBy && !(createdBy instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.createdBy = createdBy), this.keyModified.set("created_by", 1);
        }
        getDeletedTime() {
          return this.deletedTime;
        }
        setDeletedTime(deletedTime) {
          if (null != deletedTime && !(deletedTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: deletedTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.deletedTime = deletedTime),
            this.keyModified.set("deleted_time", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      LineTax: class {
        constructor() {
          (this.percentage = null),
            (this.name = null),
            (this.id = null),
            (this.value = null),
            (this.keyModified = new Map());
        }
        getPercentage() {
          return this.percentage;
        }
        setPercentage(percentage) {
          if (
            null != percentage &&
            "[object Number]" != Object.prototype.toString.call(percentage)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: percentage EXPECTED TYPE: Float",
              null,
              null
            );
          (this.percentage = percentage), this.keyModified.set("percentage", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getValue() {
          return this.value;
        }
        setValue(value) {
          if (
            null != value &&
            "[object Number]" != Object.prototype.toString.call(value)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: value EXPECTED TYPE: Float",
              null,
              null
            );
          (this.value = value), this.keyModified.set("value", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RecurringActivity: class {
        constructor() {
          (this.rrule = null), (this.keyModified = new Map());
        }
        getRrule() {
          return this.rrule;
        }
        setRrule(rrule) {
          if (
            null != rrule &&
            "[object String]" != Object.prototype.toString.call(rrule)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: rrule EXPECTED TYPE: String",
              null,
              null
            );
          (this.rrule = rrule), this.keyModified.set("RRULE", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Comment: class {
        constructor() {
          (this.commentedBy = null),
            (this.commentedTime = null),
            (this.commentContent = null),
            (this.id = null),
            (this.keyModified = new Map());
        }
        getCommentedBy() {
          return this.commentedBy;
        }
        setCommentedBy(commentedBy) {
          if (
            null != commentedBy &&
            "[object String]" != Object.prototype.toString.call(commentedBy)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: commentedBy EXPECTED TYPE: String",
              null,
              null
            );
          (this.commentedBy = commentedBy),
            this.keyModified.set("commented_by", 1);
        }
        getCommentedTime() {
          return this.commentedTime;
        }
        setCommentedTime(commentedTime) {
          if (null != commentedTime && !(commentedTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: commentedTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.commentedTime = commentedTime),
            this.keyModified.set("commented_time", 1);
        }
        getCommentContent() {
          return this.commentContent;
        }
        setCommentContent(commentContent) {
          if (
            null != commentContent &&
            "[object String]" != Object.prototype.toString.call(commentContent)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: commentContent EXPECTED TYPE: String",
              null,
              null
            );
          (this.commentContent = commentContent),
            this.keyModified.set("comment_content", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      CarryOverTags: class {
        constructor() {
          (this.contacts = null),
            (this.accounts = null),
            (this.deals = null),
            (this.keyModified = new Map());
        }
        getContacts() {
          return this.contacts;
        }
        setContacts(contacts) {
          if (
            null != contacts &&
            "[object Array]" != Object.prototype.toString.call(contacts)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: contacts EXPECTED TYPE: Array",
              null,
              null
            );
          (this.contacts = contacts), this.keyModified.set("Contacts", 1);
        }
        getAccounts() {
          return this.accounts;
        }
        setAccounts(accounts) {
          if (
            null != accounts &&
            "[object Array]" != Object.prototype.toString.call(accounts)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: accounts EXPECTED TYPE: Array",
              null,
              null
            );
          (this.accounts = accounts), this.keyModified.set("Accounts", 1);
        }
        getDeals() {
          return this.deals;
        }
        setDeals(deals) {
          if (
            null != deals &&
            "[object Array]" != Object.prototype.toString.call(deals)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: deals EXPECTED TYPE: Array",
              null,
              null
            );
          (this.deals = deals), this.keyModified.set("Deals", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      MassUpdateSuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      GetRecordParam: {
        APPROVED: new Param("approved", "Record.Model.GetRecordParam"),
        CONVERTED: new Param("converted", "Record.Model.GetRecordParam"),
        CVID: new Param("cvid", "Record.Model.GetRecordParam"),
        UID: new Param("uid", "Record.Model.GetRecordParam"),
        FIELDS: new Param("fields", "Record.Model.GetRecordParam"),
        STARTDATETIME: new Param(
          "startDateTime",
          "Record.Model.GetRecordParam"
        ),
        ENDDATETIME: new Param("endDateTime", "Record.Model.GetRecordParam"),
        TERRITORY_ID: new Param("territory_id", "Record.Model.GetRecordParam"),
        INCLUDE_CHILD: new Param(
          "include_child",
          "Record.Model.GetRecordParam"
        ),
      },
      CreateRecordsHeader: {
        X_EXTERNAL: new Header(
          "X-EXTERNAL",
          "Record.Model.CreateRecordsHeader"
        ),
      },
      UpsertRecordsHeader: {
        X_EXTERNAL: new Header(
          "X-EXTERNAL",
          "Record.Model.UpsertRecordsHeader"
        ),
      },
      DeleteRecordUsingExternalIDParam: {
        WF_TRIGGER: new Param(
          "wf_trigger",
          "Record.Model.DeleteRecordUsingExternalIDParam"
        ),
      },
      GetRecordsHeader: {
        IF_MODIFIED_SINCE: new Header(
          "If-Modified-Since",
          "Record.Model.GetRecordsHeader"
        ),
        X_EXTERNAL: new Header("X-EXTERNAL", "Record.Model.GetRecordsHeader"),
      },
      GetRecordHeader: {
        IF_MODIFIED_SINCE: new Header(
          "If-Modified-Since",
          "Record.Model.GetRecordHeader"
        ),
        X_EXTERNAL: new Header("X-EXTERNAL", "Record.Model.GetRecordHeader"),
      },
      GetRecordUsingExternalIDParam: {
        APPROVED: new Param(
          "approved",
          "Record.Model.GetRecordUsingExternalIDParam"
        ),
        CONVERTED: new Param(
          "converted",
          "Record.Model.GetRecordUsingExternalIDParam"
        ),
        CVID: new Param("cvid", "Record.Model.GetRecordUsingExternalIDParam"),
        UID: new Param("uid", "Record.Model.GetRecordUsingExternalIDParam"),
        FIELDS: new Param(
          "fields",
          "Record.Model.GetRecordUsingExternalIDParam"
        ),
        STARTDATETIME: new Param(
          "startDateTime",
          "Record.Model.GetRecordUsingExternalIDParam"
        ),
        ENDDATETIME: new Param(
          "endDateTime",
          "Record.Model.GetRecordUsingExternalIDParam"
        ),
        TERRITORY_ID: new Param(
          "territory_id",
          "Record.Model.GetRecordUsingExternalIDParam"
        ),
        INCLUDE_CHILD: new Param(
          "include_child",
          "Record.Model.GetRecordUsingExternalIDParam"
        ),
      },
      GetDeletedRecordsParam: {
        TYPE: new Param("type", "Record.Model.GetDeletedRecordsParam"),
        PAGE: new Param("page", "Record.Model.GetDeletedRecordsParam"),
        PER_PAGE: new Param("per_page", "Record.Model.GetDeletedRecordsParam"),
      },
      UpdateRecordUsingExternalIDHeader: {
        X_EXTERNAL: new Header(
          "X-EXTERNAL",
          "Record.Model.UpdateRecordUsingExternalIDHeader"
        ),
      },
      GetMassUpdateStatusParam: {
        JOB_ID: new Param("job_id", "Record.Model.GetMassUpdateStatusParam"),
      },
      UpdateRecordHeader: {
        X_EXTERNAL: new Header("X-EXTERNAL", "Record.Model.UpdateRecordHeader"),
      },
      GetRecordsParam: {
        APPROVED: new Param("approved", "Record.Model.GetRecordsParam"),
        CONVERTED: new Param("converted", "Record.Model.GetRecordsParam"),
        CVID: new Param("cvid", "Record.Model.GetRecordsParam"),
        IDS: new Param("ids", "Record.Model.GetRecordsParam"),
        UID: new Param("uid", "Record.Model.GetRecordsParam"),
        FIELDS: new Param("fields", "Record.Model.GetRecordsParam"),
        SORT_BY: new Param("sort_by", "Record.Model.GetRecordsParam"),
        SORT_ORDER: new Param("sort_order", "Record.Model.GetRecordsParam"),
        PAGE: new Param("page", "Record.Model.GetRecordsParam"),
        PER_PAGE: new Param("per_page", "Record.Model.GetRecordsParam"),
        STARTDATETIME: new Param(
          "startDateTime",
          "Record.Model.GetRecordsParam"
        ),
        ENDDATETIME: new Param("endDateTime", "Record.Model.GetRecordsParam"),
        TERRITORY_ID: new Param("territory_id", "Record.Model.GetRecordsParam"),
        INCLUDE_CHILD: new Param(
          "include_child",
          "Record.Model.GetRecordsParam"
        ),
      },
      SearchRecordsParam: {
        CRITERIA: new Param("criteria", "Record.Model.SearchRecordsParam"),
        EMAIL: new Param("email", "Record.Model.SearchRecordsParam"),
        PHONE: new Param("phone", "Record.Model.SearchRecordsParam"),
        WORD: new Param("word", "Record.Model.SearchRecordsParam"),
        CONVERTED: new Param("converted", "Record.Model.SearchRecordsParam"),
        APPROVED: new Param("approved", "Record.Model.SearchRecordsParam"),
        PAGE: new Param("page", "Record.Model.SearchRecordsParam"),
        PER_PAGE: new Param("per_page", "Record.Model.SearchRecordsParam"),
        FIELDS: new Param("fields", "Record.Model.SearchRecordsParam"),
      },
      DeleteRecordParam: {
        WF_TRIGGER: new Param("wf_trigger", "Record.Model.DeleteRecordParam"),
      },
      UpdateRecordsHeader: {
        X_EXTERNAL: new Header(
          "X-EXTERNAL",
          "Record.Model.UpdateRecordsHeader"
        ),
      },
      SearchRecordsHeader: {
        X_EXTERNAL: new Header(
          "X-EXTERNAL",
          "Record.Model.SearchRecordsHeader"
        ),
      },
      DeleteRecordHeader: {
        X_EXTERNAL: new Header("X-EXTERNAL", "Record.Model.DeleteRecordHeader"),
      },
      DeleteRecordsParam: {
        IDS: new Param("ids", "Record.Model.DeleteRecordsParam"),
        WF_TRIGGER: new Param("wf_trigger", "Record.Model.DeleteRecordsParam"),
      },
      DeleteRecordsHeader: {
        X_EXTERNAL: new Header(
          "X-EXTERNAL",
          "Record.Model.DeleteRecordsHeader"
        ),
      },
      GetDeletedRecordsHeader: {
        IF_MODIFIED_SINCE: new Header(
          "If-Modified-Since",
          "Record.Model.GetDeletedRecordsHeader"
        ),
      },
      DeleteRecordUsingExternalIDHeader: {
        X_EXTERNAL: new Header(
          "X-EXTERNAL",
          "Record.Model.DeleteRecordUsingExternalIDHeader"
        ),
      },
      GetRecordUsingExternalIDHeader: {
        IF_MODIFIED_SINCE: new Header(
          "If-Modified-Since",
          "Record.Model.GetRecordUsingExternalIDHeader"
        ),
        X_EXTERNAL: new Header(
          "X-EXTERNAL",
          "Record.Model.GetRecordUsingExternalIDHeader"
        ),
      },
    },
    Operations: class {
      constructor() {}
      async getRecord(
        id,
        moduleAPIName,
        paramInstance = null,
        headerInstance = null
      ) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/")).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.setModuleAPIName(moduleAPIName),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateRecord(id, moduleAPIName, request, headerInstance = null) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Record.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/")).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.setModuleAPIName(moduleAPIName),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async deleteRecord(
        id,
        moduleAPIName,
        paramInstance = null,
        headerInstance = null
      ) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/")).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getRecords(
        moduleAPIName,
        paramInstance = null,
        headerInstance = null
      ) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.setModuleAPIName(moduleAPIName),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async createRecords(moduleAPIName, request, headerInstance = null) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Record.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.setModuleAPIName(moduleAPIName),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async updateRecords(moduleAPIName, request, headerInstance = null) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Record.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.setModuleAPIName(moduleAPIName),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async deleteRecords(
        moduleAPIName,
        paramInstance = null,
        headerInstance = null
      ) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async upsertRecords(moduleAPIName, request, headerInstance = null) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Record.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/upsert")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_ACTION),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.setModuleAPIName(moduleAPIName),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getDeletedRecords(
        moduleAPIName,
        paramInstance = null,
        headerInstance = null
      ) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/deleted")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.DeletedRecordsHandler",
            "application/json"
          )
        );
      }
      async searchRecords(
        moduleAPIName,
        paramInstance = null,
        headerInstance = null
      ) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/search")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.setModuleAPIName(moduleAPIName),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async convertLead(id, request) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Record.Model.ConvertBodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: ConvertBodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/Leads/")).concat(id.toString())).concat(
            "/actions/convert"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          await Utility.getFields("Deals", handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ConvertActionHandler",
            "application/json"
          )
        );
      }
      async getPhoto(id, moduleAPIName) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/")).concat(id.toString())).concat("/photo")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.DownloadHandler",
            "application/x-download"
          )
        );
      }
      async uploadPhoto(id, moduleAPIName, request) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Record.Model.FileBodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: FileBodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/")).concat(id.toString())).concat("/photo")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("multipart/form-data"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          await Utility.getFields(moduleAPIName, handlerInstance),
          await Utility.verifyPhotoSupport(moduleAPIName),
          handlerInstance.apiCall(
            "Record.Model.FileHandler",
            "application/json"
          )
        );
      }
      async deletePhoto(id, moduleAPIName) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/")).concat(id.toString())).concat("/photo")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.FileHandler",
            "application/json"
          )
        );
      }
      async massUpdateRecords(moduleAPIName, request) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Record.Model.MassUpdateBodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: MassUpdateBodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/actions/mass_update")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.setModuleAPIName(moduleAPIName),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.MassUpdateActionHandler",
            "application/json"
          )
        );
      }
      async getMassUpdateStatus(moduleAPIName, paramInstance = null) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/actions/mass_update")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.MassUpdateResponseHandler",
            "application/json"
          )
        );
      }
      async getRecordUsingExternalId(
        externalFieldValue,
        moduleAPIName,
        paramInstance = null,
        headerInstance = null
      ) {
        if (
          "[object String]" !=
          Object.prototype.toString.call(externalFieldValue)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalFieldValue EXPECTED TYPE: String",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/")).concat(externalFieldValue.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.setModuleAPIName(moduleAPIName),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateRecordUsingExternalId(
        externalFieldValue,
        moduleAPIName,
        request,
        headerInstance = null
      ) {
        if (
          "[object String]" !=
          Object.prototype.toString.call(externalFieldValue)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalFieldValue EXPECTED TYPE: String",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Record.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/")).concat(externalFieldValue.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.setModuleAPIName(moduleAPIName),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async deleteRecordUsingExternalId(
        externalFieldValue,
        moduleAPIName,
        paramInstance = null,
        headerInstance = null
      ) {
        if (
          "[object String]" !=
          Object.prototype.toString.call(externalFieldValue)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalFieldValue EXPECTED TYPE: String",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/")).concat(externalFieldValue.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          await Utility.getFields(moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "Record.Model.ActionHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.Record.Model.InventoryLineItems = class extends (
    ZCRM.Record.Model.Record
  ) {
    constructor() {
      super();
    }
    getProduct() {
      return this.getKeyValue("product");
    }
    setProduct(product) {
      if (
        null != product &&
        !(product instanceof ZCRM.Record.Model.LineItemProduct)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: product EXPECTED TYPE: LineItemProduct",
          null,
          null
        );
      this.addKeyValue("product", product);
    }
    getQuantity() {
      return this.getKeyValue("quantity");
    }
    setQuantity(quantity) {
      if (
        null != quantity &&
        "[object Number]" != Object.prototype.toString.call(quantity)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: quantity EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("quantity", quantity);
    }
    getDiscount() {
      return this.getKeyValue("Discount");
    }
    setDiscount(discount) {
      if (
        null != discount &&
        "[object String]" != Object.prototype.toString.call(discount)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: discount EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("Discount", discount);
    }
    getTotalAfterDiscount() {
      return this.getKeyValue("total_after_discount");
    }
    setTotalAfterDiscount(totalAfterDiscount) {
      if (
        null != totalAfterDiscount &&
        "[object Number]" != Object.prototype.toString.call(totalAfterDiscount)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: totalAfterDiscount EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("total_after_discount", totalAfterDiscount);
    }
    getNetTotal() {
      return this.getKeyValue("net_total");
    }
    setNetTotal(netTotal) {
      if (
        null != netTotal &&
        "[object Number]" != Object.prototype.toString.call(netTotal)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: netTotal EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("net_total", netTotal);
    }
    getBook() {
      return this.getKeyValue("book");
    }
    setBook(book) {
      if (
        null != book &&
        "[object Number]" != Object.prototype.toString.call(book)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: book EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("book", book);
    }
    getTax() {
      return this.getKeyValue("Tax");
    }
    setTax(tax) {
      if (
        null != tax &&
        "[object Number]" != Object.prototype.toString.call(tax)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: tax EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("Tax", tax);
    }
    getListPrice() {
      return this.getKeyValue("list_price");
    }
    setListPrice(listPrice) {
      if (
        null != listPrice &&
        "[object Number]" != Object.prototype.toString.call(listPrice)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: listPrice EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("list_price", listPrice);
    }
    getUnitPrice() {
      return this.getKeyValue("unit_price");
    }
    setUnitPrice(unitPrice) {
      if (
        null != unitPrice &&
        "[object Number]" != Object.prototype.toString.call(unitPrice)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: unitPrice EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("unit_price", unitPrice);
    }
    getQuantityInStock() {
      return this.getKeyValue("quantity_in_stock");
    }
    setQuantityInStock(quantityInStock) {
      if (
        null != quantityInStock &&
        "[object Number]" != Object.prototype.toString.call(quantityInStock)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: quantityInStock EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("quantity_in_stock", quantityInStock);
    }
    getTotal() {
      return this.getKeyValue("total");
    }
    setTotal(total) {
      if (
        null != total &&
        "[object Number]" != Object.prototype.toString.call(total)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: total EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("total", total);
    }
    getProductDescription() {
      return this.getKeyValue("product_description");
    }
    setProductDescription(productDescription) {
      if (
        null != productDescription &&
        "[object String]" != Object.prototype.toString.call(productDescription)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: productDescription EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("product_description", productDescription);
    }
    getLineTax() {
      return this.getKeyValue("line_tax");
    }
    setLineTax(lineTax) {
      if (
        null != lineTax &&
        "[object Array]" != Object.prototype.toString.call(lineTax)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: lineTax EXPECTED TYPE: Array",
          null,
          null
        );
      this.addKeyValue("line_tax", lineTax);
    }
  }),
  (ZCRM.Record.Model.Field.Quotes = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    DISCOUNT: new ZCRM.Record.Model.Field("Discount"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    SHIPPING_STATE: new ZCRM.Record.Model.Field("Shipping_State"),
    TAX: new ZCRM.Record.Model.Field("Tax"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    DEAL_NAME: new ZCRM.Record.Model.Field("Deal_Name"),
    VALID_TILL: new ZCRM.Record.Model.Field("Valid_Till"),
    BILLING_COUNTRY: new ZCRM.Record.Model.Field("Billing_Country"),
    ACCOUNT_NAME: new ZCRM.Record.Model.Field("Account_Name"),
    TEAM: new ZCRM.Record.Model.Field("Team"),
    ID: new ZCRM.Record.Model.Field("id"),
    CARRIER: new ZCRM.Record.Model.Field("Carrier"),
    QUOTE_STAGE: new ZCRM.Record.Model.Field("Quote_Stage"),
    GRAND_TOTAL: new ZCRM.Record.Model.Field("Grand_Total"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    BILLING_STREET: new ZCRM.Record.Model.Field("Billing_Street"),
    ADJUSTMENT: new ZCRM.Record.Model.Field("Adjustment"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    TERMS_AND_CONDITIONS: new ZCRM.Record.Model.Field("Terms_and_Conditions"),
    SUB_TOTAL: new ZCRM.Record.Model.Field("Sub_Total"),
    BILLING_CODE: new ZCRM.Record.Model.Field("Billing_Code"),
    PRODUCT_DETAILS: new ZCRM.Record.Model.Field("Product_Details"),
    SUBJECT: new ZCRM.Record.Model.Field("Subject"),
    CONTACT_NAME: new ZCRM.Record.Model.Field("Contact_Name"),
    SHIPPING_CITY: new ZCRM.Record.Model.Field("Shipping_City"),
    SHIPPING_COUNTRY: new ZCRM.Record.Model.Field("Shipping_Country"),
    SHIPPING_CODE: new ZCRM.Record.Model.Field("Shipping_Code"),
    BILLING_CITY: new ZCRM.Record.Model.Field("Billing_City"),
    QUOTE_NUMBER: new ZCRM.Record.Model.Field("Quote_Number"),
    BILLING_STATE: new ZCRM.Record.Model.Field("Billing_State"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    SHIPPING_STREET: new ZCRM.Record.Model.Field("Shipping_Street"),
  }),
  (ZCRM.Record.Model.Field.Price_Books = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    ACTIVE: new ZCRM.Record.Model.Field("Active"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    PRICING_DETAILS: new ZCRM.Record.Model.Field("Pricing_Details"),
    PRICING_MODEL: new ZCRM.Record.Model.Field("Pricing_Model"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    PRICE_BOOK_NAME: new ZCRM.Record.Model.Field("Price_Book_Name"),
    ID: new ZCRM.Record.Model.Field("id"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
  }),
  (ZCRM.Record.Model.Field.Contacts = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    EMAIL: new ZCRM.Record.Model.Field("Email"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    VENDOR_NAME: new ZCRM.Record.Model.Field("Vendor_Name"),
    MAILING_ZIP: new ZCRM.Record.Model.Field("Mailing_Zip"),
    REPORTS_TO: new ZCRM.Record.Model.Field("Reports_To"),
    OTHER_PHONE: new ZCRM.Record.Model.Field("Other_Phone"),
    MAILING_STATE: new ZCRM.Record.Model.Field("Mailing_State"),
    TWITTER: new ZCRM.Record.Model.Field("Twitter"),
    OTHER_ZIP: new ZCRM.Record.Model.Field("Other_Zip"),
    MAILING_STREET: new ZCRM.Record.Model.Field("Mailing_Street"),
    OTHER_STATE: new ZCRM.Record.Model.Field("Other_State"),
    SALUTATION: new ZCRM.Record.Model.Field("Salutation"),
    OTHER_COUNTRY: new ZCRM.Record.Model.Field("Other_Country"),
    LAST_ACTIVITY_TIME: new ZCRM.Record.Model.Field("Last_Activity_Time"),
    FIRST_NAME: new ZCRM.Record.Model.Field("First_Name"),
    FULL_NAME: new ZCRM.Record.Model.Field("Full_Name"),
    ASST_PHONE: new ZCRM.Record.Model.Field("Asst_Phone"),
    RECORD_IMAGE: new ZCRM.Record.Model.Field("Record_Image"),
    DEPARTMENT: new ZCRM.Record.Model.Field("Department"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    SKYPE_ID: new ZCRM.Record.Model.Field("Skype_ID"),
    ASSISTANT: new ZCRM.Record.Model.Field("Assistant"),
    PHONE: new ZCRM.Record.Model.Field("Phone"),
    MAILING_COUNTRY: new ZCRM.Record.Model.Field("Mailing_Country"),
    ACCOUNT_NAME: new ZCRM.Record.Model.Field("Account_Name"),
    ID: new ZCRM.Record.Model.Field("id"),
    EMAIL_OPT_OUT: new ZCRM.Record.Model.Field("Email_Opt_Out"),
    REPORTING_TO: new ZCRM.Record.Model.Field("Reporting_To"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    DATE_OF_BIRTH: new ZCRM.Record.Model.Field("Date_of_Birth"),
    MAILING_CITY: new ZCRM.Record.Model.Field("Mailing_City"),
    OTHER_CITY: new ZCRM.Record.Model.Field("Other_City"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    TITLE: new ZCRM.Record.Model.Field("Title"),
    OTHER_STREET: new ZCRM.Record.Model.Field("Other_Street"),
    MOBILE: new ZCRM.Record.Model.Field("Mobile"),
    TERRITORIES: new ZCRM.Record.Model.Field("Territories"),
    HOME_PHONE: new ZCRM.Record.Model.Field("Home_Phone"),
    LAST_NAME: new ZCRM.Record.Model.Field("Last_Name"),
    LEAD_SOURCE: new ZCRM.Record.Model.Field("Lead_Source"),
    IS_RECORD_DUPLICATE: new ZCRM.Record.Model.Field("Is_Record_Duplicate"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    FAX: new ZCRM.Record.Model.Field("Fax"),
    SECONDARY_EMAIL: new ZCRM.Record.Model.Field("Secondary_Email"),
  }),
  (ZCRM.Record.Model.Field.Accounts = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    OWNERSHIP: new ZCRM.Record.Model.Field("Ownership"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    ACCOUNT_TYPE: new ZCRM.Record.Model.Field("Account_Type"),
    RATING: new ZCRM.Record.Model.Field("Rating"),
    SIC_CODE: new ZCRM.Record.Model.Field("SIC_Code"),
    SHIPPING_STATE: new ZCRM.Record.Model.Field("Shipping_State"),
    WEBSITE: new ZCRM.Record.Model.Field("Website"),
    EMPLOYEES: new ZCRM.Record.Model.Field("Employees"),
    LAST_ACTIVITY_TIME: new ZCRM.Record.Model.Field("Last_Activity_Time"),
    INDUSTRY: new ZCRM.Record.Model.Field("Industry"),
    RECORD_IMAGE: new ZCRM.Record.Model.Field("Record_Image"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    ACCOUNT_SITE: new ZCRM.Record.Model.Field("Account_Site"),
    PHONE: new ZCRM.Record.Model.Field("Phone"),
    BILLING_COUNTRY: new ZCRM.Record.Model.Field("Billing_Country"),
    ACCOUNT_NAME: new ZCRM.Record.Model.Field("Account_Name"),
    ID: new ZCRM.Record.Model.Field("id"),
    ACCOUNT_NUMBER: new ZCRM.Record.Model.Field("Account_Number"),
    TICKER_SYMBOL: new ZCRM.Record.Model.Field("Ticker_Symbol"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    BILLING_STREET: new ZCRM.Record.Model.Field("Billing_Street"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    BILLING_CODE: new ZCRM.Record.Model.Field("Billing_Code"),
    TERRITORIES: new ZCRM.Record.Model.Field("Territories"),
    PARENT_ACCOUNT: new ZCRM.Record.Model.Field("Parent_Account"),
    SHIPPING_CITY: new ZCRM.Record.Model.Field("Shipping_City"),
    SHIPPING_COUNTRY: new ZCRM.Record.Model.Field("Shipping_Country"),
    SHIPPING_CODE: new ZCRM.Record.Model.Field("Shipping_Code"),
    BILLING_CITY: new ZCRM.Record.Model.Field("Billing_City"),
    BILLING_STATE: new ZCRM.Record.Model.Field("Billing_State"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    FAX: new ZCRM.Record.Model.Field("Fax"),
    ANNUAL_REVENUE: new ZCRM.Record.Model.Field("Annual_Revenue"),
    SHIPPING_STREET: new ZCRM.Record.Model.Field("Shipping_Street"),
  }),
  (ZCRM.Record.Model.Field.Sales_Orders = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    DISCOUNT: new ZCRM.Record.Model.Field("Discount"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    CUSTOMER_NO: new ZCRM.Record.Model.Field("Customer_No"),
    SHIPPING_STATE: new ZCRM.Record.Model.Field("Shipping_State"),
    TAX: new ZCRM.Record.Model.Field("Tax"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    DEAL_NAME: new ZCRM.Record.Model.Field("Deal_Name"),
    BILLING_COUNTRY: new ZCRM.Record.Model.Field("Billing_Country"),
    ACCOUNT_NAME: new ZCRM.Record.Model.Field("Account_Name"),
    ID: new ZCRM.Record.Model.Field("id"),
    CARRIER: new ZCRM.Record.Model.Field("Carrier"),
    QUOTE_NAME: new ZCRM.Record.Model.Field("Quote_Name"),
    STATUS: new ZCRM.Record.Model.Field("Status"),
    SALES_COMMISSION: new ZCRM.Record.Model.Field("Sales_Commission"),
    GRAND_TOTAL: new ZCRM.Record.Model.Field("Grand_Total"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    DUE_DATE: new ZCRM.Record.Model.Field("Due_Date"),
    BILLING_STREET: new ZCRM.Record.Model.Field("Billing_Street"),
    ADJUSTMENT: new ZCRM.Record.Model.Field("Adjustment"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    TERMS_AND_CONDITIONS: new ZCRM.Record.Model.Field("Terms_and_Conditions"),
    SUB_TOTAL: new ZCRM.Record.Model.Field("Sub_Total"),
    BILLING_CODE: new ZCRM.Record.Model.Field("Billing_Code"),
    PRODUCT_DETAILS: new ZCRM.Record.Model.Field("Product_Details"),
    SUBJECT: new ZCRM.Record.Model.Field("Subject"),
    CONTACT_NAME: new ZCRM.Record.Model.Field("Contact_Name"),
    EXCISE_DUTY: new ZCRM.Record.Model.Field("Excise_Duty"),
    SHIPPING_CITY: new ZCRM.Record.Model.Field("Shipping_City"),
    SHIPPING_COUNTRY: new ZCRM.Record.Model.Field("Shipping_Country"),
    SHIPPING_CODE: new ZCRM.Record.Model.Field("Shipping_Code"),
    BILLING_CITY: new ZCRM.Record.Model.Field("Billing_City"),
    SO_NUMBER: new ZCRM.Record.Model.Field("SO_Number"),
    PURCHASE_ORDER: new ZCRM.Record.Model.Field("Purchase_Order"),
    BILLING_STATE: new ZCRM.Record.Model.Field("Billing_State"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    PENDING: new ZCRM.Record.Model.Field("Pending"),
    SHIPPING_STREET: new ZCRM.Record.Model.Field("Shipping_Street"),
  }),
  (ZCRM.Record.Model.Field.Notes = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    PARENT_ID: new ZCRM.Record.Model.Field("Parent_Id"),
    ID: new ZCRM.Record.Model.Field("id"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    NOTE_TITLE: new ZCRM.Record.Model.Field("Note_Title"),
    NOTE_CONTENT: new ZCRM.Record.Model.Field("Note_Content"),
  }),
  (ZCRM.Record.Model.Field.Products = {
    PRODUCT_CATEGORY: new ZCRM.Record.Model.Field("Product_Category"),
    QTY_IN_DEMAND: new ZCRM.Record.Model.Field("Qty_in_Demand"),
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    VENDOR_NAME: new ZCRM.Record.Model.Field("Vendor_Name"),
    TAX: new ZCRM.Record.Model.Field("Tax"),
    SALES_START_DATE: new ZCRM.Record.Model.Field("Sales_Start_Date"),
    PRODUCT_ACTIVE: new ZCRM.Record.Model.Field("Product_Active"),
    RECORD_IMAGE: new ZCRM.Record.Model.Field("Record_Image"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    PRODUCT_CODE: new ZCRM.Record.Model.Field("Product_Code"),
    MANUFACTURER: new ZCRM.Record.Model.Field("Manufacturer"),
    ID: new ZCRM.Record.Model.Field("id"),
    SUPPORT_EXPIRY_DATE: new ZCRM.Record.Model.Field("Support_Expiry_Date"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    COMMISSION_RATE: new ZCRM.Record.Model.Field("Commission_Rate"),
    PRODUCT_NAME: new ZCRM.Record.Model.Field("Product_Name"),
    HANDLER: new ZCRM.Record.Model.Field("Handler"),
    SUPPORT_START_DATE: new ZCRM.Record.Model.Field("Support_Start_Date"),
    USAGE_UNIT: new ZCRM.Record.Model.Field("Usage_Unit"),
    QTY_ORDERED: new ZCRM.Record.Model.Field("Qty_Ordered"),
    QTY_IN_STOCK: new ZCRM.Record.Model.Field("Qty_in_Stock"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    SALES_END_DATE: new ZCRM.Record.Model.Field("Sales_End_Date"),
    UNIT_PRICE: new ZCRM.Record.Model.Field("Unit_Price"),
    TAXABLE: new ZCRM.Record.Model.Field("Taxable"),
    REORDER_LEVEL: new ZCRM.Record.Model.Field("Reorder_Level"),
  }),
  (ZCRM.Record.Model.Field.Cases = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    EMAIL: new ZCRM.Record.Model.Field("Email"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    INTERNAL_COMMENTS: new ZCRM.Record.Model.Field("Internal_Comments"),
    NO_OF_COMMENTS: new ZCRM.Record.Model.Field("No_of_comments"),
    REPORTED_BY: new ZCRM.Record.Model.Field("Reported_By"),
    CASE_NUMBER: new ZCRM.Record.Model.Field("Case_Number"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    DEAL_NAME: new ZCRM.Record.Model.Field("Deal_Name"),
    PHONE: new ZCRM.Record.Model.Field("Phone"),
    ACCOUNT_NAME: new ZCRM.Record.Model.Field("Account_Name"),
    ID: new ZCRM.Record.Model.Field("id"),
    SOLUTION: new ZCRM.Record.Model.Field("Solution"),
    STATUS: new ZCRM.Record.Model.Field("Status"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    PRIORITY: new ZCRM.Record.Model.Field("Priority"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    COMMENTS: new ZCRM.Record.Model.Field("Comments"),
    PRODUCT_NAME: new ZCRM.Record.Model.Field("Product_Name"),
    ADD_COMMENT: new ZCRM.Record.Model.Field("Add_Comment"),
    CASE_ORIGIN: new ZCRM.Record.Model.Field("Case_Origin"),
    SUBJECT: new ZCRM.Record.Model.Field("Subject"),
    CASE_REASON: new ZCRM.Record.Model.Field("Case_Reason"),
    TYPE: new ZCRM.Record.Model.Field("Type"),
    IS_RECORD_DUPLICATE: new ZCRM.Record.Model.Field("Is_Record_Duplicate"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    RELATED_TO: new ZCRM.Record.Model.Field("Related_To"),
  }),
  (ZCRM.Record.Model.LineItemProduct = class extends ZCRM.Record.Model.Record {
    constructor() {
      super();
    }
    getProductCode() {
      return this.getKeyValue("Product_Code");
    }
    setProductCode(productCode) {
      if (
        null != productCode &&
        "[object String]" != Object.prototype.toString.call(productCode)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: productCode EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("Product_Code", productCode);
    }
    getCurrency() {
      return this.getKeyValue("Currency");
    }
    setCurrency(currency) {
      if (
        null != currency &&
        "[object String]" != Object.prototype.toString.call(currency)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: currency EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("Currency", currency);
    }
    getName() {
      return this.getKeyValue("name");
    }
    setName(name) {
      if (
        null != name &&
        "[object String]" != Object.prototype.toString.call(name)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: name EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("name", name);
    }
  }),
  (ZCRM.Record.Model.Field.Deals = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    CAMPAIGN_SOURCE: new ZCRM.Record.Model.Field("Campaign_Source"),
    CLOSING_DATE: new ZCRM.Record.Model.Field("Closing_Date"),
    LAST_ACTIVITY_TIME: new ZCRM.Record.Model.Field("Last_Activity_Time"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    LEAD_CONVERSION_TIME: new ZCRM.Record.Model.Field("Lead_Conversion_Time"),
    DEAL_NAME: new ZCRM.Record.Model.Field("Deal_Name"),
    EXPECTED_REVENUE: new ZCRM.Record.Model.Field("Expected_Revenue"),
    OVERALL_SALES_DURATION: new ZCRM.Record.Model.Field(
      "Overall_Sales_Duration"
    ),
    STAGE: new ZCRM.Record.Model.Field("Stage"),
    ID: new ZCRM.Record.Model.Field("id"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    TERRITORY: new ZCRM.Record.Model.Field("Territory"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    AMOUNT: new ZCRM.Record.Model.Field("Amount"),
    PROBABILITY: new ZCRM.Record.Model.Field("Probability"),
    NEXT_STEP: new ZCRM.Record.Model.Field("Next_Step"),
    CONTACT_NAME: new ZCRM.Record.Model.Field("Contact_Name"),
    SALES_CYCLE_DURATION: new ZCRM.Record.Model.Field("Sales_Cycle_Duration"),
    TYPE: new ZCRM.Record.Model.Field("Type"),
    DEAL_CATEGORY_STATUS: new ZCRM.Record.Model.Field("Deal_Category_Status"),
    LEAD_SOURCE: new ZCRM.Record.Model.Field("Lead_Source"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
  }),
  (ZCRM.Record.Model.Field.Events = {
    ALL_DAY: new ZCRM.Record.Model.Field("All_day"),
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    CHECK_IN_STATE: new ZCRM.Record.Model.Field("Check_In_State"),
    CHECK_IN_ADDRESS: new ZCRM.Record.Model.Field("Check_In_Address"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    START_DATETIME: new ZCRM.Record.Model.Field("Start_DateTime"),
    LATITUDE: new ZCRM.Record.Model.Field("Latitude"),
    PARTICIPANTS: new ZCRM.Record.Model.Field("Participants"),
    EVENT_TITLE: new ZCRM.Record.Model.Field("Event_Title"),
    END_DATETIME: new ZCRM.Record.Model.Field("End_DateTime"),
    CHECK_IN_BY: new ZCRM.Record.Model.Field("Check_In_By"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    CHECK_IN_CITY: new ZCRM.Record.Model.Field("Check_In_City"),
    ID: new ZCRM.Record.Model.Field("id"),
    CHECK_IN_COMMENT: new ZCRM.Record.Model.Field("Check_In_Comment"),
    REMIND_AT: new ZCRM.Record.Model.Field("Remind_At"),
    WHO_ID: new ZCRM.Record.Model.Field("Who_Id"),
    CHECK_IN_STATUS: new ZCRM.Record.Model.Field("Check_In_Status"),
    CHECK_IN_COUNTRY: new ZCRM.Record.Model.Field("Check_In_Country"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    VENUE: new ZCRM.Record.Model.Field("Venue"),
    ZIP_CODE: new ZCRM.Record.Model.Field("ZIP_Code"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    LONGITUDE: new ZCRM.Record.Model.Field("Longitude"),
    CHECK_IN_TIME: new ZCRM.Record.Model.Field("Check_In_Time"),
    RECURRING_ACTIVITY: new ZCRM.Record.Model.Field("Recurring_Activity"),
    WHAT_ID: new ZCRM.Record.Model.Field("What_Id"),
    CHECK_IN_SUB_LOCALITY: new ZCRM.Record.Model.Field("Check_In_Sub_Locality"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
  }),
  (ZCRM.Record.Model.Participants = class extends ZCRM.Record.Model.Record {
    constructor() {
      super();
    }
    getName() {
      return this.getKeyValue("name");
    }
    setName(name) {
      if (
        null != name &&
        "[object String]" != Object.prototype.toString.call(name)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: name EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("name", name);
    }
    getEmail() {
      return this.getKeyValue("Email");
    }
    setEmail(email) {
      if (
        null != email &&
        "[object String]" != Object.prototype.toString.call(email)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: email EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("Email", email);
    }
    getInvited() {
      return this.getKeyValue("invited");
    }
    setInvited(invited) {
      if (
        null != invited &&
        "[object Boolean]" != Object.prototype.toString.call(invited)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: invited EXPECTED TYPE: Boolean",
          null,
          null
        );
      this.addKeyValue("invited", invited);
    }
    getType() {
      return this.getKeyValue("type");
    }
    setType(type) {
      if (
        null != type &&
        "[object String]" != Object.prototype.toString.call(type)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: type EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("type", type);
    }
    getParticipant() {
      return this.getKeyValue("participant");
    }
    setParticipant(participant) {
      if (
        null != participant &&
        "[object String]" != Object.prototype.toString.call(participant)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: participant EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("participant", participant);
    }
    getStatus() {
      return this.getKeyValue("status");
    }
    setStatus(status) {
      if (
        null != status &&
        "[object String]" != Object.prototype.toString.call(status)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: status EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("status", status);
    }
  }),
  (ZCRM.Record.Model.Field.Invoices = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    DISCOUNT: new ZCRM.Record.Model.Field("Discount"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    SHIPPING_STATE: new ZCRM.Record.Model.Field("Shipping_State"),
    TAX: new ZCRM.Record.Model.Field("Tax"),
    INVOICE_DATE: new ZCRM.Record.Model.Field("Invoice_Date"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    BILLING_COUNTRY: new ZCRM.Record.Model.Field("Billing_Country"),
    ACCOUNT_NAME: new ZCRM.Record.Model.Field("Account_Name"),
    ID: new ZCRM.Record.Model.Field("id"),
    SALES_ORDER: new ZCRM.Record.Model.Field("Sales_Order"),
    STATUS: new ZCRM.Record.Model.Field("Status"),
    GRAND_TOTAL: new ZCRM.Record.Model.Field("Grand_Total"),
    SALES_COMMISSION: new ZCRM.Record.Model.Field("Sales_Commission"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    DUE_DATE: new ZCRM.Record.Model.Field("Due_Date"),
    BILLING_STREET: new ZCRM.Record.Model.Field("Billing_Street"),
    ADJUSTMENT: new ZCRM.Record.Model.Field("Adjustment"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    TERMS_AND_CONDITIONS: new ZCRM.Record.Model.Field("Terms_and_Conditions"),
    SUB_TOTAL: new ZCRM.Record.Model.Field("Sub_Total"),
    INVOICE_NUMBER: new ZCRM.Record.Model.Field("Invoice_Number"),
    BILLING_CODE: new ZCRM.Record.Model.Field("Billing_Code"),
    PRODUCT_DETAILS: new ZCRM.Record.Model.Field("Product_Details"),
    SUBJECT: new ZCRM.Record.Model.Field("Subject"),
    CONTACT_NAME: new ZCRM.Record.Model.Field("Contact_Name"),
    EXCISE_DUTY: new ZCRM.Record.Model.Field("Excise_Duty"),
    SHIPPING_CITY: new ZCRM.Record.Model.Field("Shipping_City"),
    SHIPPING_COUNTRY: new ZCRM.Record.Model.Field("Shipping_Country"),
    SHIPPING_CODE: new ZCRM.Record.Model.Field("Shipping_Code"),
    BILLING_CITY: new ZCRM.Record.Model.Field("Billing_City"),
    PURCHASE_ORDER: new ZCRM.Record.Model.Field("Purchase_Order"),
    BILLING_STATE: new ZCRM.Record.Model.Field("Billing_State"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    SHIPPING_STREET: new ZCRM.Record.Model.Field("Shipping_Street"),
  }),
  (ZCRM.Record.Model.PricingDetails = class extends ZCRM.Record.Model.Record {
    constructor() {
      super();
    }
    getToRange() {
      return this.getKeyValue("to_range");
    }
    setToRange(toRange) {
      if (
        null != toRange &&
        "[object Number]" != Object.prototype.toString.call(toRange)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: toRange EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("to_range", toRange);
    }
    getDiscount() {
      return this.getKeyValue("discount");
    }
    setDiscount(discount) {
      if (
        null != discount &&
        "[object Number]" != Object.prototype.toString.call(discount)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: discount EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("discount", discount);
    }
    getFromRange() {
      return this.getKeyValue("from_range");
    }
    setFromRange(fromRange) {
      if (
        null != fromRange &&
        "[object Number]" != Object.prototype.toString.call(fromRange)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: fromRange EXPECTED TYPE: Float",
          null,
          null
        );
      this.addKeyValue("from_range", fromRange);
    }
  }),
  (ZCRM.Record.Model.Field.Tasks = {
    STATUS: new ZCRM.Record.Model.Field("Status"),
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    DUE_DATE: new ZCRM.Record.Model.Field("Due_Date"),
    PRIORITY: new ZCRM.Record.Model.Field("Priority"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    CLOSED_TIME: new ZCRM.Record.Model.Field("Closed_Time"),
    SUBJECT: new ZCRM.Record.Model.Field("Subject"),
    SEND_NOTIFICATION_EMAIL: new ZCRM.Record.Model.Field(
      "Send_Notification_Email"
    ),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    RECURRING_ACTIVITY: new ZCRM.Record.Model.Field("Recurring_Activity"),
    WHAT_ID: new ZCRM.Record.Model.Field("What_Id"),
    ID: new ZCRM.Record.Model.Field("id"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    REMIND_AT: new ZCRM.Record.Model.Field("Remind_At"),
    WHO_ID: new ZCRM.Record.Model.Field("Who_Id"),
  }),
  (ZCRM.Record.Model.Consent = class extends ZCRM.Record.Model.Record {
    constructor() {
      super();
    }
    getOwner() {
      return this.getKeyValue("Owner");
    }
    setOwner(owner) {
      if (null != owner && !(owner instanceof ZCRM.User.Model.User))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: owner EXPECTED TYPE: User",
          null,
          null
        );
      this.addKeyValue("Owner", owner);
    }
    getContactThroughEmail() {
      return this.getKeyValue("Contact_Through_Email");
    }
    setContactThroughEmail(contactThroughEmail) {
      if (
        null != contactThroughEmail &&
        "[object Boolean]" !=
          Object.prototype.toString.call(contactThroughEmail)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: contactThroughEmail EXPECTED TYPE: Boolean",
          null,
          null
        );
      this.addKeyValue("Contact_Through_Email", contactThroughEmail);
    }
    getContactThroughSocial() {
      return this.getKeyValue("Contact_Through_Social");
    }
    setContactThroughSocial(contactThroughSocial) {
      if (
        null != contactThroughSocial &&
        "[object Boolean]" !=
          Object.prototype.toString.call(contactThroughSocial)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: contactThroughSocial EXPECTED TYPE: Boolean",
          null,
          null
        );
      this.addKeyValue("Contact_Through_Social", contactThroughSocial);
    }
    getContactThroughSurvey() {
      return this.getKeyValue("Contact_Through_Survey");
    }
    setContactThroughSurvey(contactThroughSurvey) {
      if (
        null != contactThroughSurvey &&
        "[object Boolean]" !=
          Object.prototype.toString.call(contactThroughSurvey)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: contactThroughSurvey EXPECTED TYPE: Boolean",
          null,
          null
        );
      this.addKeyValue("Contact_Through_Survey", contactThroughSurvey);
    }
    getContactThroughPhone() {
      return this.getKeyValue("Contact_Through_Phone");
    }
    setContactThroughPhone(contactThroughPhone) {
      if (
        null != contactThroughPhone &&
        "[object Boolean]" !=
          Object.prototype.toString.call(contactThroughPhone)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: contactThroughPhone EXPECTED TYPE: Boolean",
          null,
          null
        );
      this.addKeyValue("Contact_Through_Phone", contactThroughPhone);
    }
    getMailSentTime() {
      return this.getKeyValue("Mail_Sent_Time");
    }
    setMailSentTime(mailSentTime) {
      if (null != mailSentTime && !(mailSentTime instanceof Date))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: mailSentTime EXPECTED TYPE: Date",
          null,
          null
        );
      this.addKeyValue("Mail_Sent_Time", mailSentTime);
    }
    getConsentDate() {
      return this.getKeyValue("Consent_Date");
    }
    setConsentDate(consentDate) {
      if (null != consentDate && !(consentDate instanceof Date))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: consentDate EXPECTED TYPE: Date",
          null,
          null
        );
      this.addKeyValue("Consent_Date", consentDate);
    }
    getConsentRemarks() {
      return this.getKeyValue("Consent_Remarks");
    }
    setConsentRemarks(consentRemarks) {
      if (
        null != consentRemarks &&
        "[object String]" != Object.prototype.toString.call(consentRemarks)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: consentRemarks EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("Consent_Remarks", consentRemarks);
    }
    getConsentThrough() {
      return this.getKeyValue("Consent_Through");
    }
    setConsentThrough(consentThrough) {
      if (
        null != consentThrough &&
        "[object String]" != Object.prototype.toString.call(consentThrough)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: consentThrough EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("Consent_Through", consentThrough);
    }
    getDataProcessingBasis() {
      return this.getKeyValue("Data_Processing_Basis");
    }
    setDataProcessingBasis(dataProcessingBasis) {
      if (
        null != dataProcessingBasis &&
        "[object String]" != Object.prototype.toString.call(dataProcessingBasis)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: dataProcessingBasis EXPECTED TYPE: String",
          null,
          null
        );
      this.addKeyValue("Data_Processing_Basis", dataProcessingBasis);
    }
  }),
  (ZCRM.Record.Model.Field.Calls = {
    CALL_DURATION: new ZCRM.Record.Model.Field("Call_Duration"),
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    REMINDER: new ZCRM.Record.Model.Field("Reminder"),
    CALLER_ID: new ZCRM.Record.Model.Field("Caller_ID"),
    CTI_ENTRY: new ZCRM.Record.Model.Field("CTI_Entry"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    CALL_START_TIME: new ZCRM.Record.Model.Field("Call_Start_Time"),
    SUBJECT: new ZCRM.Record.Model.Field("Subject"),
    CALL_AGENDA: new ZCRM.Record.Model.Field("Call_Agenda"),
    CALL_RESULT: new ZCRM.Record.Model.Field("Call_Result"),
    CALL_TYPE: new ZCRM.Record.Model.Field("Call_Type"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    WHAT_ID: new ZCRM.Record.Model.Field("What_Id"),
    CALL_DURATION_IN_SECONDS: new ZCRM.Record.Model.Field(
      "Call_Duration_in_seconds"
    ),
    CALL_PURPOSE: new ZCRM.Record.Model.Field("Call_Purpose"),
    ID: new ZCRM.Record.Model.Field("id"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    DIALLED_NUMBER: new ZCRM.Record.Model.Field("Dialled_Number"),
    CALL_STATUS: new ZCRM.Record.Model.Field("Call_Status"),
    WHO_ID: new ZCRM.Record.Model.Field("Who_Id"),
  }),
  (ZCRM.Record.Model.Field.Attachments = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    FILE_NAME: new ZCRM.Record.Model.Field("File_Name"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    SIZE: new ZCRM.Record.Model.Field("Size"),
    PARENT_ID: new ZCRM.Record.Model.Field("Parent_Id"),
    ID: new ZCRM.Record.Model.Field("id"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
  }),
  (ZCRM.Record.Model.Field.Purchase_Orders = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    DISCOUNT: new ZCRM.Record.Model.Field("Discount"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    VENDOR_NAME: new ZCRM.Record.Model.Field("Vendor_Name"),
    SHIPPING_STATE: new ZCRM.Record.Model.Field("Shipping_State"),
    TAX: new ZCRM.Record.Model.Field("Tax"),
    PO_DATE: new ZCRM.Record.Model.Field("PO_Date"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    BILLING_COUNTRY: new ZCRM.Record.Model.Field("Billing_Country"),
    ID: new ZCRM.Record.Model.Field("id"),
    CARRIER: new ZCRM.Record.Model.Field("Carrier"),
    STATUS: new ZCRM.Record.Model.Field("Status"),
    GRAND_TOTAL: new ZCRM.Record.Model.Field("Grand_Total"),
    SALES_COMMISSION: new ZCRM.Record.Model.Field("Sales_Commission"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    PO_NUMBER: new ZCRM.Record.Model.Field("PO_Number"),
    DUE_DATE: new ZCRM.Record.Model.Field("Due_Date"),
    BILLING_STREET: new ZCRM.Record.Model.Field("Billing_Street"),
    ADJUSTMENT: new ZCRM.Record.Model.Field("Adjustment"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    TERMS_AND_CONDITIONS: new ZCRM.Record.Model.Field("Terms_and_Conditions"),
    SUB_TOTAL: new ZCRM.Record.Model.Field("Sub_Total"),
    BILLING_CODE: new ZCRM.Record.Model.Field("Billing_Code"),
    PRODUCT_DETAILS: new ZCRM.Record.Model.Field("Product_Details"),
    SUBJECT: new ZCRM.Record.Model.Field("Subject"),
    TRACKING_NUMBER: new ZCRM.Record.Model.Field("Tracking_Number"),
    CONTACT_NAME: new ZCRM.Record.Model.Field("Contact_Name"),
    EXCISE_DUTY: new ZCRM.Record.Model.Field("Excise_Duty"),
    SHIPPING_CITY: new ZCRM.Record.Model.Field("Shipping_City"),
    SHIPPING_COUNTRY: new ZCRM.Record.Model.Field("Shipping_Country"),
    SHIPPING_CODE: new ZCRM.Record.Model.Field("Shipping_Code"),
    BILLING_CITY: new ZCRM.Record.Model.Field("Billing_City"),
    REQUISITION_NO: new ZCRM.Record.Model.Field("Requisition_No"),
    BILLING_STATE: new ZCRM.Record.Model.Field("Billing_State"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    SHIPPING_STREET: new ZCRM.Record.Model.Field("Shipping_Street"),
  }),
  (ZCRM.Record.Model.Field.Vendors = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    EMAIL: new ZCRM.Record.Model.Field("Email"),
    CATEGORY: new ZCRM.Record.Model.Field("Category"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    VENDOR_NAME: new ZCRM.Record.Model.Field("Vendor_Name"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    WEBSITE: new ZCRM.Record.Model.Field("Website"),
    CITY: new ZCRM.Record.Model.Field("City"),
    RECORD_IMAGE: new ZCRM.Record.Model.Field("Record_Image"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    PHONE: new ZCRM.Record.Model.Field("Phone"),
    STATE: new ZCRM.Record.Model.Field("State"),
    GL_ACCOUNT: new ZCRM.Record.Model.Field("GL_Account"),
    STREET: new ZCRM.Record.Model.Field("Street"),
    COUNTRY: new ZCRM.Record.Model.Field("Country"),
    ZIP_CODE: new ZCRM.Record.Model.Field("Zip_Code"),
    ID: new ZCRM.Record.Model.Field("id"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
  }),
  (ZCRM.Record.Model.Field.Campaigns = {
    STATUS: new ZCRM.Record.Model.Field("Status"),
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    CAMPAIGN_NAME: new ZCRM.Record.Model.Field("Campaign_Name"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    END_DATE: new ZCRM.Record.Model.Field("End_Date"),
    TYPE: new ZCRM.Record.Model.Field("Type"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    NUM_SENT: new ZCRM.Record.Model.Field("Num_sent"),
    EXPECTED_REVENUE: new ZCRM.Record.Model.Field("Expected_Revenue"),
    ACTUAL_COST: new ZCRM.Record.Model.Field("Actual_Cost"),
    ID: new ZCRM.Record.Model.Field("id"),
    EXPECTED_RESPONSE: new ZCRM.Record.Model.Field("Expected_Response"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    PARENT_CAMPAIGN: new ZCRM.Record.Model.Field("Parent_Campaign"),
    START_DATE: new ZCRM.Record.Model.Field("Start_Date"),
    BUDGETED_COST: new ZCRM.Record.Model.Field("Budgeted_Cost"),
  }),
  (ZCRM.Record.Model.Field.Solutions = {
    STATUS: new ZCRM.Record.Model.Field("Status"),
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    COMMENTS: new ZCRM.Record.Model.Field("Comments"),
    NO_OF_COMMENTS: new ZCRM.Record.Model.Field("No_of_comments"),
    PRODUCT_NAME: new ZCRM.Record.Model.Field("Product_Name"),
    ADD_COMMENT: new ZCRM.Record.Model.Field("Add_Comment"),
    SOLUTION_NUMBER: new ZCRM.Record.Model.Field("Solution_Number"),
    ANSWER: new ZCRM.Record.Model.Field("Answer"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    SOLUTION_TITLE: new ZCRM.Record.Model.Field("Solution_Title"),
    PUBLISHED: new ZCRM.Record.Model.Field("Published"),
    QUESTION: new ZCRM.Record.Model.Field("Question"),
    ID: new ZCRM.Record.Model.Field("id"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
  }),
  (ZCRM.Record.Model.Field.Leads = {
    OWNER: new ZCRM.Record.Model.Field("Owner"),
    COMPANY: new ZCRM.Record.Model.Field("Company"),
    EMAIL: new ZCRM.Record.Model.Field("Email"),
    DESCRIPTION: new ZCRM.Record.Model.Field("Description"),
    RATING: new ZCRM.Record.Model.Field("Rating"),
    WEBSITE: new ZCRM.Record.Model.Field("Website"),
    TWITTER: new ZCRM.Record.Model.Field("Twitter"),
    SALUTATION: new ZCRM.Record.Model.Field("Salutation"),
    LAST_ACTIVITY_TIME: new ZCRM.Record.Model.Field("Last_Activity_Time"),
    FIRST_NAME: new ZCRM.Record.Model.Field("First_Name"),
    FULL_NAME: new ZCRM.Record.Model.Field("Full_Name"),
    LEAD_STATUS: new ZCRM.Record.Model.Field("Lead_Status"),
    INDUSTRY: new ZCRM.Record.Model.Field("Industry"),
    RECORD_IMAGE: new ZCRM.Record.Model.Field("Record_Image"),
    MODIFIED_BY: new ZCRM.Record.Model.Field("Modified_By"),
    SKYPE_ID: new ZCRM.Record.Model.Field("Skype_ID"),
    PHONE: new ZCRM.Record.Model.Field("Phone"),
    STREET: new ZCRM.Record.Model.Field("Street"),
    ZIP_CODE: new ZCRM.Record.Model.Field("Zip_Code"),
    ID: new ZCRM.Record.Model.Field("id"),
    EMAIL_OPT_OUT: new ZCRM.Record.Model.Field("Email_Opt_Out"),
    DESIGNATION: new ZCRM.Record.Model.Field("Designation"),
    MODIFIED_TIME: new ZCRM.Record.Model.Field("Modified_Time"),
    CREATED_TIME: new ZCRM.Record.Model.Field("Created_Time"),
    CITY: new ZCRM.Record.Model.Field("City"),
    NO_OF_EMPLOYEES: new ZCRM.Record.Model.Field("No_of_Employees"),
    MOBILE: new ZCRM.Record.Model.Field("Mobile"),
    CONVERTED_DATE_TIME: new ZCRM.Record.Model.Field("Converted_Date_Time"),
    LAST_NAME: new ZCRM.Record.Model.Field("Last_Name"),
    LAYOUT: new ZCRM.Record.Model.Field("Layout"),
    STATE: new ZCRM.Record.Model.Field("State"),
    LEAD_SOURCE: new ZCRM.Record.Model.Field("Lead_Source"),
    IS_RECORD_DUPLICATE: new ZCRM.Record.Model.Field("Is_Record_Duplicate"),
    TAG: new ZCRM.Record.Model.Field("Tag"),
    CREATED_BY: new ZCRM.Record.Model.Field("Created_By"),
    FAX: new ZCRM.Record.Model.Field("Fax"),
    ANNUAL_REVENUE: new ZCRM.Record.Model.Field("Annual_Revenue"),
    SECONDARY_EMAIL: new ZCRM.Record.Model.Field("Secondary_Email"),
  });
class InitializeBuilder {
  constructor() {
    (this._environment = null),
      (this._token = null),
      (this._requestProxy = null),
      (this._sdkConfig = null),
      (this._logger = null),
      (this.errorMessage = null),
      (this.initializer = null);
  }
  initialize() {
    Utility.assertNotNull(
      this._environment,
      this.errorMessage,
      Constants.ENVIRONMENT_ERROR_MESSAGE
    ),
      null == this._sdkConfig &&
        (this._sdkConfig = new SDKConfigBuilder()
          .autoRefreshFields(!0)
          .pickListValidation(!1)
          .build()),
      null == this._logger && (this._logger = Logger.getInstance(Levels.INFO)),
      initializeSDK(
        this._environment,
        this._sdkConfig,
        this._token,
        this._logger,
        this._requestProxy
      );
  }
  logger(logger) {
    return (this._logger = logger), this;
  }
  token(token) {
    if (
      (Utility.assertNotNull(
        token,
        this.errorMessage,
        Constants.TOKEN_ERROR_MESSAGE
      ),
      !(token instanceof Token) &&
        null === document.getElementById(Constants.ZES_CLIENT_SCOPE))
    )
      throw (
        ((detailsJO.field = Constants.TOKEN),
        (detailsJO.expected_type = Token.name),
        new SDKException(Constants.INITIALIZATION_ERROR, null, detailsJO, null))
      );
    return (this._token = token), this;
  }
  SDKConfig(sdkConfig) {
    if (
      (Utility.assertNotNull(
        sdkConfig,
        this.errorMessage,
        Constants.SDK_CONFIG_ERROR_MESSAGE
      ),
      !(sdkConfig instanceof SDKConfig))
    )
      throw (
        ((detailsJO.field = Constants.SDK_CONFIG),
        (detailsJO.expected_type = SDKConfig.name),
        new SDKException(
          Constants.INITIALIZATION_ERROR,
          Constants.INITIALIZATION_EXCEPTION,
          error
        ))
      );
    return (this._sdkConfig = sdkConfig), this;
  }
  requestProxy(requestProxy) {
    if (null != proxy && !(proxy instanceof RequestProxy))
      throw (
        ((detailsJO.field = Constants.USER_PROXY),
        (detailsJO.expected_type = RequestProxy.name),
        new SDKException(Constants.INITIALIZATION_ERROR, null, detailsJO, null))
      );
    return (this._requestProxy = requestProxy), this;
  }
  environment(environment) {
    if (
      (Utility.assertNotNull(
        environment,
        this.errorMessage,
        Constants.ENVIRONMENT_ERROR_MESSAGE
      ),
      !(environment instanceof Environment))
    )
      throw (
        ((detailsJO.field = Constants.ENVIRONMENT),
        (detailsJO.expected_type = Environment.name),
        new SDKException(Constants.INITIALIZATION_ERROR, null, detailsJO, null))
      );
    return (this._environment = environment), this;
  }
}
(ZCRM.File = {
  Model: {
    ResponseHandler: class {
      constructor() {}
    },
    ActionHandler: class {
      constructor() {}
    },
    ActionResponse: class {
      constructor() {}
    },
    BodyWrapper: class {
      constructor() {
        (this.file = null), (this.keyModified = new Map());
      }
      getFile() {
        return this.file;
      }
      setFile(file) {
        if (
          null != file &&
          "[object Array]" != Object.prototype.toString.call(file)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: file EXPECTED TYPE: Array",
            null,
            null
          );
        (this.file = file), this.keyModified.set("file", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    SuccessResponse: class {
      constructor() {
        (this.status = null),
          (this.code = null),
          (this.message = null),
          (this.details = null),
          (this.keyModified = new Map());
      }
      getStatus() {
        return this.status;
      }
      setStatus(status) {
        if (null != status && !(status instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: status EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.status = status), this.keyModified.set("status", 1);
      }
      getCode() {
        return this.code;
      }
      setCode(code) {
        if (null != code && !(code instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: code EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.code = code), this.keyModified.set("code", 1);
      }
      getMessage() {
        return this.message;
      }
      setMessage(message) {
        if (null != message && !(message instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: message EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.message = message), this.keyModified.set("message", 1);
      }
      getDetails() {
        return this.details;
      }
      setDetails(details) {
        if (
          null != details &&
          "[object Map]" != Object.prototype.toString.call(details)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: details EXPECTED TYPE: Map",
            null,
            null
          );
        (this.details = details), this.keyModified.set("details", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    ActionWrapper: class {
      constructor() {
        (this.data = null), (this.keyModified = new Map());
      }
      getData() {
        return this.data;
      }
      setData(data) {
        if (
          null != data &&
          "[object Array]" != Object.prototype.toString.call(data)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: data EXPECTED TYPE: Array",
            null,
            null
          );
        (this.data = data), this.keyModified.set("data", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    APIException: class {
      constructor() {
        (this.status = null),
          (this.code = null),
          (this.message = null),
          (this.details = null),
          (this.keyModified = new Map());
      }
      getStatus() {
        return this.status;
      }
      setStatus(status) {
        if (null != status && !(status instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: status EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.status = status), this.keyModified.set("status", 1);
      }
      getCode() {
        return this.code;
      }
      setCode(code) {
        if (null != code && !(code instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: code EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.code = code), this.keyModified.set("code", 1);
      }
      getMessage() {
        return this.message;
      }
      setMessage(message) {
        if (null != message && !(message instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: message EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.message = message), this.keyModified.set("message", 1);
      }
      getDetails() {
        return this.details;
      }
      setDetails(details) {
        if (
          null != details &&
          "[object Map]" != Object.prototype.toString.call(details)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: details EXPECTED TYPE: Map",
            null,
            null
          );
        (this.details = details), this.keyModified.set("details", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    FileBodyWrapper: class {
      constructor() {
        (this.file = null), (this.keyModified = new Map());
      }
      getFile() {
        return this.file;
      }
      setFile(file) {
        if (
          null != file &&
          !(file instanceof StreamWrapper.Model.StreamWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: file EXPECTED TYPE: StreamWrapper",
            null,
            null
          );
        (this.file = file), this.keyModified.set("file", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    GetFileParam: { ID: new Param("id", "File.Model.GetFileParam") },
    UploadFilesParam: {
      TYPE: new Param("type", "File.Model.UploadFilesParam"),
    },
  },
  Operations: class {
    constructor() {}
    async uploadFiles(request, paramInstance = null) {
      if (null != request && !(request instanceof ZCRM.File.Model.BodyWrapper))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: request EXPECTED TYPE: BodyWrapper",
          null,
          null
        );
      if (null != paramInstance && !(paramInstance instanceof ParameterMap))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: paramInstance EXPECTED TYPE: ParameterMap",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/files")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
        handlerInstance.setContentType("multipart/form-data"),
        handlerInstance.setRequest(request),
        handlerInstance.setMandatoryChecker(!0),
        handlerInstance.setParam(paramInstance),
        handlerInstance.apiCall("File.Model.ActionHandler", "application/json")
      );
    }
    async getFile(paramInstance = null) {
      if (null != paramInstance && !(paramInstance instanceof ParameterMap))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: paramInstance EXPECTED TYPE: ParameterMap",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/files")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
        handlerInstance.setParam(paramInstance),
        handlerInstance.apiCall(
          "File.Model.ResponseHandler",
          "application/x-download"
        )
      );
    }
  },
}),
  (ZCRM.RelatedList = {
    Model: {
      ResponseHandler: class {
        constructor() {}
      },
      ResponseWrapper: class {
        constructor() {
          (this.relatedLists = null), (this.keyModified = new Map());
        }
        getRelatedLists() {
          return this.relatedLists;
        }
        setRelatedLists(relatedLists) {
          if (
            null != relatedLists &&
            "[object Array]" != Object.prototype.toString.call(relatedLists)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: relatedLists EXPECTED TYPE: Array",
              null,
              null
            );
          (this.relatedLists = relatedLists),
            this.keyModified.set("related_lists", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RelatedList: class {
        constructor() {
          (this.id = null),
            (this.sequenceNumber = null),
            (this.displayLabel = null),
            (this.apiName = null),
            (this.module = null),
            (this.name = null),
            (this.action = null),
            (this.href = null),
            (this.type = null),
            (this.connectedmodule = null),
            (this.linkingmodule = null),
            (this.keyModified = new Map());
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getSequenceNumber() {
          return this.sequenceNumber;
        }
        setSequenceNumber(sequenceNumber) {
          if (
            null != sequenceNumber &&
            "[object String]" != Object.prototype.toString.call(sequenceNumber)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sequenceNumber EXPECTED TYPE: String",
              null,
              null
            );
          (this.sequenceNumber = sequenceNumber),
            this.keyModified.set("sequence_number", 1);
        }
        getDisplayLabel() {
          return this.displayLabel;
        }
        setDisplayLabel(displayLabel) {
          if (
            null != displayLabel &&
            "[object String]" != Object.prototype.toString.call(displayLabel)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: displayLabel EXPECTED TYPE: String",
              null,
              null
            );
          (this.displayLabel = displayLabel),
            this.keyModified.set("display_label", 1);
        }
        getAPIName() {
          return this.apiName;
        }
        setAPIName(apiName) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          (this.apiName = apiName), this.keyModified.set("api_name", 1);
        }
        getModule() {
          return this.module;
        }
        setModule(module) {
          if (
            null != module &&
            "[object String]" != Object.prototype.toString.call(module)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: module EXPECTED TYPE: String",
              null,
              null
            );
          (this.module = module), this.keyModified.set("module", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getAction() {
          return this.action;
        }
        setAction(action) {
          if (
            null != action &&
            "[object String]" != Object.prototype.toString.call(action)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: action EXPECTED TYPE: String",
              null,
              null
            );
          (this.action = action), this.keyModified.set("action", 1);
        }
        getHref() {
          return this.href;
        }
        setHref(href) {
          if (
            null != href &&
            "[object String]" != Object.prototype.toString.call(href)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: href EXPECTED TYPE: String",
              null,
              null
            );
          (this.href = href), this.keyModified.set("href", 1);
        }
        getType() {
          return this.type;
        }
        setType(type) {
          if (
            null != type &&
            "[object String]" != Object.prototype.toString.call(type)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: type EXPECTED TYPE: String",
              null,
              null
            );
          (this.type = type), this.keyModified.set("type", 1);
        }
        getConnectedmodule() {
          return this.connectedmodule;
        }
        setConnectedmodule(connectedmodule) {
          if (
            null != connectedmodule &&
            "[object String]" != Object.prototype.toString.call(connectedmodule)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: connectedmodule EXPECTED TYPE: String",
              null,
              null
            );
          (this.connectedmodule = connectedmodule),
            this.keyModified.set("connectedmodule", 1);
        }
        getLinkingmodule() {
          return this.linkingmodule;
        }
        setLinkingmodule(linkingmodule) {
          if (
            null != linkingmodule &&
            "[object String]" != Object.prototype.toString.call(linkingmodule)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: linkingmodule EXPECTED TYPE: String",
              null,
              null
            );
          (this.linkingmodule = linkingmodule),
            this.keyModified.set("linkingmodule", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      GetRelatedListsParam: {},
      GetRelatedListParam: {},
    },
    Operations: class {
      constructor(module = null) {
        if (
          null != module &&
          "[object String]" != Object.prototype.toString.call(module)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: module EXPECTED TYPE: String",
            null,
            null
          );
        this.module = module;
      }
      async getRelatedLists() {
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/related_lists")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addParam(
            new Param("module", "RelatedList.Model.GetRelatedListsParam"),
            this.module
          ),
          handlerInstance.apiCall(
            "RelatedList.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async getRelatedList(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/related_lists/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addParam(
            new Param("module", "RelatedList.Model.GetRelatedListParam"),
            this.module
          ),
          handlerInstance.apiCall(
            "RelatedList.Model.ResponseHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.Notification = {
    Model: {
      ActionHandler: class {
        constructor() {}
      },
      ActionResponse: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Info: class {
        constructor() {
          (this.perPage = null),
            (this.count = null),
            (this.page = null),
            (this.moreRecords = null),
            (this.keyModified = new Map());
        }
        getPerPage() {
          return this.perPage;
        }
        setPerPage(perPage) {
          if (
            null != perPage &&
            "[object Number]" != Object.prototype.toString.call(perPage)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: perPage EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.perPage = perPage), this.keyModified.set("per_page", 1);
        }
        getCount() {
          return this.count;
        }
        setCount(count) {
          if (
            null != count &&
            "[object Number]" != Object.prototype.toString.call(count)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: count EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.count = count), this.keyModified.set("count", 1);
        }
        getPage() {
          return this.page;
        }
        setPage(page) {
          if (
            null != page &&
            "[object Number]" != Object.prototype.toString.call(page)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: page EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.page = page), this.keyModified.set("page", 1);
        }
        getMoreRecords() {
          return this.moreRecords;
        }
        setMoreRecords(moreRecords) {
          if (
            null != moreRecords &&
            "[object Boolean]" != Object.prototype.toString.call(moreRecords)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: moreRecords EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.moreRecords = moreRecords),
            this.keyModified.set("more_records", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.watch = null), (this.keyModified = new Map());
        }
        getWatch() {
          return this.watch;
        }
        setWatch(watch) {
          if (
            null != watch &&
            "[object Array]" != Object.prototype.toString.call(watch)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: watch EXPECTED TYPE: Array",
              null,
              null
            );
          (this.watch = watch), this.keyModified.set("watch", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ActionWrapper: class {
        constructor() {
          (this.watch = null), (this.keyModified = new Map());
        }
        getWatch() {
          return this.watch;
        }
        setWatch(watch) {
          if (
            null != watch &&
            "[object Array]" != Object.prototype.toString.call(watch)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: watch EXPECTED TYPE: Array",
              null,
              null
            );
          (this.watch = watch), this.keyModified.set("watch", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.watch = null),
            (this.info = null),
            (this.keyModified = new Map());
        }
        getWatch() {
          return this.watch;
        }
        setWatch(watch) {
          if (
            null != watch &&
            "[object Array]" != Object.prototype.toString.call(watch)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: watch EXPECTED TYPE: Array",
              null,
              null
            );
          (this.watch = watch), this.keyModified.set("watch", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (null != info && !(info instanceof ZCRM.Notification.Model.Info))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Info",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Notification: class {
        constructor() {
          (this.channelExpiry = null),
            (this.resourceUri = null),
            (this.resourceId = null),
            (this.notifyUrl = null),
            (this.resourceName = null),
            (this.channelId = null),
            (this.events = null),
            (this.token = null),
            (this.notifyOnRelatedAction = null),
            (this.fields = null),
            (this.deleteevents = null),
            (this.keyModified = new Map());
        }
        getChannelExpiry() {
          return this.channelExpiry;
        }
        setChannelExpiry(channelExpiry) {
          if (null != channelExpiry && !(channelExpiry instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: channelExpiry EXPECTED TYPE: Date",
              null,
              null
            );
          (this.channelExpiry = channelExpiry),
            this.keyModified.set("channel_expiry", 1);
        }
        getResourceUri() {
          return this.resourceUri;
        }
        setResourceUri(resourceUri) {
          if (
            null != resourceUri &&
            "[object String]" != Object.prototype.toString.call(resourceUri)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: resourceUri EXPECTED TYPE: String",
              null,
              null
            );
          (this.resourceUri = resourceUri),
            this.keyModified.set("resource_uri", 1);
        }
        getResourceId() {
          return this.resourceId;
        }
        setResourceId(resourceId) {
          if (
            null != resourceId &&
            "[object String]" != Object.prototype.toString.call(resourceId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: resourceId EXPECTED TYPE: String",
              null,
              null
            );
          (this.resourceId = resourceId),
            this.keyModified.set("resource_id", 1);
        }
        getNotifyUrl() {
          return this.notifyUrl;
        }
        setNotifyUrl(notifyUrl) {
          if (
            null != notifyUrl &&
            "[object String]" != Object.prototype.toString.call(notifyUrl)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: notifyUrl EXPECTED TYPE: String",
              null,
              null
            );
          (this.notifyUrl = notifyUrl), this.keyModified.set("notify_url", 1);
        }
        getResourceName() {
          return this.resourceName;
        }
        setResourceName(resourceName) {
          if (
            null != resourceName &&
            "[object String]" != Object.prototype.toString.call(resourceName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: resourceName EXPECTED TYPE: String",
              null,
              null
            );
          (this.resourceName = resourceName),
            this.keyModified.set("resource_name", 1);
        }
        getChannelId() {
          return this.channelId;
        }
        setChannelId(channelId) {
          if (
            null != channelId &&
            "[object BigInt]" != Object.prototype.toString.call(channelId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: channelId EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.channelId = channelId), this.keyModified.set("channel_id", 1);
        }
        getEvents() {
          return this.events;
        }
        setEvents(events) {
          if (
            null != events &&
            "[object Array]" != Object.prototype.toString.call(events)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: events EXPECTED TYPE: Array",
              null,
              null
            );
          (this.events = events), this.keyModified.set("events", 1);
        }
        getToken() {
          return this.token;
        }
        setToken(token) {
          if (
            null != token &&
            "[object String]" != Object.prototype.toString.call(token)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: token EXPECTED TYPE: String",
              null,
              null
            );
          (this.token = token), this.keyModified.set("token", 1);
        }
        getNotifyOnRelatedAction() {
          return this.notifyOnRelatedAction;
        }
        setNotifyOnRelatedAction(notifyOnRelatedAction) {
          if (
            null != notifyOnRelatedAction &&
            "[object Boolean]" !=
              Object.prototype.toString.call(notifyOnRelatedAction)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: notifyOnRelatedAction EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.notifyOnRelatedAction = notifyOnRelatedAction),
            this.keyModified.set("notify_on_related_action", 1);
        }
        getFields() {
          return this.fields;
        }
        setFields(fields) {
          if (
            null != fields &&
            "[object Map]" != Object.prototype.toString.call(fields)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fields EXPECTED TYPE: Map",
              null,
              null
            );
          (this.fields = fields), this.keyModified.set("fields", 1);
        }
        getDeleteevents() {
          return this.deleteevents;
        }
        setDeleteevents(deleteevents) {
          if (
            null != deleteevents &&
            "[object Boolean]" != Object.prototype.toString.call(deleteevents)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: deleteevents EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.deleteevents = deleteevents),
            this.keyModified.set("_delete_events", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      GetNotificationDetailsParam: {
        PAGE: new Param(
          "page",
          "Notification.Model.GetNotificationDetailsParam"
        ),
        PER_PAGE: new Param(
          "per_page",
          "Notification.Model.GetNotificationDetailsParam"
        ),
        CHANNEL_ID: new Param(
          "channel_id",
          "Notification.Model.GetNotificationDetailsParam"
        ),
        MODULE: new Param(
          "module",
          "Notification.Model.GetNotificationDetailsParam"
        ),
      },
      DisableNotificationsParam: {
        CHANNEL_IDS: new Param(
          "channel_ids",
          "Notification.Model.DisableNotificationsParam"
        ),
      },
    },
    Operations: class {
      constructor() {}
      async enableNotifications(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.Notification.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/actions/watch")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "Notification.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getNotificationDetails(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/actions/watch")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Notification.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateNotifications(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.Notification.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/actions/watch")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "Notification.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async updateNotification(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.Notification.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/actions/watch")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PATCH),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "Notification.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async disableNotifications(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/actions/watch")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Notification.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async disableNotification(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.Notification.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/actions/watch")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PATCH),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "Notification.Model.ActionHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.Org = {
    Model: {
      ActionResponse: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.org = null), (this.keyModified = new Map());
        }
        getOrg() {
          return this.org;
        }
        setOrg(org) {
          if (
            null != org &&
            "[object Array]" != Object.prototype.toString.call(org)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: org EXPECTED TYPE: Array",
              null,
              null
            );
          (this.org = org), this.keyModified.set("org", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Org: class {
        constructor() {
          (this.country = null),
            (this.photoId = null),
            (this.city = null),
            (this.description = null),
            (this.mcStatus = null),
            (this.gappsEnabled = null),
            (this.domainName = null),
            (this.translationEnabled = null),
            (this.street = null),
            (this.alias = null),
            (this.currency = null),
            (this.id = null),
            (this.state = null),
            (this.fax = null),
            (this.employeeCount = null),
            (this.zip = null),
            (this.website = null),
            (this.currencySymbol = null),
            (this.mobile = null),
            (this.currencyLocale = null),
            (this.primaryZuid = null),
            (this.ziaPortalId = null),
            (this.timeZone = null),
            (this.zgid = null),
            (this.countryCode = null),
            (this.licenseDetails = null),
            (this.phone = null),
            (this.companyName = null),
            (this.privacySettings = null),
            (this.primaryEmail = null),
            (this.isoCode = null),
            (this.keyModified = new Map());
        }
        getCountry() {
          return this.country;
        }
        setCountry(country) {
          if (
            null != country &&
            "[object String]" != Object.prototype.toString.call(country)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: country EXPECTED TYPE: String",
              null,
              null
            );
          (this.country = country), this.keyModified.set("country", 1);
        }
        getPhotoId() {
          return this.photoId;
        }
        setPhotoId(photoId) {
          if (
            null != photoId &&
            "[object String]" != Object.prototype.toString.call(photoId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: photoId EXPECTED TYPE: String",
              null,
              null
            );
          (this.photoId = photoId), this.keyModified.set("photo_id", 1);
        }
        getCity() {
          return this.city;
        }
        setCity(city) {
          if (
            null != city &&
            "[object String]" != Object.prototype.toString.call(city)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: city EXPECTED TYPE: String",
              null,
              null
            );
          (this.city = city), this.keyModified.set("city", 1);
        }
        getDescription() {
          return this.description;
        }
        setDescription(description) {
          if (
            null != description &&
            "[object String]" != Object.prototype.toString.call(description)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: description EXPECTED TYPE: String",
              null,
              null
            );
          (this.description = description),
            this.keyModified.set("description", 1);
        }
        getMcStatus() {
          return this.mcStatus;
        }
        setMcStatus(mcStatus) {
          if (
            null != mcStatus &&
            "[object Boolean]" != Object.prototype.toString.call(mcStatus)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: mcStatus EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.mcStatus = mcStatus), this.keyModified.set("mc_status", 1);
        }
        getGappsEnabled() {
          return this.gappsEnabled;
        }
        setGappsEnabled(gappsEnabled) {
          if (
            null != gappsEnabled &&
            "[object Boolean]" != Object.prototype.toString.call(gappsEnabled)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: gappsEnabled EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.gappsEnabled = gappsEnabled),
            this.keyModified.set("gapps_enabled", 1);
        }
        getDomainName() {
          return this.domainName;
        }
        setDomainName(domainName) {
          if (
            null != domainName &&
            "[object String]" != Object.prototype.toString.call(domainName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: domainName EXPECTED TYPE: String",
              null,
              null
            );
          (this.domainName = domainName),
            this.keyModified.set("domain_name", 1);
        }
        getTranslationEnabled() {
          return this.translationEnabled;
        }
        setTranslationEnabled(translationEnabled) {
          if (
            null != translationEnabled &&
            "[object Boolean]" !=
              Object.prototype.toString.call(translationEnabled)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: translationEnabled EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.translationEnabled = translationEnabled),
            this.keyModified.set("translation_enabled", 1);
        }
        getStreet() {
          return this.street;
        }
        setStreet(street) {
          if (
            null != street &&
            "[object String]" != Object.prototype.toString.call(street)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: street EXPECTED TYPE: String",
              null,
              null
            );
          (this.street = street), this.keyModified.set("street", 1);
        }
        getAlias() {
          return this.alias;
        }
        setAlias(alias) {
          if (
            null != alias &&
            "[object String]" != Object.prototype.toString.call(alias)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: alias EXPECTED TYPE: String",
              null,
              null
            );
          (this.alias = alias), this.keyModified.set("alias", 1);
        }
        getCurrency() {
          return this.currency;
        }
        setCurrency(currency) {
          if (
            null != currency &&
            "[object String]" != Object.prototype.toString.call(currency)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: currency EXPECTED TYPE: String",
              null,
              null
            );
          (this.currency = currency), this.keyModified.set("currency", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getState() {
          return this.state;
        }
        setState(state) {
          if (
            null != state &&
            "[object String]" != Object.prototype.toString.call(state)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: state EXPECTED TYPE: String",
              null,
              null
            );
          (this.state = state), this.keyModified.set("state", 1);
        }
        getFax() {
          return this.fax;
        }
        setFax(fax) {
          if (
            null != fax &&
            "[object String]" != Object.prototype.toString.call(fax)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fax EXPECTED TYPE: String",
              null,
              null
            );
          (this.fax = fax), this.keyModified.set("fax", 1);
        }
        getEmployeeCount() {
          return this.employeeCount;
        }
        setEmployeeCount(employeeCount) {
          if (
            null != employeeCount &&
            "[object String]" != Object.prototype.toString.call(employeeCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: employeeCount EXPECTED TYPE: String",
              null,
              null
            );
          (this.employeeCount = employeeCount),
            this.keyModified.set("employee_count", 1);
        }
        getZip() {
          return this.zip;
        }
        setZip(zip) {
          if (
            null != zip &&
            "[object String]" != Object.prototype.toString.call(zip)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: zip EXPECTED TYPE: String",
              null,
              null
            );
          (this.zip = zip), this.keyModified.set("zip", 1);
        }
        getWebsite() {
          return this.website;
        }
        setWebsite(website) {
          if (
            null != website &&
            "[object String]" != Object.prototype.toString.call(website)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: website EXPECTED TYPE: String",
              null,
              null
            );
          (this.website = website), this.keyModified.set("website", 1);
        }
        getCurrencySymbol() {
          return this.currencySymbol;
        }
        setCurrencySymbol(currencySymbol) {
          if (
            null != currencySymbol &&
            "[object String]" != Object.prototype.toString.call(currencySymbol)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: currencySymbol EXPECTED TYPE: String",
              null,
              null
            );
          (this.currencySymbol = currencySymbol),
            this.keyModified.set("currency_symbol", 1);
        }
        getMobile() {
          return this.mobile;
        }
        setMobile(mobile) {
          if (
            null != mobile &&
            "[object String]" != Object.prototype.toString.call(mobile)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: mobile EXPECTED TYPE: String",
              null,
              null
            );
          (this.mobile = mobile), this.keyModified.set("mobile", 1);
        }
        getCurrencyLocale() {
          return this.currencyLocale;
        }
        setCurrencyLocale(currencyLocale) {
          if (
            null != currencyLocale &&
            "[object String]" != Object.prototype.toString.call(currencyLocale)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: currencyLocale EXPECTED TYPE: String",
              null,
              null
            );
          (this.currencyLocale = currencyLocale),
            this.keyModified.set("currency_locale", 1);
        }
        getPrimaryZuid() {
          return this.primaryZuid;
        }
        setPrimaryZuid(primaryZuid) {
          if (
            null != primaryZuid &&
            "[object String]" != Object.prototype.toString.call(primaryZuid)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: primaryZuid EXPECTED TYPE: String",
              null,
              null
            );
          (this.primaryZuid = primaryZuid),
            this.keyModified.set("primary_zuid", 1);
        }
        getZiaPortalId() {
          return this.ziaPortalId;
        }
        setZiaPortalId(ziaPortalId) {
          if (
            null != ziaPortalId &&
            "[object String]" != Object.prototype.toString.call(ziaPortalId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: ziaPortalId EXPECTED TYPE: String",
              null,
              null
            );
          (this.ziaPortalId = ziaPortalId),
            this.keyModified.set("zia_portal_id", 1);
        }
        getTimeZone() {
          return this.timeZone;
        }
        setTimeZone(timeZone) {
          if (
            null != timeZone &&
            "[object String]" != Object.prototype.toString.call(timeZone)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: timeZone EXPECTED TYPE: String",
              null,
              null
            );
          (this.timeZone = timeZone), this.keyModified.set("time_zone", 1);
        }
        getZgid() {
          return this.zgid;
        }
        setZgid(zgid) {
          if (
            null != zgid &&
            "[object String]" != Object.prototype.toString.call(zgid)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: zgid EXPECTED TYPE: String",
              null,
              null
            );
          (this.zgid = zgid), this.keyModified.set("zgid", 1);
        }
        getCountryCode() {
          return this.countryCode;
        }
        setCountryCode(countryCode) {
          if (
            null != countryCode &&
            "[object String]" != Object.prototype.toString.call(countryCode)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: countryCode EXPECTED TYPE: String",
              null,
              null
            );
          (this.countryCode = countryCode),
            this.keyModified.set("country_code", 1);
        }
        getLicenseDetails() {
          return this.licenseDetails;
        }
        setLicenseDetails(licenseDetails) {
          if (
            null != licenseDetails &&
            !(licenseDetails instanceof ZCRM.Org.Model.LicenseDetails)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: licenseDetails EXPECTED TYPE: LicenseDetails",
              null,
              null
            );
          (this.licenseDetails = licenseDetails),
            this.keyModified.set("license_details", 1);
        }
        getPhone() {
          return this.phone;
        }
        setPhone(phone) {
          if (
            null != phone &&
            "[object String]" != Object.prototype.toString.call(phone)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: phone EXPECTED TYPE: String",
              null,
              null
            );
          (this.phone = phone), this.keyModified.set("phone", 1);
        }
        getCompanyName() {
          return this.companyName;
        }
        setCompanyName(companyName) {
          if (
            null != companyName &&
            "[object String]" != Object.prototype.toString.call(companyName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: companyName EXPECTED TYPE: String",
              null,
              null
            );
          (this.companyName = companyName),
            this.keyModified.set("company_name", 1);
        }
        getPrivacySettings() {
          return this.privacySettings;
        }
        setPrivacySettings(privacySettings) {
          if (
            null != privacySettings &&
            "[object Boolean]" !=
              Object.prototype.toString.call(privacySettings)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: privacySettings EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.privacySettings = privacySettings),
            this.keyModified.set("privacy_settings", 1);
        }
        getPrimaryEmail() {
          return this.primaryEmail;
        }
        setPrimaryEmail(primaryEmail) {
          if (
            null != primaryEmail &&
            "[object String]" != Object.prototype.toString.call(primaryEmail)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: primaryEmail EXPECTED TYPE: String",
              null,
              null
            );
          (this.primaryEmail = primaryEmail),
            this.keyModified.set("primary_email", 1);
        }
        getIsoCode() {
          return this.isoCode;
        }
        setIsoCode(isoCode) {
          if (
            null != isoCode &&
            "[object String]" != Object.prototype.toString.call(isoCode)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: isoCode EXPECTED TYPE: String",
              null,
              null
            );
          (this.isoCode = isoCode), this.keyModified.set("iso_code", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      LicenseDetails: class {
        constructor() {
          (this.paidExpiry = null),
            (this.usersLicensePurchased = null),
            (this.trialType = null),
            (this.trialExpiry = null),
            (this.paid = null),
            (this.paidType = null),
            (this.keyModified = new Map());
        }
        getPaidExpiry() {
          return this.paidExpiry;
        }
        setPaidExpiry(paidExpiry) {
          if (null != paidExpiry && !(paidExpiry instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: paidExpiry EXPECTED TYPE: Date",
              null,
              null
            );
          (this.paidExpiry = paidExpiry),
            this.keyModified.set("paid_expiry", 1);
        }
        getUsersLicensePurchased() {
          return this.usersLicensePurchased;
        }
        setUsersLicensePurchased(usersLicensePurchased) {
          if (
            null != usersLicensePurchased &&
            "[object BigInt]" !=
              Object.prototype.toString.call(usersLicensePurchased)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: usersLicensePurchased EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.usersLicensePurchased = usersLicensePurchased),
            this.keyModified.set("users_license_purchased", 1);
        }
        getTrialType() {
          return this.trialType;
        }
        setTrialType(trialType) {
          if (
            null != trialType &&
            "[object String]" != Object.prototype.toString.call(trialType)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: trialType EXPECTED TYPE: String",
              null,
              null
            );
          (this.trialType = trialType), this.keyModified.set("trial_type", 1);
        }
        getTrialExpiry() {
          return this.trialExpiry;
        }
        setTrialExpiry(trialExpiry) {
          if (
            null != trialExpiry &&
            "[object String]" != Object.prototype.toString.call(trialExpiry)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: trialExpiry EXPECTED TYPE: String",
              null,
              null
            );
          (this.trialExpiry = trialExpiry),
            this.keyModified.set("trial_expiry", 1);
        }
        getPaid() {
          return this.paid;
        }
        setPaid(paid) {
          if (
            null != paid &&
            "[object Boolean]" != Object.prototype.toString.call(paid)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: paid EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.paid = paid), this.keyModified.set("paid", 1);
        }
        getPaidType() {
          return this.paidType;
        }
        setPaidType(paidType) {
          if (
            null != paidType &&
            "[object String]" != Object.prototype.toString.call(paidType)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: paidType EXPECTED TYPE: String",
              null,
              null
            );
          (this.paidType = paidType), this.keyModified.set("paid_type", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      FileBodyWrapper: class {
        constructor() {
          (this.file = null), (this.keyModified = new Map());
        }
        getFile() {
          return this.file;
        }
        setFile(file) {
          if (
            null != file &&
            !(file instanceof StreamWrapper.Model.StreamWrapper)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: file EXPECTED TYPE: StreamWrapper",
              null,
              null
            );
          (this.file = file), this.keyModified.set("file", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
    },
    Operations: class {
      constructor() {}
      async getOrganization() {
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/org")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "Org.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async uploadOrganizationPhoto(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.Org.Model.FileBodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: FileBodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/org/photo")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("multipart/form-data"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "Org.Model.ActionResponse",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.BluePrint = {
    Model: {
      ResponseHandler: class {
        constructor() {}
      },
      ActionResponse: class {
        constructor() {}
      },
      Transition: class {
        constructor() {
          (this.nextTransitions = null),
            (this.percentPartialSave = null),
            (this.data = null),
            (this.nextFieldValue = null),
            (this.name = null),
            (this.criteriaMatched = null),
            (this.id = null),
            (this.fields = null),
            (this.criteriaMessage = null),
            (this.type = null),
            (this.executionTime = null),
            (this.keyModified = new Map());
        }
        getNextTransitions() {
          return this.nextTransitions;
        }
        setNextTransitions(nextTransitions) {
          if (
            null != nextTransitions &&
            "[object Array]" != Object.prototype.toString.call(nextTransitions)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: nextTransitions EXPECTED TYPE: Array",
              null,
              null
            );
          (this.nextTransitions = nextTransitions),
            this.keyModified.set("next_transitions", 1);
        }
        getPercentPartialSave() {
          return this.percentPartialSave;
        }
        setPercentPartialSave(percentPartialSave) {
          if (
            null != percentPartialSave &&
            "[object Number]" !=
              Object.prototype.toString.call(percentPartialSave)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: percentPartialSave EXPECTED TYPE: Float",
              null,
              null
            );
          (this.percentPartialSave = percentPartialSave),
            this.keyModified.set("percent_partial_save", 1);
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (null != data && !(data instanceof ZCRM.Record.Model.Record))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Record",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getNextFieldValue() {
          return this.nextFieldValue;
        }
        setNextFieldValue(nextFieldValue) {
          if (
            null != nextFieldValue &&
            "[object String]" != Object.prototype.toString.call(nextFieldValue)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: nextFieldValue EXPECTED TYPE: String",
              null,
              null
            );
          (this.nextFieldValue = nextFieldValue),
            this.keyModified.set("next_field_value", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getCriteriaMatched() {
          return this.criteriaMatched;
        }
        setCriteriaMatched(criteriaMatched) {
          if (
            null != criteriaMatched &&
            "[object Boolean]" !=
              Object.prototype.toString.call(criteriaMatched)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: criteriaMatched EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.criteriaMatched = criteriaMatched),
            this.keyModified.set("criteria_matched", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getFields() {
          return this.fields;
        }
        setFields(fields) {
          if (
            null != fields &&
            "[object Array]" != Object.prototype.toString.call(fields)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fields EXPECTED TYPE: Array",
              null,
              null
            );
          (this.fields = fields), this.keyModified.set("fields", 1);
        }
        getCriteriaMessage() {
          return this.criteriaMessage;
        }
        setCriteriaMessage(criteriaMessage) {
          if (
            null != criteriaMessage &&
            "[object String]" != Object.prototype.toString.call(criteriaMessage)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: criteriaMessage EXPECTED TYPE: String",
              null,
              null
            );
          (this.criteriaMessage = criteriaMessage),
            this.keyModified.set("criteria_message", 1);
        }
        getType() {
          return this.type;
        }
        setType(type) {
          if (
            null != type &&
            "[object String]" != Object.prototype.toString.call(type)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: type EXPECTED TYPE: String",
              null,
              null
            );
          (this.type = type), this.keyModified.set("type", 1);
        }
        getExecutionTime() {
          return this.executionTime;
        }
        setExecutionTime(executionTime) {
          if (null != executionTime && !(executionTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: executionTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.executionTime = executionTime),
            this.keyModified.set("execution_time", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BluePrint: class {
        constructor() {
          (this.transitionId = null),
            (this.data = null),
            (this.processInfo = null),
            (this.transitions = null),
            (this.keyModified = new Map());
        }
        getTransitionId() {
          return this.transitionId;
        }
        setTransitionId(transitionId) {
          if (
            null != transitionId &&
            "[object BigInt]" != Object.prototype.toString.call(transitionId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: transitionId EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.transitionId = transitionId),
            this.keyModified.set("transition_id", 1);
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (null != data && !(data instanceof ZCRM.Record.Model.Record))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Record",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getProcessInfo() {
          return this.processInfo;
        }
        setProcessInfo(processInfo) {
          if (
            null != processInfo &&
            !(processInfo instanceof ZCRM.BluePrint.Model.ProcessInfo)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: processInfo EXPECTED TYPE: ProcessInfo",
              null,
              null
            );
          (this.processInfo = processInfo),
            this.keyModified.set("process_info", 1);
        }
        getTransitions() {
          return this.transitions;
        }
        setTransitions(transitions) {
          if (
            null != transitions &&
            "[object Array]" != Object.prototype.toString.call(transitions)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: transitions EXPECTED TYPE: Array",
              null,
              null
            );
          (this.transitions = transitions),
            this.keyModified.set("transitions", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.blueprint = null), (this.keyModified = new Map());
        }
        getBlueprint() {
          return this.blueprint;
        }
        setBlueprint(blueprint) {
          if (
            null != blueprint &&
            "[object Array]" != Object.prototype.toString.call(blueprint)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: blueprint EXPECTED TYPE: Array",
              null,
              null
            );
          (this.blueprint = blueprint), this.keyModified.set("blueprint", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      NextTransition: class {
        constructor() {
          (this.id = null), (this.name = null), (this.keyModified = new Map());
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ProcessInfo: class {
        constructor() {
          (this.fieldId = null),
            (this.isContinuous = null),
            (this.apiName = null),
            (this.continuous = null),
            (this.fieldLabel = null),
            (this.name = null),
            (this.columnName = null),
            (this.fieldValue = null),
            (this.id = null),
            (this.fieldName = null),
            (this.escalation = null),
            (this.keyModified = new Map());
        }
        getFieldId() {
          return this.fieldId;
        }
        setFieldId(fieldId) {
          if (
            null != fieldId &&
            "[object String]" != Object.prototype.toString.call(fieldId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fieldId EXPECTED TYPE: String",
              null,
              null
            );
          (this.fieldId = fieldId), this.keyModified.set("field_id", 1);
        }
        getIsContinuous() {
          return this.isContinuous;
        }
        setIsContinuous(isContinuous) {
          if (
            null != isContinuous &&
            "[object Boolean]" != Object.prototype.toString.call(isContinuous)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: isContinuous EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.isContinuous = isContinuous),
            this.keyModified.set("is_continuous", 1);
        }
        getAPIName() {
          return this.apiName;
        }
        setAPIName(apiName) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          (this.apiName = apiName), this.keyModified.set("api_name", 1);
        }
        getContinuous() {
          return this.continuous;
        }
        setContinuous(continuous) {
          if (
            null != continuous &&
            "[object Boolean]" != Object.prototype.toString.call(continuous)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: continuous EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.continuous = continuous), this.keyModified.set("continuous", 1);
        }
        getFieldLabel() {
          return this.fieldLabel;
        }
        setFieldLabel(fieldLabel) {
          if (
            null != fieldLabel &&
            "[object String]" != Object.prototype.toString.call(fieldLabel)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fieldLabel EXPECTED TYPE: String",
              null,
              null
            );
          (this.fieldLabel = fieldLabel),
            this.keyModified.set("field_label", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getColumnName() {
          return this.columnName;
        }
        setColumnName(columnName) {
          if (
            null != columnName &&
            "[object String]" != Object.prototype.toString.call(columnName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: columnName EXPECTED TYPE: String",
              null,
              null
            );
          (this.columnName = columnName),
            this.keyModified.set("column_name", 1);
        }
        getFieldValue() {
          return this.fieldValue;
        }
        setFieldValue(fieldValue) {
          if (
            null != fieldValue &&
            "[object String]" != Object.prototype.toString.call(fieldValue)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fieldValue EXPECTED TYPE: String",
              null,
              null
            );
          (this.fieldValue = fieldValue),
            this.keyModified.set("field_value", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getFieldName() {
          return this.fieldName;
        }
        setFieldName(fieldName) {
          if (
            null != fieldName &&
            "[object String]" != Object.prototype.toString.call(fieldName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fieldName EXPECTED TYPE: String",
              null,
              null
            );
          (this.fieldName = fieldName), this.keyModified.set("field_name", 1);
        }
        getEscalation() {
          return this.escalation;
        }
        setEscalation(escalation) {
          if (
            null != escalation &&
            "[object String]" != Object.prototype.toString.call(escalation)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: escalation EXPECTED TYPE: String",
              null,
              null
            );
          (this.escalation = escalation), this.keyModified.set("escalation", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.blueprint = null), (this.keyModified = new Map());
        }
        getBlueprint() {
          return this.blueprint;
        }
        setBlueprint(blueprint) {
          if (
            null != blueprint &&
            !(blueprint instanceof ZCRM.BluePrint.Model.BluePrint)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: blueprint EXPECTED TYPE: BluePrint",
              null,
              null
            );
          (this.blueprint = blueprint), this.keyModified.set("blueprint", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ValidationError: class {
        constructor() {
          (this.apiName = null),
            (this.message = null),
            (this.keyModified = new Map());
        }
        getAPIName() {
          return this.apiName;
        }
        setAPIName(apiName) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          (this.apiName = apiName), this.keyModified.set("api_name", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (
            null != message &&
            "[object String]" != Object.prototype.toString.call(message)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: String",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
    },
    Operations: class {
      constructor(recordId, moduleAPIName) {
        if ("[object BigInt]" != Object.prototype.toString.call(recordId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: recordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        (this.recordId = recordId), (this.moduleAPIName = moduleAPIName);
      }
      async getBlueprint() {
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/actions/blueprint"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "BluePrint.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateBlueprint(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.BluePrint.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/actions/blueprint"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "BluePrint.Model.ActionResponse",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.RelatedRecord = {
    Model: {
      ActionHandler: class {
        constructor() {}
      },
      ActionResponse: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.code = null),
            (this.details = null),
            (this.message = null),
            (this.status = null),
            (this.keyModified = new Map());
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.data = null), (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ActionWrapper: class {
        constructor() {
          (this.data = null), (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.data = null),
            (this.info = null),
            (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (null != info && !(info instanceof ZCRM.Record.Model.Info))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Info",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      FileBodyWrapper: class {
        constructor() {
          (this.file = null), (this.keyModified = new Map());
        }
        getFile() {
          return this.file;
        }
        setFile(file) {
          if (
            null != file &&
            !(file instanceof StreamWrapper.Model.StreamWrapper)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: file EXPECTED TYPE: StreamWrapper",
              null,
              null
            );
          (this.file = file), this.keyModified.set("file", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      GetRelatedRecordHeader: {
        IF_MODIFIED_SINCE: new Header(
          "If-Modified-Since",
          "RelatedRecord.Model.GetRelatedRecordHeader"
        ),
      },
      DelinkRecordsHeader: {},
      DeleteRelatedRecordUsingExternalIDHeader: {},
      GetRelatedRecordsParam: {
        PAGE: new Param("page", "RelatedRecord.Model.GetRelatedRecordsParam"),
        PER_PAGE: new Param(
          "per_page",
          "RelatedRecord.Model.GetRelatedRecordsParam"
        ),
      },
      UpdateRelatedRecordUsingExternalIDHeader: {},
      GetRelatedRecordsUsingExternalIDParam: {
        PAGE: new Param(
          "page",
          "RelatedRecord.Model.GetRelatedRecordsUsingExternalIDParam"
        ),
        PER_PAGE: new Param(
          "per_page",
          "RelatedRecord.Model.GetRelatedRecordsUsingExternalIDParam"
        ),
      },
      DeleteRelatedRecordsUsingExternalIDHeader: {},
      GetRelatedRecordUsingExternalIDHeader: {
        IF_MODIFIED_SINCE: new Header(
          "If-Modified-Since",
          "RelatedRecord.Model.GetRelatedRecordUsingExternalIDHeader"
        ),
      },
      UpdateRelatedRecordsUsingExternalIDHeader: {},
      GetRelatedRecordsUsingExternalIDHeader: {
        IF_MODIFIED_SINCE: new Header(
          "If-Modified-Since",
          "RelatedRecord.Model.GetRelatedRecordsUsingExternalIDHeader"
        ),
      },
      DeleteRelatedRecordsUsingExternalIDParam: {
        IDS: new Param(
          "ids",
          "RelatedRecord.Model.DeleteRelatedRecordsUsingExternalIDParam"
        ),
      },
      DelinkRecordHeader: {},
      UpdateRelatedRecordHeader: {},
      GetRelatedRecordsHeader: {
        IF_MODIFIED_SINCE: new Header(
          "If-Modified-Since",
          "RelatedRecord.Model.GetRelatedRecordsHeader"
        ),
      },
      UpdateRelatedRecordsHeader: {},
      DelinkRecordsParam: {
        IDS: new Param("ids", "RelatedRecord.Model.DelinkRecordsParam"),
      },
    },
    Operations: class {
      constructor(relatedListAPIName, moduleAPIName, xExternal = null) {
        if (
          "[object String]" !=
          Object.prototype.toString.call(relatedListAPIName)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: relatedListAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != xExternal &&
          "[object String]" != Object.prototype.toString.call(xExternal)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: xExternal EXPECTED TYPE: String",
            null,
            null
          );
        (this.relatedListAPIName = relatedListAPIName),
          (this.moduleAPIName = moduleAPIName),
          (this.xExternal = xExternal);
      }
      async getRelatedRecords(
        recordId,
        paramInstance = null,
        headerInstance = null
      ) {
        if ("[object BigInt]" != Object.prototype.toString.call(recordId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: recordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(recordId.toString())).concat("/")).concat(
            this.relatedListAPIName.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addHeader(
            new Header(
              "X-EXTERNAL",
              "RelatedRecord.Model.GetRelatedRecordsHeader"
            ),
            this.xExternal
          ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          await Utility.getRelatedLists(
            this.relatedListAPIName,
            this.moduleAPIName,
            handlerInstance
          ),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateRelatedRecords(recordId, request) {
        if ("[object BigInt]" != Object.prototype.toString.call(recordId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: recordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.RelatedRecord.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(recordId.toString())).concat("/")).concat(
            this.relatedListAPIName.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          await handlerInstance.addHeader(
            new Header(
              "X-EXTERNAL",
              "RelatedRecord.Model.UpdateRelatedRecordsHeader"
            ),
            this.xExternal
          ),
          await Utility.getRelatedLists(
            this.relatedListAPIName,
            this.moduleAPIName,
            handlerInstance
          ),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async delinkRecords(recordId, paramInstance = null) {
        if ("[object BigInt]" != Object.prototype.toString.call(recordId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: recordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(recordId.toString())).concat("/")).concat(
            this.relatedListAPIName.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          await handlerInstance.addHeader(
            new Header("X-EXTERNAL", "RelatedRecord.Model.DelinkRecordsHeader"),
            this.xExternal
          ),
          handlerInstance.setParam(paramInstance),
          await Utility.getFields(this.moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getRelatedRecordsUsingExternalId(
        externalValue,
        paramInstance = null,
        headerInstance = null
      ) {
        if ("[object String]" != Object.prototype.toString.call(externalValue))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalValue EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(externalValue.toString())).concat("/")).concat(
            this.relatedListAPIName.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addHeader(
            new Header(
              "X-EXTERNAL",
              "RelatedRecord.Model.GetRelatedRecordsUsingExternalIDHeader"
            ),
            this.xExternal
          ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          await Utility.getRelatedLists(
            this.relatedListAPIName,
            this.moduleAPIName,
            handlerInstance
          ),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateRelatedRecordsUsingExternalId(externalValue, request) {
        if ("[object String]" != Object.prototype.toString.call(externalValue))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalValue EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.RelatedRecord.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(externalValue.toString())).concat("/")).concat(
            this.relatedListAPIName.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          await handlerInstance.addHeader(
            new Header(
              "X-EXTERNAL",
              "RelatedRecord.Model.UpdateRelatedRecordsUsingExternalIDHeader"
            ),
            this.xExternal
          ),
          await Utility.getRelatedLists(
            this.relatedListAPIName,
            this.moduleAPIName,
            handlerInstance
          ),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async deleteRelatedRecordsUsingExternalId(
        externalValue,
        paramInstance = null
      ) {
        if ("[object String]" != Object.prototype.toString.call(externalValue))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalValue EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(externalValue.toString())).concat("/")).concat(
            this.relatedListAPIName.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          await handlerInstance.addHeader(
            new Header(
              "X-EXTERNAL",
              "RelatedRecord.Model.DeleteRelatedRecordsUsingExternalIDHeader"
            ),
            this.xExternal
          ),
          handlerInstance.setParam(paramInstance),
          await Utility.getRelatedLists(
            this.relatedListAPIName,
            this.moduleAPIName,
            handlerInstance
          ),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getRelatedRecord(relatedRecordId, recordId, headerInstance = null) {
        if (
          "[object BigInt]" != Object.prototype.toString.call(relatedRecordId)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: relatedRecordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object BigInt]" != Object.prototype.toString.call(recordId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: recordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
              this.moduleAPIName.toString()
            )).concat("/")).concat(recordId.toString())).concat("/")).concat(
            this.relatedListAPIName.toString()
          )).concat("/")).concat(relatedRecordId.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addHeader(
            new Header(
              "X-EXTERNAL",
              "RelatedRecord.Model.GetRelatedRecordHeader"
            ),
            this.xExternal
          ),
          handlerInstance.setHeader(headerInstance),
          await Utility.getRelatedLists(
            this.relatedListAPIName,
            this.moduleAPIName,
            handlerInstance
          ),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateRelatedRecord(relatedRecordId, recordId, request) {
        if (
          "[object BigInt]" != Object.prototype.toString.call(relatedRecordId)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: relatedRecordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object BigInt]" != Object.prototype.toString.call(recordId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: recordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.RelatedRecord.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
              this.moduleAPIName.toString()
            )).concat("/")).concat(recordId.toString())).concat("/")).concat(
            this.relatedListAPIName.toString()
          )).concat("/")).concat(relatedRecordId.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          await handlerInstance.addHeader(
            new Header(
              "X-EXTERNAL",
              "RelatedRecord.Model.UpdateRelatedRecordHeader"
            ),
            this.xExternal
          ),
          await Utility.getRelatedLists(
            this.relatedListAPIName,
            this.moduleAPIName,
            handlerInstance
          ),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async delinkRecord(relatedRecordId, recordId) {
        if (
          "[object BigInt]" != Object.prototype.toString.call(relatedRecordId)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: relatedRecordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object BigInt]" != Object.prototype.toString.call(recordId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: recordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
              this.moduleAPIName.toString()
            )).concat("/")).concat(recordId.toString())).concat("/")).concat(
            this.relatedListAPIName.toString()
          )).concat("/")).concat(relatedRecordId.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          await handlerInstance.addHeader(
            new Header("X-EXTERNAL", "RelatedRecord.Model.DelinkRecordHeader"),
            this.xExternal
          ),
          await Utility.getFields(this.moduleAPIName, handlerInstance),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getRelatedRecordUsingExternalId(
        externalFieldValue,
        externalValue,
        headerInstance = null
      ) {
        if (
          "[object String]" !=
          Object.prototype.toString.call(externalFieldValue)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalFieldValue EXPECTED TYPE: String",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(externalValue))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalValue EXPECTED TYPE: String",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
              this.moduleAPIName.toString()
            )).concat("/")).concat(externalValue.toString())).concat(
            "/"
          )).concat(this.relatedListAPIName.toString())).concat("/")).concat(
            externalFieldValue.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addHeader(
            new Header(
              "X-EXTERNAL",
              "RelatedRecord.Model.GetRelatedRecordUsingExternalIDHeader"
            ),
            this.xExternal
          ),
          handlerInstance.setHeader(headerInstance),
          await Utility.getRelatedLists(
            this.relatedListAPIName,
            this.moduleAPIName,
            handlerInstance
          ),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateRelatedRecordUsingExternalId(
        externalFieldValue,
        externalValue,
        request
      ) {
        if (
          "[object String]" !=
          Object.prototype.toString.call(externalFieldValue)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalFieldValue EXPECTED TYPE: String",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(externalValue))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalValue EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.RelatedRecord.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
              this.moduleAPIName.toString()
            )).concat("/")).concat(externalValue.toString())).concat(
            "/"
          )).concat(this.relatedListAPIName.toString())).concat("/")).concat(
            externalFieldValue.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          await handlerInstance.addHeader(
            new Header(
              "X-EXTERNAL",
              "RelatedRecord.Model.UpdateRelatedRecordUsingExternalIDHeader"
            ),
            this.xExternal
          ),
          await Utility.getRelatedLists(
            this.relatedListAPIName,
            this.moduleAPIName,
            handlerInstance
          ),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async deleteRelatedRecordUsingExternalId(
        externalFieldValue,
        externalValue
      ) {
        if (
          "[object String]" !=
          Object.prototype.toString.call(externalFieldValue)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalFieldValue EXPECTED TYPE: String",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(externalValue))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: externalValue EXPECTED TYPE: String",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
              this.moduleAPIName.toString()
            )).concat("/")).concat(externalValue.toString())).concat(
            "/"
          )).concat(this.relatedListAPIName.toString())).concat("/")).concat(
            externalFieldValue.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          await handlerInstance.addHeader(
            new Header(
              "X-EXTERNAL",
              "RelatedRecord.Model.DeleteRelatedRecordUsingExternalIDHeader"
            ),
            this.xExternal
          ),
          await Utility.getRelatedLists(
            this.relatedListAPIName,
            this.moduleAPIName,
            handlerInstance
          ),
          handlerInstance.apiCall(
            "RelatedRecord.Model.ActionHandler",
            "application/json"
          )
        );
      }
    },
  });
class ProxyBuilder {
  constructor() {
    (this._host = null), (this._port = null);
  }
  host(host) {
    return (
      Utility.assertNotNull(
        host,
        Constants.USER_PROXY_ERROR,
        Constants.HOST_ERROR_MESSAGE
      ),
      (this._host = host),
      this
    );
  }
  port(port) {
    return (
      Utility.assertNotNull(
        port,
        Constants.USER_PROXY_ERROR,
        Constants.PORT_ERROR_MESSAGE
      ),
      (this._port = port),
      this
    );
  }
  build() {
    return (
      Utility.assertNotNull(
        this._host,
        Constants.REQUEST_PROXY_ERROR,
        Constants.HOST_ERROR_MESSAGE
      ),
      Utility.assertNotNull(
        this._port,
        Constants.REQUEST_PROXY_ERROR,
        Constants.PORT_ERROR_MESSAGE
      ),
      new RequestProxy(this._host, this._port)
    );
  }
}
(ZCRM.Role = {
  Model: {
    ResponseHandler: class {
      constructor() {}
    },
    Role: class {
      constructor() {
        (this.displayLabel = null),
          (this.forecastManager = null),
          (this.shareWithPeers = null),
          (this.name = null),
          (this.description = null),
          (this.id = null),
          (this.reportingTo = null),
          (this.adminUser = null),
          (this.keyModified = new Map());
      }
      getDisplayLabel() {
        return this.displayLabel;
      }
      setDisplayLabel(displayLabel) {
        if (
          null != displayLabel &&
          "[object String]" != Object.prototype.toString.call(displayLabel)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: displayLabel EXPECTED TYPE: String",
            null,
            null
          );
        (this.displayLabel = displayLabel),
          this.keyModified.set("display_label", 1);
      }
      getForecastManager() {
        return this.forecastManager;
      }
      setForecastManager(forecastManager) {
        if (
          null != forecastManager &&
          !(forecastManager instanceof ZCRM.User.Model.User)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: forecastManager EXPECTED TYPE: User",
            null,
            null
          );
        (this.forecastManager = forecastManager),
          this.keyModified.set("forecast_manager", 1);
      }
      getShareWithPeers() {
        return this.shareWithPeers;
      }
      setShareWithPeers(shareWithPeers) {
        if (
          null != shareWithPeers &&
          "[object Boolean]" != Object.prototype.toString.call(shareWithPeers)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: shareWithPeers EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.shareWithPeers = shareWithPeers),
          this.keyModified.set("share_with_peers", 1);
      }
      getName() {
        return this.name;
      }
      setName(name) {
        if (
          null != name &&
          "[object String]" != Object.prototype.toString.call(name)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: name EXPECTED TYPE: String",
            null,
            null
          );
        (this.name = name), this.keyModified.set("name", 1);
      }
      getDescription() {
        return this.description;
      }
      setDescription(description) {
        if (
          null != description &&
          "[object String]" != Object.prototype.toString.call(description)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: description EXPECTED TYPE: String",
            null,
            null
          );
        (this.description = description),
          this.keyModified.set("description", 1);
      }
      getId() {
        return this.id;
      }
      setId(id) {
        if (
          null != id &&
          "[object BigInt]" != Object.prototype.toString.call(id)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        (this.id = id), this.keyModified.set("id", 1);
      }
      getReportingTo() {
        return this.reportingTo;
      }
      setReportingTo(reportingTo) {
        if (
          null != reportingTo &&
          !(reportingTo instanceof ZCRM.User.Model.User)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: reportingTo EXPECTED TYPE: User",
            null,
            null
          );
        (this.reportingTo = reportingTo),
          this.keyModified.set("reporting_to", 1);
      }
      getAdminUser() {
        return this.adminUser;
      }
      setAdminUser(adminUser) {
        if (
          null != adminUser &&
          "[object Boolean]" != Object.prototype.toString.call(adminUser)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: adminUser EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.adminUser = adminUser), this.keyModified.set("admin_user", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    APIException: class {
      constructor() {
        (this.status = null),
          (this.code = null),
          (this.message = null),
          (this.details = null),
          (this.keyModified = new Map());
      }
      getStatus() {
        return this.status;
      }
      setStatus(status) {
        if (null != status && !(status instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: status EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.status = status), this.keyModified.set("status", 1);
      }
      getCode() {
        return this.code;
      }
      setCode(code) {
        if (null != code && !(code instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: code EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.code = code), this.keyModified.set("code", 1);
      }
      getMessage() {
        return this.message;
      }
      setMessage(message) {
        if (null != message && !(message instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: message EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.message = message), this.keyModified.set("message", 1);
      }
      getDetails() {
        return this.details;
      }
      setDetails(details) {
        if (
          null != details &&
          "[object Map]" != Object.prototype.toString.call(details)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: details EXPECTED TYPE: Map",
            null,
            null
          );
        (this.details = details), this.keyModified.set("details", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    ResponseWrapper: class {
      constructor() {
        (this.roles = null), (this.keyModified = new Map());
      }
      getRoles() {
        return this.roles;
      }
      setRoles(roles) {
        if (
          null != roles &&
          "[object Array]" != Object.prototype.toString.call(roles)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: roles EXPECTED TYPE: Array",
            null,
            null
          );
        (this.roles = roles), this.keyModified.set("roles", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
  },
  Operations: class {
    constructor() {}
    async getRoles() {
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/settings/roles")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
        handlerInstance.apiCall(
          "Role.Model.ResponseHandler",
          "application/json"
        )
      );
    }
    async getRole(id) {
      if ("[object BigInt]" != Object.prototype.toString.call(id))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: id EXPECTED TYPE: BigInt",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = (apiPath = apiPath.concat("/crm/v2/settings/roles/")).concat(
          id.toString()
        )),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
        handlerInstance.apiCall(
          "Role.Model.ResponseHandler",
          "application/json"
        )
      );
    }
  },
}),
  (ZCRM.Tag = {
    Model: {
      ActionHandler: class {
        constructor() {}
      },
      RecordActionResponse: class {
        constructor() {}
      },
      CountHandler: class {
        constructor() {}
      },
      RecordActionHandler: class {
        constructor() {}
      },
      ActionResponse: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      MergeWrapper: class {
        constructor() {
          (this.tags = null), (this.keyModified = new Map());
        }
        getTags() {
          return this.tags;
        }
        setTags(tags) {
          if (
            null != tags &&
            "[object Array]" != Object.prototype.toString.call(tags)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: tags EXPECTED TYPE: Array",
              null,
              null
            );
          (this.tags = tags), this.keyModified.set("tags", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ActionWrapper: class {
        constructor() {
          (this.tags = null), (this.keyModified = new Map());
        }
        getTags() {
          return this.tags;
        }
        setTags(tags) {
          if (
            null != tags &&
            "[object Array]" != Object.prototype.toString.call(tags)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: tags EXPECTED TYPE: Array",
              null,
              null
            );
          (this.tags = tags), this.keyModified.set("tags", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.tags = null), (this.keyModified = new Map());
        }
        getTags() {
          return this.tags;
        }
        setTags(tags) {
          if (
            null != tags &&
            "[object Array]" != Object.prototype.toString.call(tags)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: tags EXPECTED TYPE: Array",
              null,
              null
            );
          (this.tags = tags), this.keyModified.set("tags", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.tags = null),
            (this.info = null),
            (this.keyModified = new Map());
        }
        getTags() {
          return this.tags;
        }
        setTags(tags) {
          if (
            null != tags &&
            "[object Array]" != Object.prototype.toString.call(tags)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: tags EXPECTED TYPE: Array",
              null,
              null
            );
          (this.tags = tags), this.keyModified.set("tags", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (null != info && !(info instanceof ZCRM.Tag.Model.Info))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Info",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Tag: class {
        constructor() {
          (this.createdTime = null),
            (this.modifiedTime = null),
            (this.name = null),
            (this.modifiedBy = null),
            (this.id = null),
            (this.createdBy = null),
            (this.keyModified = new Map());
        }
        getCreatedTime() {
          return this.createdTime;
        }
        setCreatedTime(createdTime) {
          if (null != createdTime && !(createdTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.createdTime = createdTime),
            this.keyModified.set("created_time", 1);
        }
        getModifiedTime() {
          return this.modifiedTime;
        }
        setModifiedTime(modifiedTime) {
          if (null != modifiedTime && !(modifiedTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.modifiedTime = modifiedTime),
            this.keyModified.set("modified_time", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getModifiedBy() {
          return this.modifiedBy;
        }
        setModifiedBy(modifiedBy) {
          if (
            null != modifiedBy &&
            !(modifiedBy instanceof ZCRM.User.Model.User)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.modifiedBy = modifiedBy),
            this.keyModified.set("modified_by", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getCreatedBy() {
          return this.createdBy;
        }
        setCreatedBy(createdBy) {
          if (null != createdBy && !(createdBy instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.createdBy = createdBy), this.keyModified.set("created_by", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Info: class {
        constructor() {
          (this.count = null),
            (this.allowedCount = null),
            (this.keyModified = new Map());
        }
        getCount() {
          return this.count;
        }
        setCount(count) {
          if (
            null != count &&
            "[object Number]" != Object.prototype.toString.call(count)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: count EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.count = count), this.keyModified.set("count", 1);
        }
        getAllowedCount() {
          return this.allowedCount;
        }
        setAllowedCount(allowedCount) {
          if (
            null != allowedCount &&
            "[object Number]" != Object.prototype.toString.call(allowedCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: allowedCount EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.allowedCount = allowedCount),
            this.keyModified.set("allowed_count", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.code = null),
            (this.status = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RecordActionWrapper: class {
        constructor() {
          (this.data = null),
            (this.wfScheduler = null),
            (this.successCount = null),
            (this.lockedCount = null),
            (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getWfScheduler() {
          return this.wfScheduler;
        }
        setWfScheduler(wfScheduler) {
          if (
            null != wfScheduler &&
            "[object Boolean]" != Object.prototype.toString.call(wfScheduler)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: wfScheduler EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.wfScheduler = wfScheduler),
            this.keyModified.set("wf_scheduler", 1);
        }
        getSuccessCount() {
          return this.successCount;
        }
        setSuccessCount(successCount) {
          if (
            null != successCount &&
            "[object String]" != Object.prototype.toString.call(successCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: successCount EXPECTED TYPE: String",
              null,
              null
            );
          (this.successCount = successCount),
            this.keyModified.set("success_count", 1);
        }
        getLockedCount() {
          return this.lockedCount;
        }
        setLockedCount(lockedCount) {
          if (
            null != lockedCount &&
            "[object Number]" != Object.prototype.toString.call(lockedCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: lockedCount EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.lockedCount = lockedCount),
            this.keyModified.set("locked_count", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      CountWrapper: class {
        constructor() {
          (this.count = null), (this.keyModified = new Map());
        }
        getCount() {
          return this.count;
        }
        setCount(count) {
          if (
            null != count &&
            "[object String]" != Object.prototype.toString.call(count)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: count EXPECTED TYPE: String",
              null,
              null
            );
          (this.count = count), this.keyModified.set("count", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ConflictWrapper: class {
        constructor() {
          (this.conflictId = null), (this.keyModified = new Map());
        }
        getConflictId() {
          return this.conflictId;
        }
        setConflictId(conflictId) {
          if (
            null != conflictId &&
            "[object String]" != Object.prototype.toString.call(conflictId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: conflictId EXPECTED TYPE: String",
              null,
              null
            );
          (this.conflictId = conflictId),
            this.keyModified.set("conflict_id", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RemoveTagsFromMultipleRecordsParam: {
        TAG_NAMES: new Param(
          "tag_names",
          "Tag.Model.RemoveTagsFromMultipleRecordsParam"
        ),
        IDS: new Param("ids", "Tag.Model.RemoveTagsFromMultipleRecordsParam"),
      },
      AddTagsToRecordParam: {
        TAG_NAMES: new Param("tag_names", "Tag.Model.AddTagsToRecordParam"),
        OVER_WRITE: new Param("over_write", "Tag.Model.AddTagsToRecordParam"),
      },
      AddTagsToMultipleRecordsParam: {
        TAG_NAMES: new Param(
          "tag_names",
          "Tag.Model.AddTagsToMultipleRecordsParam"
        ),
        IDS: new Param("ids", "Tag.Model.AddTagsToMultipleRecordsParam"),
        OVER_WRITE: new Param(
          "over_write",
          "Tag.Model.AddTagsToMultipleRecordsParam"
        ),
      },
      RemoveTagsFromRecordParam: {
        TAG_NAMES: new Param(
          "tag_names",
          "Tag.Model.RemoveTagsFromRecordParam"
        ),
      },
      GetRecordCountForTagParam: {
        MODULE: new Param("module", "Tag.Model.GetRecordCountForTagParam"),
      },
      UpdateTagsParam: {
        MODULE: new Param("module", "Tag.Model.UpdateTagsParam"),
      },
      UpdateTagParam: {
        MODULE: new Param("module", "Tag.Model.UpdateTagParam"),
      },
      GetTagsParam: {
        MODULE: new Param("module", "Tag.Model.GetTagsParam"),
        MY_TAGS: new Param("my_tags", "Tag.Model.GetTagsParam"),
      },
      CreateTagsParam: {
        MODULE: new Param("module", "Tag.Model.CreateTagsParam"),
      },
    },
    Operations: class {
      constructor() {}
      async getTags(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/tags")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Tag.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async createTags(request, paramInstance = null) {
        if (null != request && !(request instanceof ZCRM.Tag.Model.BodyWrapper))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/tags")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall("Tag.Model.ActionHandler", "application/json")
        );
      }
      async updateTags(request, paramInstance = null) {
        if (null != request && !(request instanceof ZCRM.Tag.Model.BodyWrapper))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/tags")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall("Tag.Model.ActionHandler", "application/json")
        );
      }
      async updateTag(id, request, paramInstance = null) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (null != request && !(request instanceof ZCRM.Tag.Model.BodyWrapper))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/tags/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall("Tag.Model.ActionHandler", "application/json")
        );
      }
      async deleteTag(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/tags/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.apiCall("Tag.Model.ActionHandler", "application/json")
        );
      }
      async mergeTags(id, request) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Tag.Model.MergeWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: MergeWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/tags/"
          )).concat(id.toString())).concat("/actions/merge")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall("Tag.Model.ActionHandler", "application/json")
        );
      }
      async addTagsToRecord(recordId, moduleAPIName, paramInstance = null) {
        if ("[object BigInt]" != Object.prototype.toString.call(recordId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: recordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/")).concat(recordId.toString())).concat(
            "/actions/add_tags"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Tag.Model.RecordActionHandler",
            "application/json"
          )
        );
      }
      async removeTagsFromRecord(
        recordId,
        moduleAPIName,
        paramInstance = null
      ) {
        if ("[object BigInt]" != Object.prototype.toString.call(recordId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: recordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/")).concat(recordId.toString())).concat(
            "/actions/remove_tags"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Tag.Model.RecordActionHandler",
            "application/json"
          )
        );
      }
      async addTagsToMultipleRecords(moduleAPIName, paramInstance = null) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/actions/add_tags")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Tag.Model.RecordActionHandler",
            "application/json"
          )
        );
      }
      async removeTagsFromMultipleRecords(moduleAPIName, paramInstance = null) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = apiPath.concat("/crm/v2/")).concat(
            moduleAPIName.toString()
          )).concat("/actions/remove_tags")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Tag.Model.RecordActionHandler",
            "application/json"
          )
        );
      }
      async getRecordCountForTag(id, paramInstance = null) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/tags/"
          )).concat(id.toString())).concat("/actions/records_count")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall("Tag.Model.CountHandler", "application/json")
        );
      }
    },
  }),
  (ZCRM.CustomView = {
    Model: {
      ResponseHandler: class {
        constructor() {}
      },
      SharedDetails: class {
        constructor() {
          (this.id = null),
            (this.name = null),
            (this.type = null),
            (this.subordinates = null),
            (this.keyModified = new Map());
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getType() {
          return this.type;
        }
        setType(type) {
          if (
            null != type &&
            "[object String]" != Object.prototype.toString.call(type)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: type EXPECTED TYPE: String",
              null,
              null
            );
          (this.type = type), this.keyModified.set("type", 1);
        }
        getSubordinates() {
          return this.subordinates;
        }
        setSubordinates(subordinates) {
          if (
            null != subordinates &&
            "[object Boolean]" != Object.prototype.toString.call(subordinates)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: subordinates EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.subordinates = subordinates),
            this.keyModified.set("subordinates", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Translation: class {
        constructor() {
          (this.publicViews = null),
            (this.otherUsersViews = null),
            (this.sharedWithMe = null),
            (this.createdByMe = null),
            (this.keyModified = new Map());
        }
        getPublicViews() {
          return this.publicViews;
        }
        setPublicViews(publicViews) {
          if (
            null != publicViews &&
            "[object String]" != Object.prototype.toString.call(publicViews)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: publicViews EXPECTED TYPE: String",
              null,
              null
            );
          (this.publicViews = publicViews),
            this.keyModified.set("public_views", 1);
        }
        getOtherUsersViews() {
          return this.otherUsersViews;
        }
        setOtherUsersViews(otherUsersViews) {
          if (
            null != otherUsersViews &&
            "[object String]" != Object.prototype.toString.call(otherUsersViews)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: otherUsersViews EXPECTED TYPE: String",
              null,
              null
            );
          (this.otherUsersViews = otherUsersViews),
            this.keyModified.set("other_users_views", 1);
        }
        getSharedWithMe() {
          return this.sharedWithMe;
        }
        setSharedWithMe(sharedWithMe) {
          if (
            null != sharedWithMe &&
            "[object String]" != Object.prototype.toString.call(sharedWithMe)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sharedWithMe EXPECTED TYPE: String",
              null,
              null
            );
          (this.sharedWithMe = sharedWithMe),
            this.keyModified.set("shared_with_me", 1);
        }
        getCreatedByMe() {
          return this.createdByMe;
        }
        setCreatedByMe(createdByMe) {
          if (
            null != createdByMe &&
            "[object String]" != Object.prototype.toString.call(createdByMe)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdByMe EXPECTED TYPE: String",
              null,
              null
            );
          (this.createdByMe = createdByMe),
            this.keyModified.set("created_by_me", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.customViews = null),
            (this.info = null),
            (this.keyModified = new Map());
        }
        getCustomViews() {
          return this.customViews;
        }
        setCustomViews(customViews) {
          if (
            null != customViews &&
            "[object Array]" != Object.prototype.toString.call(customViews)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: customViews EXPECTED TYPE: Array",
              null,
              null
            );
          (this.customViews = customViews),
            this.keyModified.set("custom_views", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (null != info && !(info instanceof ZCRM.CustomView.Model.Info))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Info",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Info: class {
        constructor() {
          (this.perPage = null),
            (this.default1 = null),
            (this.count = null),
            (this.page = null),
            (this.moreRecords = null),
            (this.translation = null),
            (this.keyModified = new Map());
        }
        getPerPage() {
          return this.perPage;
        }
        setPerPage(perPage) {
          if (
            null != perPage &&
            "[object Number]" != Object.prototype.toString.call(perPage)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: perPage EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.perPage = perPage), this.keyModified.set("per_page", 1);
        }
        getDefault() {
          return this.default1;
        }
        setDefault(default1) {
          if (
            null != default1 &&
            "[object String]" != Object.prototype.toString.call(default1)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: default1 EXPECTED TYPE: String",
              null,
              null
            );
          (this.default1 = default1), this.keyModified.set("default", 1);
        }
        getCount() {
          return this.count;
        }
        setCount(count) {
          if (
            null != count &&
            "[object Number]" != Object.prototype.toString.call(count)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: count EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.count = count), this.keyModified.set("count", 1);
        }
        getPage() {
          return this.page;
        }
        setPage(page) {
          if (
            null != page &&
            "[object Number]" != Object.prototype.toString.call(page)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: page EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.page = page), this.keyModified.set("page", 1);
        }
        getMoreRecords() {
          return this.moreRecords;
        }
        setMoreRecords(moreRecords) {
          if (
            null != moreRecords &&
            "[object Boolean]" != Object.prototype.toString.call(moreRecords)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: moreRecords EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.moreRecords = moreRecords),
            this.keyModified.set("more_records", 1);
        }
        getTranslation() {
          return this.translation;
        }
        setTranslation(translation) {
          if (
            null != translation &&
            !(translation instanceof ZCRM.CustomView.Model.Translation)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: translation EXPECTED TYPE: Translation",
              null,
              null
            );
          (this.translation = translation),
            this.keyModified.set("translation", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      CustomView: class {
        constructor() {
          (this.id = null),
            (this.name = null),
            (this.systemName = null),
            (this.displayValue = null),
            (this.sharedType = null),
            (this.category = null),
            (this.sortBy = null),
            (this.sortOrder = null),
            (this.favorite = null),
            (this.offline = null),
            (this.default1 = null),
            (this.systemDefined = null),
            (this.criteria = null),
            (this.sharedDetails = null),
            (this.fields = null),
            (this.keyModified = new Map());
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getSystemName() {
          return this.systemName;
        }
        setSystemName(systemName) {
          if (
            null != systemName &&
            "[object String]" != Object.prototype.toString.call(systemName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: systemName EXPECTED TYPE: String",
              null,
              null
            );
          (this.systemName = systemName),
            this.keyModified.set("system_name", 1);
        }
        getDisplayValue() {
          return this.displayValue;
        }
        setDisplayValue(displayValue) {
          if (
            null != displayValue &&
            "[object String]" != Object.prototype.toString.call(displayValue)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: displayValue EXPECTED TYPE: String",
              null,
              null
            );
          (this.displayValue = displayValue),
            this.keyModified.set("display_value", 1);
        }
        getSharedType() {
          return this.sharedType;
        }
        setSharedType(sharedType) {
          if (
            null != sharedType &&
            "[object String]" != Object.prototype.toString.call(sharedType)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sharedType EXPECTED TYPE: String",
              null,
              null
            );
          (this.sharedType = sharedType),
            this.keyModified.set("shared_type", 1);
        }
        getCategory() {
          return this.category;
        }
        setCategory(category) {
          if (
            null != category &&
            "[object String]" != Object.prototype.toString.call(category)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: category EXPECTED TYPE: String",
              null,
              null
            );
          (this.category = category), this.keyModified.set("category", 1);
        }
        getSortBy() {
          return this.sortBy;
        }
        setSortBy(sortBy) {
          if (
            null != sortBy &&
            "[object String]" != Object.prototype.toString.call(sortBy)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sortBy EXPECTED TYPE: String",
              null,
              null
            );
          (this.sortBy = sortBy), this.keyModified.set("sort_by", 1);
        }
        getSortOrder() {
          return this.sortOrder;
        }
        setSortOrder(sortOrder) {
          if (
            null != sortOrder &&
            "[object String]" != Object.prototype.toString.call(sortOrder)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sortOrder EXPECTED TYPE: String",
              null,
              null
            );
          (this.sortOrder = sortOrder), this.keyModified.set("sort_order", 1);
        }
        getFavorite() {
          return this.favorite;
        }
        setFavorite(favorite) {
          if (
            null != favorite &&
            "[object Number]" != Object.prototype.toString.call(favorite)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: favorite EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.favorite = favorite), this.keyModified.set("favorite", 1);
        }
        getOffline() {
          return this.offline;
        }
        setOffline(offline) {
          if (
            null != offline &&
            "[object Boolean]" != Object.prototype.toString.call(offline)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: offline EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.offline = offline), this.keyModified.set("offline", 1);
        }
        getDefault() {
          return this.default1;
        }
        setDefault(default1) {
          if (
            null != default1 &&
            "[object Boolean]" != Object.prototype.toString.call(default1)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: default1 EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.default1 = default1), this.keyModified.set("default", 1);
        }
        getSystemDefined() {
          return this.systemDefined;
        }
        setSystemDefined(systemDefined) {
          if (
            null != systemDefined &&
            "[object Boolean]" != Object.prototype.toString.call(systemDefined)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: systemDefined EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.systemDefined = systemDefined),
            this.keyModified.set("system_defined", 1);
        }
        getCriteria() {
          return this.criteria;
        }
        setCriteria(criteria) {
          if (
            null != criteria &&
            !(criteria instanceof ZCRM.CustomView.Model.Criteria)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: criteria EXPECTED TYPE: Criteria",
              null,
              null
            );
          (this.criteria = criteria), this.keyModified.set("criteria", 1);
        }
        getSharedDetails() {
          return this.sharedDetails;
        }
        setSharedDetails(sharedDetails) {
          if (
            null != sharedDetails &&
            "[object Array]" != Object.prototype.toString.call(sharedDetails)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sharedDetails EXPECTED TYPE: Array",
              null,
              null
            );
          (this.sharedDetails = sharedDetails),
            this.keyModified.set("shared_details", 1);
        }
        getFields() {
          return this.fields;
        }
        setFields(fields) {
          if (
            null != fields &&
            "[object Array]" != Object.prototype.toString.call(fields)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fields EXPECTED TYPE: Array",
              null,
              null
            );
          (this.fields = fields), this.keyModified.set("fields", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Criteria: class {
        constructor() {
          (this.comparator = null),
            (this.field = null),
            (this.value = null),
            (this.groupOperator = null),
            (this.group = null),
            (this.keyModified = new Map());
        }
        getComparator() {
          return this.comparator;
        }
        setComparator(comparator) {
          if (null != comparator && !(comparator instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: comparator EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.comparator = comparator), this.keyModified.set("comparator", 1);
        }
        getField() {
          return this.field;
        }
        setField(field) {
          if (
            null != field &&
            "[object String]" != Object.prototype.toString.call(field)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: field EXPECTED TYPE: String",
              null,
              null
            );
          (this.field = field), this.keyModified.set("field", 1);
        }
        getValue() {
          return this.value;
        }
        setValue(value) {
          (this.value = value), this.keyModified.set("value", 1);
        }
        getGroupOperator() {
          return this.groupOperator;
        }
        setGroupOperator(groupOperator) {
          if (null != groupOperator && !(groupOperator instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: groupOperator EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.groupOperator = groupOperator),
            this.keyModified.set("group_operator", 1);
        }
        getGroup() {
          return this.group;
        }
        setGroup(group) {
          if (
            null != group &&
            "[object Array]" != Object.prototype.toString.call(group)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: group EXPECTED TYPE: Array",
              null,
              null
            );
          (this.group = group), this.keyModified.set("group", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Range: class {
        constructor() {
          (this.from = null), (this.to = null), (this.keyModified = new Map());
        }
        getFrom() {
          return this.from;
        }
        setFrom(from) {
          if (
            null != from &&
            "[object Number]" != Object.prototype.toString.call(from)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: from EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.from = from), this.keyModified.set("from", 1);
        }
        getTo() {
          return this.to;
        }
        setTo(to) {
          if (
            null != to &&
            "[object Number]" != Object.prototype.toString.call(to)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: to EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.to = to), this.keyModified.set("to", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      GetCustomViewsParam: {
        PAGE: new Param("page", "CustomView.Model.GetCustomViewsParam"),
        PER_PAGE: new Param("per_page", "CustomView.Model.GetCustomViewsParam"),
      },
      GetCustomViewParam: {},
    },
    Operations: class {
      constructor(module = null) {
        if (
          null != module &&
          "[object String]" != Object.prototype.toString.call(module)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: module EXPECTED TYPE: String",
            null,
            null
          );
        this.module = module;
      }
      async getCustomViews(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/custom_views")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addParam(
            new Param("module", "CustomView.Model.GetCustomViewsParam"),
            this.module
          ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "CustomView.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async getCustomView(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/custom_views/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addParam(
            new Param("module", "CustomView.Model.GetCustomViewParam"),
            this.module
          ),
          handlerInstance.apiCall(
            "CustomView.Model.ResponseHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.BulkRead = {
    Model: {
      ActionHandler: class {
        constructor() {}
      },
      ActionResponse: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      Criteria: class {
        constructor() {
          (this.apiName = null),
            (this.value = null),
            (this.groupOperator = null),
            (this.group = null),
            (this.comparator = null),
            (this.keyModified = new Map());
        }
        getAPIName() {
          return this.apiName;
        }
        setAPIName(apiName) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          (this.apiName = apiName), this.keyModified.set("api_name", 1);
        }
        getValue() {
          return this.value;
        }
        setValue(value) {
          (this.value = value), this.keyModified.set("value", 1);
        }
        getGroupOperator() {
          return this.groupOperator;
        }
        setGroupOperator(groupOperator) {
          if (null != groupOperator && !(groupOperator instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: groupOperator EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.groupOperator = groupOperator),
            this.keyModified.set("group_operator", 1);
        }
        getGroup() {
          return this.group;
        }
        setGroup(group) {
          if (
            null != group &&
            "[object Array]" != Object.prototype.toString.call(group)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: group EXPECTED TYPE: Array",
              null,
              null
            );
          (this.group = group), this.keyModified.set("group", 1);
        }
        getComparator() {
          return this.comparator;
        }
        setComparator(comparator) {
          if (null != comparator && !(comparator instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: comparator EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.comparator = comparator), this.keyModified.set("comparator", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Query: class {
        constructor() {
          (this.module = null),
            (this.cvid = null),
            (this.fields = null),
            (this.page = null),
            (this.criteria = null),
            (this.keyModified = new Map());
        }
        getModule() {
          return this.module;
        }
        setModule(module) {
          if (
            null != module &&
            "[object String]" != Object.prototype.toString.call(module)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: module EXPECTED TYPE: String",
              null,
              null
            );
          (this.module = module), this.keyModified.set("module", 1);
        }
        getCvid() {
          return this.cvid;
        }
        setCvid(cvid) {
          if (
            null != cvid &&
            "[object String]" != Object.prototype.toString.call(cvid)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: cvid EXPECTED TYPE: String",
              null,
              null
            );
          (this.cvid = cvid), this.keyModified.set("cvid", 1);
        }
        getFields() {
          return this.fields;
        }
        setFields(fields) {
          if (
            null != fields &&
            "[object Array]" != Object.prototype.toString.call(fields)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fields EXPECTED TYPE: Array",
              null,
              null
            );
          (this.fields = fields), this.keyModified.set("fields", 1);
        }
        getPage() {
          return this.page;
        }
        setPage(page) {
          if (
            null != page &&
            "[object Number]" != Object.prototype.toString.call(page)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: page EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.page = page), this.keyModified.set("page", 1);
        }
        getCriteria() {
          return this.criteria;
        }
        setCriteria(criteria) {
          if (
            null != criteria &&
            !(criteria instanceof ZCRM.BulkRead.Model.Criteria)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: criteria EXPECTED TYPE: Criteria",
              null,
              null
            );
          (this.criteria = criteria), this.keyModified.set("criteria", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RequestWrapper: class {
        constructor() {
          (this.callback = null),
            (this.query = null),
            (this.fileType = null),
            (this.keyModified = new Map());
        }
        getCallback() {
          return this.callback;
        }
        setCallback(callback) {
          if (
            null != callback &&
            !(callback instanceof ZCRM.BulkRead.Model.CallBack)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: callback EXPECTED TYPE: CallBack",
              null,
              null
            );
          (this.callback = callback), this.keyModified.set("callback", 1);
        }
        getQuery() {
          return this.query;
        }
        setQuery(query) {
          if (null != query && !(query instanceof ZCRM.BulkRead.Model.Query))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: query EXPECTED TYPE: Query",
              null,
              null
            );
          (this.query = query), this.keyModified.set("query", 1);
        }
        getFileType() {
          return this.fileType;
        }
        setFileType(fileType) {
          if (null != fileType && !(fileType instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fileType EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.fileType = fileType), this.keyModified.set("file_type", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      JobDetail: class {
        constructor() {
          (this.id = null),
            (this.operation = null),
            (this.state = null),
            (this.query = null),
            (this.createdBy = null),
            (this.createdTime = null),
            (this.result = null),
            (this.fileType = null),
            (this.keyModified = new Map());
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getOperation() {
          return this.operation;
        }
        setOperation(operation) {
          if (
            null != operation &&
            "[object String]" != Object.prototype.toString.call(operation)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: operation EXPECTED TYPE: String",
              null,
              null
            );
          (this.operation = operation), this.keyModified.set("operation", 1);
        }
        getState() {
          return this.state;
        }
        setState(state) {
          if (null != state && !(state instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: state EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.state = state), this.keyModified.set("state", 1);
        }
        getQuery() {
          return this.query;
        }
        setQuery(query) {
          if (null != query && !(query instanceof ZCRM.BulkRead.Model.Query))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: query EXPECTED TYPE: Query",
              null,
              null
            );
          (this.query = query), this.keyModified.set("query", 1);
        }
        getCreatedBy() {
          return this.createdBy;
        }
        setCreatedBy(createdBy) {
          if (null != createdBy && !(createdBy instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.createdBy = createdBy), this.keyModified.set("created_by", 1);
        }
        getCreatedTime() {
          return this.createdTime;
        }
        setCreatedTime(createdTime) {
          if (null != createdTime && !(createdTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.createdTime = createdTime),
            this.keyModified.set("created_time", 1);
        }
        getResult() {
          return this.result;
        }
        setResult(result) {
          if (null != result && !(result instanceof ZCRM.BulkRead.Model.Result))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: result EXPECTED TYPE: Result",
              null,
              null
            );
          (this.result = result), this.keyModified.set("result", 1);
        }
        getFileType() {
          return this.fileType;
        }
        setFileType(fileType) {
          if (
            null != fileType &&
            "[object String]" != Object.prototype.toString.call(fileType)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fileType EXPECTED TYPE: String",
              null,
              null
            );
          (this.fileType = fileType), this.keyModified.set("file_type", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Result: class {
        constructor() {
          (this.page = null),
            (this.count = null),
            (this.downloadUrl = null),
            (this.perPage = null),
            (this.moreRecords = null),
            (this.keyModified = new Map());
        }
        getPage() {
          return this.page;
        }
        setPage(page) {
          if (
            null != page &&
            "[object Number]" != Object.prototype.toString.call(page)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: page EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.page = page), this.keyModified.set("page", 1);
        }
        getCount() {
          return this.count;
        }
        setCount(count) {
          if (
            null != count &&
            "[object Number]" != Object.prototype.toString.call(count)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: count EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.count = count), this.keyModified.set("count", 1);
        }
        getDownloadUrl() {
          return this.downloadUrl;
        }
        setDownloadUrl(downloadUrl) {
          if (
            null != downloadUrl &&
            "[object String]" != Object.prototype.toString.call(downloadUrl)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: downloadUrl EXPECTED TYPE: String",
              null,
              null
            );
          (this.downloadUrl = downloadUrl),
            this.keyModified.set("download_url", 1);
        }
        getPerPage() {
          return this.perPage;
        }
        setPerPage(perPage) {
          if (
            null != perPage &&
            "[object Number]" != Object.prototype.toString.call(perPage)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: perPage EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.perPage = perPage), this.keyModified.set("per_page", 1);
        }
        getMoreRecords() {
          return this.moreRecords;
        }
        setMoreRecords(moreRecords) {
          if (
            null != moreRecords &&
            "[object Boolean]" != Object.prototype.toString.call(moreRecords)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: moreRecords EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.moreRecords = moreRecords),
            this.keyModified.set("more_records", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      CallBack: class {
        constructor() {
          (this.url = null),
            (this.method = null),
            (this.keyModified = new Map());
        }
        getUrl() {
          return this.url;
        }
        setUrl(url) {
          if (
            null != url &&
            "[object String]" != Object.prototype.toString.call(url)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: url EXPECTED TYPE: String",
              null,
              null
            );
          (this.url = url), this.keyModified.set("url", 1);
        }
        getMethod() {
          return this.method;
        }
        setMethod(method) {
          if (null != method && !(method instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: method EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.method = method), this.keyModified.set("method", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.data = null), (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ActionWrapper: class {
        constructor() {
          (this.data = null),
            (this.info = null),
            (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (
            null != info &&
            "[object Map]" != Object.prototype.toString.call(info)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Map",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      FileBodyWrapper: class {
        constructor() {
          (this.file = null), (this.keyModified = new Map());
        }
        getFile() {
          return this.file;
        }
        setFile(file) {
          if (
            null != file &&
            !(file instanceof StreamWrapper.Model.StreamWrapper)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: file EXPECTED TYPE: StreamWrapper",
              null,
              null
            );
          (this.file = file), this.keyModified.set("file", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
    },
    Operations: class {
      constructor() {}
      async getBulkReadJobDetails(jobId) {
        if ("[object BigInt]" != Object.prototype.toString.call(jobId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: jobId EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/crm/bulk/v2/read/")).concat(
            jobId.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "BulkRead.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async downloadResult(jobId) {
        if ("[object BigInt]" != Object.prototype.toString.call(jobId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: jobId EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/bulk/v2/read/")).concat(
            jobId.toString()
          )).concat("/result")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "BulkRead.Model.ResponseHandler",
            "application/x-download"
          )
        );
      }
      async createBulkReadJob(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.BulkRead.Model.RequestWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: RequestWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/bulk/v2/read")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "BulkRead.Model.ActionHandler",
            "application/json"
          )
        );
      }
    },
  });
class SDKConfigBuilder {
  constructor() {
    (this._autoRefreshFields = !1),
      (this._pickListValidation = !0),
      (this._cacheStore = !1),
      (this._timeout = 0);
  }
  autoRefreshFields(autoRefreshFields) {
    return (this._autoRefreshFields = autoRefreshFields), this;
  }
  pickListValidation(pickListValidation) {
    return (this._pickListValidation = pickListValidation), this;
  }
  cacheStore(cacheStore) {
    return (this._cacheStore = cacheStore), this;
  }
  timeout(timeout) {
    return (this._timeout = timeout > 0 ? timeout : 0), this;
  }
  build() {
    return new SDKConfig(
      this._autoRefreshFields,
      this._pickListValidation,
      this._cacheStore,
      this._timeout
    );
  }
}
class SDKConfig {
  constructor(autoRefreshFields, pickListValidation, cacheStore, timeout) {
    (this._autoRefreshFields = autoRefreshFields),
      (this._pickListValidation = pickListValidation),
      (this._cacheStore = cacheStore),
      (this._timeout = timeout);
  }
  getAutoRefreshFields() {
    return this._autoRefreshFields;
  }
  getPickListValidation() {
    return this._pickListValidation;
  }
  getCacheStore() {
    return this._cacheStore;
  }
  getTimeout() {
    return this._timeout;
  }
}
(ZCRM.Note = {
  Model: {
    ActionHandler: class {
      constructor() {}
    },
    ResponseHandler: class {
      constructor() {}
    },
    ActionResponse: class {
      constructor() {}
    },
    ActionWrapper: class {
      constructor() {
        (this.data = null), (this.keyModified = new Map());
      }
      getData() {
        return this.data;
      }
      setData(data) {
        if (
          null != data &&
          "[object Array]" != Object.prototype.toString.call(data)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: data EXPECTED TYPE: Array",
            null,
            null
          );
        (this.data = data), this.keyModified.set("data", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    SuccessResponse: class {
      constructor() {
        (this.code = null),
          (this.status = null),
          (this.message = null),
          (this.details = null),
          (this.keyModified = new Map());
      }
      getCode() {
        return this.code;
      }
      setCode(code) {
        if (null != code && !(code instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: code EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.code = code), this.keyModified.set("code", 1);
      }
      getStatus() {
        return this.status;
      }
      setStatus(status) {
        if (null != status && !(status instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: status EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.status = status), this.keyModified.set("status", 1);
      }
      getMessage() {
        return this.message;
      }
      setMessage(message) {
        if (null != message && !(message instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: message EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.message = message), this.keyModified.set("message", 1);
      }
      getDetails() {
        return this.details;
      }
      setDetails(details) {
        if (
          null != details &&
          "[object Map]" != Object.prototype.toString.call(details)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: details EXPECTED TYPE: Map",
            null,
            null
          );
        (this.details = details), this.keyModified.set("details", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    BodyWrapper: class {
      constructor() {
        (this.data = null), (this.keyModified = new Map());
      }
      getData() {
        return this.data;
      }
      setData(data) {
        if (
          null != data &&
          "[object Array]" != Object.prototype.toString.call(data)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: data EXPECTED TYPE: Array",
            null,
            null
          );
        (this.data = data), this.keyModified.set("data", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    APIException: class {
      constructor() {
        (this.status = null),
          (this.code = null),
          (this.message = null),
          (this.details = null),
          (this.keyModified = new Map());
      }
      getStatus() {
        return this.status;
      }
      setStatus(status) {
        if (null != status && !(status instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: status EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.status = status), this.keyModified.set("status", 1);
      }
      getCode() {
        return this.code;
      }
      setCode(code) {
        if (null != code && !(code instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: code EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.code = code), this.keyModified.set("code", 1);
      }
      getMessage() {
        return this.message;
      }
      setMessage(message) {
        if (null != message && !(message instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: message EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.message = message), this.keyModified.set("message", 1);
      }
      getDetails() {
        return this.details;
      }
      setDetails(details) {
        if (
          null != details &&
          "[object Map]" != Object.prototype.toString.call(details)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: details EXPECTED TYPE: Map",
            null,
            null
          );
        (this.details = details), this.keyModified.set("details", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    Info: class {
      constructor() {
        (this.perPage = null),
          (this.count = null),
          (this.page = null),
          (this.moreRecords = null),
          (this.keyModified = new Map());
      }
      getPerPage() {
        return this.perPage;
      }
      setPerPage(perPage) {
        if (
          null != perPage &&
          "[object Number]" != Object.prototype.toString.call(perPage)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: perPage EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.perPage = perPage), this.keyModified.set("per_page", 1);
      }
      getCount() {
        return this.count;
      }
      setCount(count) {
        if (
          null != count &&
          "[object Number]" != Object.prototype.toString.call(count)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: count EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.count = count), this.keyModified.set("count", 1);
      }
      getPage() {
        return this.page;
      }
      setPage(page) {
        if (
          null != page &&
          "[object Number]" != Object.prototype.toString.call(page)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: page EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.page = page), this.keyModified.set("page", 1);
      }
      getMoreRecords() {
        return this.moreRecords;
      }
      setMoreRecords(moreRecords) {
        if (
          null != moreRecords &&
          "[object Boolean]" != Object.prototype.toString.call(moreRecords)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moreRecords EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.moreRecords = moreRecords),
          this.keyModified.set("more_records", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    ResponseWrapper: class {
      constructor() {
        (this.data = null), (this.info = null), (this.keyModified = new Map());
      }
      getData() {
        return this.data;
      }
      setData(data) {
        if (
          null != data &&
          "[object Array]" != Object.prototype.toString.call(data)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: data EXPECTED TYPE: Array",
            null,
            null
          );
        (this.data = data), this.keyModified.set("data", 1);
      }
      getInfo() {
        return this.info;
      }
      setInfo(info) {
        if (null != info && !(info instanceof ZCRM.Note.Model.Info))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: info EXPECTED TYPE: Info",
            null,
            null
          );
        (this.info = info), this.keyModified.set("info", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    Note: class {
      constructor() {
        (this.owner = null),
          (this.modifiedTime = null),
          (this.attachments = null),
          (this.createdTime = null),
          (this.parentId = null),
          (this.editable = null),
          (this.seModule = null),
          (this.isSharedToClient = null),
          (this.modifiedBy = null),
          (this.size = null),
          (this.state = null),
          (this.voiceNote = null),
          (this.id = null),
          (this.createdBy = null),
          (this.noteTitle = null),
          (this.noteContent = null),
          (this.keyModified = new Map());
      }
      getOwner() {
        return this.owner;
      }
      setOwner(owner) {
        if (null != owner && !(owner instanceof ZCRM.User.Model.User))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: owner EXPECTED TYPE: User",
            null,
            null
          );
        (this.owner = owner), this.keyModified.set("Owner", 1);
      }
      getModifiedTime() {
        return this.modifiedTime;
      }
      setModifiedTime(modifiedTime) {
        if (null != modifiedTime && !(modifiedTime instanceof Date))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modifiedTime EXPECTED TYPE: Date",
            null,
            null
          );
        (this.modifiedTime = modifiedTime),
          this.keyModified.set("Modified_Time", 1);
      }
      getAttachments() {
        return this.attachments;
      }
      setAttachments(attachments) {
        if (
          null != attachments &&
          "[object Array]" != Object.prototype.toString.call(attachments)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: attachments EXPECTED TYPE: Array",
            null,
            null
          );
        (this.attachments = attachments),
          this.keyModified.set("$attachments", 1);
      }
      getCreatedTime() {
        return this.createdTime;
      }
      setCreatedTime(createdTime) {
        if (null != createdTime && !(createdTime instanceof Date))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: createdTime EXPECTED TYPE: Date",
            null,
            null
          );
        (this.createdTime = createdTime),
          this.keyModified.set("Created_Time", 1);
      }
      getParentId() {
        return this.parentId;
      }
      setParentId(parentId) {
        if (null != parentId && !(parentId instanceof ZCRM.Record.Model.Record))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: parentId EXPECTED TYPE: Record",
            null,
            null
          );
        (this.parentId = parentId), this.keyModified.set("Parent_Id", 1);
      }
      getEditable() {
        return this.editable;
      }
      setEditable(editable) {
        if (
          null != editable &&
          "[object Boolean]" != Object.prototype.toString.call(editable)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: editable EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.editable = editable), this.keyModified.set("$editable", 1);
      }
      getSeModule() {
        return this.seModule;
      }
      setSeModule(seModule) {
        if (
          null != seModule &&
          "[object String]" != Object.prototype.toString.call(seModule)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: seModule EXPECTED TYPE: String",
            null,
            null
          );
        (this.seModule = seModule), this.keyModified.set("$se_module", 1);
      }
      getIsSharedToClient() {
        return this.isSharedToClient;
      }
      setIsSharedToClient(isSharedToClient) {
        if (
          null != isSharedToClient &&
          "[object Boolean]" != Object.prototype.toString.call(isSharedToClient)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: isSharedToClient EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.isSharedToClient = isSharedToClient),
          this.keyModified.set("$is_shared_to_client", 1);
      }
      getModifiedBy() {
        return this.modifiedBy;
      }
      setModifiedBy(modifiedBy) {
        if (null != modifiedBy && !(modifiedBy instanceof ZCRM.User.Model.User))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modifiedBy EXPECTED TYPE: User",
            null,
            null
          );
        (this.modifiedBy = modifiedBy), this.keyModified.set("Modified_By", 1);
      }
      getSize() {
        return this.size;
      }
      setSize(size) {
        if (
          null != size &&
          "[object String]" != Object.prototype.toString.call(size)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: size EXPECTED TYPE: String",
            null,
            null
          );
        (this.size = size), this.keyModified.set("$size", 1);
      }
      getState() {
        return this.state;
      }
      setState(state) {
        if (
          null != state &&
          "[object String]" != Object.prototype.toString.call(state)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: state EXPECTED TYPE: String",
            null,
            null
          );
        (this.state = state), this.keyModified.set("$state", 1);
      }
      getVoiceNote() {
        return this.voiceNote;
      }
      setVoiceNote(voiceNote) {
        if (
          null != voiceNote &&
          "[object Boolean]" != Object.prototype.toString.call(voiceNote)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: voiceNote EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.voiceNote = voiceNote), this.keyModified.set("$voice_note", 1);
      }
      getId() {
        return this.id;
      }
      setId(id) {
        if (
          null != id &&
          "[object BigInt]" != Object.prototype.toString.call(id)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        (this.id = id), this.keyModified.set("id", 1);
      }
      getCreatedBy() {
        return this.createdBy;
      }
      setCreatedBy(createdBy) {
        if (null != createdBy && !(createdBy instanceof ZCRM.User.Model.User))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: createdBy EXPECTED TYPE: User",
            null,
            null
          );
        (this.createdBy = createdBy), this.keyModified.set("Created_By", 1);
      }
      getNoteTitle() {
        return this.noteTitle;
      }
      setNoteTitle(noteTitle) {
        if (
          null != noteTitle &&
          "[object String]" != Object.prototype.toString.call(noteTitle)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: noteTitle EXPECTED TYPE: String",
            null,
            null
          );
        (this.noteTitle = noteTitle), this.keyModified.set("Note_Title", 1);
      }
      getNoteContent() {
        return this.noteContent;
      }
      setNoteContent(noteContent) {
        if (
          null != noteContent &&
          "[object String]" != Object.prototype.toString.call(noteContent)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: noteContent EXPECTED TYPE: String",
            null,
            null
          );
        (this.noteContent = noteContent),
          this.keyModified.set("Note_Content", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    GetNotesHeader: {
      IF_MODIFIED_SINCE: new Header(
        "If-Modified-Since",
        "Note.Model.GetNotesHeader"
      ),
    },
    GetNoteParam: { FIELDS: new Param("fields", "Note.Model.GetNoteParam") },
    GetNoteHeader: {
      IF_MODIFIED_SINCE: new Header(
        "If-Modified-Since",
        "Note.Model.GetNoteHeader"
      ),
    },
    GetNotesParam: {
      PAGE: new Param("page", "Note.Model.GetNotesParam"),
      PER_PAGE: new Param("per_page", "Note.Model.GetNotesParam"),
      FIELDS: new Param("fields", "Note.Model.GetNotesParam"),
    },
    DeleteNotesParam: { IDS: new Param("ids", "Note.Model.DeleteNotesParam") },
  },
  Operations: class {
    constructor() {}
    async getNotes(paramInstance = null, headerInstance = null) {
      if (null != paramInstance && !(paramInstance instanceof ParameterMap))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: paramInstance EXPECTED TYPE: ParameterMap",
          null,
          null
        );
      if (null != headerInstance && !(headerInstance instanceof HeaderMap))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: headerInstance EXPECTED TYPE: HeaderMap",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/Notes")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
        handlerInstance.setParam(paramInstance),
        handlerInstance.setHeader(headerInstance),
        handlerInstance.apiCall(
          "Note.Model.ResponseHandler",
          "application/json"
        )
      );
    }
    async createNotes(request) {
      if (null != request && !(request instanceof ZCRM.Note.Model.BodyWrapper))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: request EXPECTED TYPE: BodyWrapper",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/Notes")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
        handlerInstance.setContentType("application/json"),
        handlerInstance.setRequest(request),
        handlerInstance.setMandatoryChecker(!0),
        handlerInstance.apiCall("Note.Model.ActionHandler", "application/json")
      );
    }
    async updateNotes(request) {
      if (null != request && !(request instanceof ZCRM.Note.Model.BodyWrapper))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: request EXPECTED TYPE: BodyWrapper",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/Notes")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
        handlerInstance.setContentType("application/json"),
        handlerInstance.setRequest(request),
        handlerInstance.setMandatoryChecker(!0),
        handlerInstance.apiCall("Note.Model.ActionHandler", "application/json")
      );
    }
    async deleteNotes(paramInstance = null) {
      if (null != paramInstance && !(paramInstance instanceof ParameterMap))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: paramInstance EXPECTED TYPE: ParameterMap",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/Notes")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
        handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
        handlerInstance.setParam(paramInstance),
        handlerInstance.apiCall("Note.Model.ActionHandler", "application/json")
      );
    }
    async getNote(id, paramInstance = null, headerInstance = null) {
      if ("[object BigInt]" != Object.prototype.toString.call(id))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: id EXPECTED TYPE: BigInt",
          null,
          null
        );
      if (null != paramInstance && !(paramInstance instanceof ParameterMap))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: paramInstance EXPECTED TYPE: ParameterMap",
          null,
          null
        );
      if (null != headerInstance && !(headerInstance instanceof HeaderMap))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: headerInstance EXPECTED TYPE: HeaderMap",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = (apiPath = apiPath.concat("/crm/v2/Notes/")).concat(
          id.toString()
        )),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
        handlerInstance.setParam(paramInstance),
        handlerInstance.setHeader(headerInstance),
        handlerInstance.apiCall(
          "Note.Model.ResponseHandler",
          "application/json"
        )
      );
    }
    async updateNote(id, request) {
      if ("[object BigInt]" != Object.prototype.toString.call(id))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: id EXPECTED TYPE: BigInt",
          null,
          null
        );
      if (null != request && !(request instanceof ZCRM.Note.Model.BodyWrapper))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: request EXPECTED TYPE: BodyWrapper",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = (apiPath = apiPath.concat("/crm/v2/Notes/")).concat(
          id.toString()
        )),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
        handlerInstance.setContentType("application/json"),
        handlerInstance.setRequest(request),
        handlerInstance.apiCall("Note.Model.ActionHandler", "application/json")
      );
    }
    async deleteNote(id) {
      if ("[object BigInt]" != Object.prototype.toString.call(id))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: id EXPECTED TYPE: BigInt",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = (apiPath = apiPath.concat("/crm/v2/Notes/")).concat(
          id.toString()
        )),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
        handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
        handlerInstance.apiCall("Note.Model.ActionHandler", "application/json")
      );
    }
  },
}),
  (ZCRM.VariableGroup = {
    Model: {
      ResponseHandler: class {
        constructor() {}
      },
      ResponseWrapper: class {
        constructor() {
          (this.variableGroups = null), (this.keyModified = new Map());
        }
        getVariableGroups() {
          return this.variableGroups;
        }
        setVariableGroups(variableGroups) {
          if (
            null != variableGroups &&
            "[object Array]" != Object.prototype.toString.call(variableGroups)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: variableGroups EXPECTED TYPE: Array",
              null,
              null
            );
          (this.variableGroups = variableGroups),
            this.keyModified.set("variable_groups", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      VariableGroup: class {
        constructor() {
          (this.displayLabel = null),
            (this.apiName = null),
            (this.name = null),
            (this.description = null),
            (this.id = null),
            (this.keyModified = new Map());
        }
        getDisplayLabel() {
          return this.displayLabel;
        }
        setDisplayLabel(displayLabel) {
          if (
            null != displayLabel &&
            "[object String]" != Object.prototype.toString.call(displayLabel)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: displayLabel EXPECTED TYPE: String",
              null,
              null
            );
          (this.displayLabel = displayLabel),
            this.keyModified.set("display_label", 1);
        }
        getAPIName() {
          return this.apiName;
        }
        setAPIName(apiName) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          (this.apiName = apiName), this.keyModified.set("api_name", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getDescription() {
          return this.description;
        }
        setDescription(description) {
          if (
            null != description &&
            "[object String]" != Object.prototype.toString.call(description)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: description EXPECTED TYPE: String",
              null,
              null
            );
          (this.description = description),
            this.keyModified.set("description", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.code = null),
            (this.status = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
    },
    Operations: class {
      constructor() {}
      async getVariableGroups() {
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/variable_groups")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "VariableGroup.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async getVariableGroupById(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/variable_groups/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "VariableGroup.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async getVariableGroupByAPIName(apiName) {
        if ("[object String]" != Object.prototype.toString.call(apiName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: apiName EXPECTED TYPE: String",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/variable_groups/"
          )).concat(apiName.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "VariableGroup.Model.ResponseHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.ContactRole = {
    Model: {
      ResponseHandler: class {
        constructor() {}
      },
      RecordResponseHandler: class {
        constructor() {}
      },
      ActionResponse: class {
        constructor() {}
      },
      ActionHandler: class {
        constructor() {}
      },
      RecordActionHandler: class {
        constructor() {}
      },
      ResponseWrapper: class {
        constructor() {
          (this.contactRoles = null), (this.keyModified = new Map());
        }
        getContactRoles() {
          return this.contactRoles;
        }
        setContactRoles(contactRoles) {
          if (
            null != contactRoles &&
            "[object Array]" != Object.prototype.toString.call(contactRoles)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: contactRoles EXPECTED TYPE: Array",
              null,
              null
            );
          (this.contactRoles = contactRoles),
            this.keyModified.set("contact_roles", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RecordBodyWrapper: class {
        constructor() {
          (this.data = null), (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.contactRoles = null), (this.keyModified = new Map());
        }
        getContactRoles() {
          return this.contactRoles;
        }
        setContactRoles(contactRoles) {
          if (
            null != contactRoles &&
            "[object Array]" != Object.prototype.toString.call(contactRoles)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: contactRoles EXPECTED TYPE: Array",
              null,
              null
            );
          (this.contactRoles = contactRoles),
            this.keyModified.set("contact_roles", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RecordActionWrapper: class {
        constructor() {
          (this.data = null), (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ContactRoleWrapper: class {
        constructor() {
          (this.contactRole = null), (this.keyModified = new Map());
        }
        getContactRole() {
          return this.contactRole;
        }
        setContactRole(contactRole) {
          if (
            null != contactRole &&
            "[object String]" != Object.prototype.toString.call(contactRole)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: contactRole EXPECTED TYPE: String",
              null,
              null
            );
          (this.contactRole = contactRole),
            this.keyModified.set("Contact_Role", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RecordResponseWrapper: class {
        constructor() {
          (this.data = null),
            (this.info = null),
            (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (null != info && !(info instanceof ZCRM.Record.Model.Info))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Info",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ActionWrapper: class {
        constructor() {
          (this.contactRoles = null), (this.keyModified = new Map());
        }
        getContactRoles() {
          return this.contactRoles;
        }
        setContactRoles(contactRoles) {
          if (
            null != contactRoles &&
            "[object Array]" != Object.prototype.toString.call(contactRoles)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: contactRoles EXPECTED TYPE: Array",
              null,
              null
            );
          (this.contactRoles = contactRoles),
            this.keyModified.set("contact_roles", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ContactRole: class {
        constructor() {
          (this.id = null),
            (this.name = null),
            (this.sequenceNumber = null),
            (this.keyModified = new Map());
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getSequenceNumber() {
          return this.sequenceNumber;
        }
        setSequenceNumber(sequenceNumber) {
          if (
            null != sequenceNumber &&
            "[object Number]" != Object.prototype.toString.call(sequenceNumber)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sequenceNumber EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.sequenceNumber = sequenceNumber),
            this.keyModified.set("sequence_number", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      DeleteContactRolesParam: {
        IDS: new Param("ids", "ContactRole.Model.DeleteContactRolesParam"),
      },
      GetAllContactRolesOfDealParam: {
        IDS: new Param(
          "ids",
          "ContactRole.Model.GetAllContactRolesOfDealParam"
        ),
      },
    },
    Operations: class {
      constructor() {}
      async getContactRoles() {
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/Contacts/roles")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "ContactRole.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async createContactRoles(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.ContactRole.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/Contacts/roles")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "ContactRole.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async updateContactRoles(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.ContactRole.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/Contacts/roles")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "ContactRole.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async deleteContactRoles(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/Contacts/roles")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "ContactRole.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getContactRole(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/Contacts/roles/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "ContactRole.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateContactRole(id, request) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.ContactRole.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/Contacts/roles/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.apiCall(
            "ContactRole.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async deleteContactRole(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/Contacts/roles/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.apiCall(
            "ContactRole.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getAllContactRolesOfDeal(dealId, paramInstance = null) {
        if ("[object BigInt]" != Object.prototype.toString.call(dealId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: dealId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/Deals/")).concat(dealId.toString())).concat(
            "/Contact_Roles"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setModuleAPIName("Contacts"),
          await Utility.getFields("Contacts", handlerInstance),
          handlerInstance.apiCall(
            "ContactRole.Model.RecordResponseHandler",
            "application/json"
          )
        );
      }
      async getContactRoleOfDeal(contactId, dealId) {
        if ("[object BigInt]" != Object.prototype.toString.call(contactId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: contactId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object BigInt]" != Object.prototype.toString.call(dealId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: dealId EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/Deals/")).concat(dealId.toString())).concat(
            "/Contact_Roles/"
          )).concat(contactId.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setModuleAPIName("Contacts"),
          await Utility.getFields("Contacts", handlerInstance),
          handlerInstance.apiCall(
            "ContactRole.Model.RecordResponseHandler",
            "application/json"
          )
        );
      }
      async addContactRoleToDeal(contactId, dealId, request) {
        if ("[object BigInt]" != Object.prototype.toString.call(contactId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: contactId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object BigInt]" != Object.prototype.toString.call(dealId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: dealId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.ContactRole.Model.RecordBodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: RecordBodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/Deals/")).concat(dealId.toString())).concat(
            "/Contact_Roles/"
          )).concat(contactId.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.apiCall(
            "ContactRole.Model.RecordActionHandler",
            "application/json"
          )
        );
      }
      async removeContactRoleFromDeal(contactId, dealId) {
        if ("[object BigInt]" != Object.prototype.toString.call(contactId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: contactId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object BigInt]" != Object.prototype.toString.call(dealId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: dealId EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/Deals/")).concat(dealId.toString())).concat(
            "/Contact_Roles/"
          )).concat(contactId.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.apiCall(
            "ContactRole.Model.RecordActionHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.Layout = {
    Model: {
      ResponseHandler: class {
        constructor() {}
      },
      ResponseWrapper: class {
        constructor() {
          (this.layouts = null), (this.keyModified = new Map());
        }
        getLayouts() {
          return this.layouts;
        }
        setLayouts(layouts) {
          if (
            null != layouts &&
            "[object Array]" != Object.prototype.toString.call(layouts)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: layouts EXPECTED TYPE: Array",
              null,
              null
            );
          (this.layouts = layouts), this.keyModified.set("layouts", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Section: class {
        constructor() {
          (this.displayLabel = null),
            (this.sequenceNumber = null),
            (this.issubformsection = null),
            (this.tabTraversal = null),
            (this.apiName = null),
            (this.columnCount = null),
            (this.name = null),
            (this.generatedType = null),
            (this.fields = null),
            (this.properties = null),
            (this.keyModified = new Map());
        }
        getDisplayLabel() {
          return this.displayLabel;
        }
        setDisplayLabel(displayLabel) {
          if (
            null != displayLabel &&
            "[object String]" != Object.prototype.toString.call(displayLabel)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: displayLabel EXPECTED TYPE: String",
              null,
              null
            );
          (this.displayLabel = displayLabel),
            this.keyModified.set("display_label", 1);
        }
        getSequenceNumber() {
          return this.sequenceNumber;
        }
        setSequenceNumber(sequenceNumber) {
          if (
            null != sequenceNumber &&
            "[object Number]" != Object.prototype.toString.call(sequenceNumber)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sequenceNumber EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.sequenceNumber = sequenceNumber),
            this.keyModified.set("sequence_number", 1);
        }
        getIssubformsection() {
          return this.issubformsection;
        }
        setIssubformsection(issubformsection) {
          if (
            null != issubformsection &&
            "[object Boolean]" !=
              Object.prototype.toString.call(issubformsection)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: issubformsection EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.issubformsection = issubformsection),
            this.keyModified.set("isSubformSection", 1);
        }
        getTabTraversal() {
          return this.tabTraversal;
        }
        setTabTraversal(tabTraversal) {
          if (
            null != tabTraversal &&
            "[object Number]" != Object.prototype.toString.call(tabTraversal)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: tabTraversal EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.tabTraversal = tabTraversal),
            this.keyModified.set("tab_traversal", 1);
        }
        getAPIName() {
          return this.apiName;
        }
        setAPIName(apiName) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          (this.apiName = apiName), this.keyModified.set("api_name", 1);
        }
        getColumnCount() {
          return this.columnCount;
        }
        setColumnCount(columnCount) {
          if (
            null != columnCount &&
            "[object Number]" != Object.prototype.toString.call(columnCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: columnCount EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.columnCount = columnCount),
            this.keyModified.set("column_count", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getGeneratedType() {
          return this.generatedType;
        }
        setGeneratedType(generatedType) {
          if (
            null != generatedType &&
            "[object String]" != Object.prototype.toString.call(generatedType)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: generatedType EXPECTED TYPE: String",
              null,
              null
            );
          (this.generatedType = generatedType),
            this.keyModified.set("generated_type", 1);
        }
        getFields() {
          return this.fields;
        }
        setFields(fields) {
          if (
            null != fields &&
            "[object Array]" != Object.prototype.toString.call(fields)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fields EXPECTED TYPE: Array",
              null,
              null
            );
          (this.fields = fields), this.keyModified.set("fields", 1);
        }
        getProperties() {
          return this.properties;
        }
        setProperties(properties) {
          if (
            null != properties &&
            !(properties instanceof ZCRM.Layout.Model.Properties)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: properties EXPECTED TYPE: Properties",
              null,
              null
            );
          (this.properties = properties), this.keyModified.set("properties", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Properties: class {
        constructor() {
          (this.reorderRows = null),
            (this.tooltip = null),
            (this.maximumRows = null),
            (this.keyModified = new Map());
        }
        getReorderRows() {
          return this.reorderRows;
        }
        setReorderRows(reorderRows) {
          if (
            null != reorderRows &&
            "[object Boolean]" != Object.prototype.toString.call(reorderRows)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: reorderRows EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.reorderRows = reorderRows),
            this.keyModified.set("reorder_rows", 1);
        }
        getTooltip() {
          return this.tooltip;
        }
        setTooltip(tooltip) {
          if (null != tooltip && !(tooltip instanceof ZCRM.Field.Model.ToolTip))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: tooltip EXPECTED TYPE: ToolTip",
              null,
              null
            );
          (this.tooltip = tooltip), this.keyModified.set("tooltip", 1);
        }
        getMaximumRows() {
          return this.maximumRows;
        }
        setMaximumRows(maximumRows) {
          if (
            null != maximumRows &&
            "[object Number]" != Object.prototype.toString.call(maximumRows)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: maximumRows EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.maximumRows = maximumRows),
            this.keyModified.set("maximum_rows", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Layout: class {
        constructor() {
          (this.createdTime = null),
            (this.convertMapping = null),
            (this.modifiedTime = null),
            (this.visible = null),
            (this.createdFor = null),
            (this.name = null),
            (this.modifiedBy = null),
            (this.profiles = null),
            (this.id = null),
            (this.createdBy = null),
            (this.sections = null),
            (this.status = null),
            (this.keyModified = new Map());
        }
        getCreatedTime() {
          return this.createdTime;
        }
        setCreatedTime(createdTime) {
          if (null != createdTime && !(createdTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.createdTime = createdTime),
            this.keyModified.set("created_time", 1);
        }
        getConvertMapping() {
          return this.convertMapping;
        }
        setConvertMapping(convertMapping) {
          if (
            null != convertMapping &&
            "[object Map]" != Object.prototype.toString.call(convertMapping)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: convertMapping EXPECTED TYPE: Map",
              null,
              null
            );
          (this.convertMapping = convertMapping),
            this.keyModified.set("convert_mapping", 1);
        }
        getModifiedTime() {
          return this.modifiedTime;
        }
        setModifiedTime(modifiedTime) {
          if (null != modifiedTime && !(modifiedTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.modifiedTime = modifiedTime),
            this.keyModified.set("modified_time", 1);
        }
        getVisible() {
          return this.visible;
        }
        setVisible(visible) {
          if (
            null != visible &&
            "[object Boolean]" != Object.prototype.toString.call(visible)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: visible EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.visible = visible), this.keyModified.set("visible", 1);
        }
        getCreatedFor() {
          return this.createdFor;
        }
        setCreatedFor(createdFor) {
          if (
            null != createdFor &&
            !(createdFor instanceof ZCRM.User.Model.User)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdFor EXPECTED TYPE: User",
              null,
              null
            );
          (this.createdFor = createdFor),
            this.keyModified.set("created_for", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getModifiedBy() {
          return this.modifiedBy;
        }
        setModifiedBy(modifiedBy) {
          if (
            null != modifiedBy &&
            !(modifiedBy instanceof ZCRM.User.Model.User)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.modifiedBy = modifiedBy),
            this.keyModified.set("modified_by", 1);
        }
        getProfiles() {
          return this.profiles;
        }
        setProfiles(profiles) {
          if (
            null != profiles &&
            "[object Array]" != Object.prototype.toString.call(profiles)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: profiles EXPECTED TYPE: Array",
              null,
              null
            );
          (this.profiles = profiles), this.keyModified.set("profiles", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getCreatedBy() {
          return this.createdBy;
        }
        setCreatedBy(createdBy) {
          if (null != createdBy && !(createdBy instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.createdBy = createdBy), this.keyModified.set("created_by", 1);
        }
        getSections() {
          return this.sections;
        }
        setSections(sections) {
          if (
            null != sections &&
            "[object Array]" != Object.prototype.toString.call(sections)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sections EXPECTED TYPE: Array",
              null,
              null
            );
          (this.sections = sections), this.keyModified.set("sections", 1);
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (
            null != status &&
            "[object Number]" != Object.prototype.toString.call(status)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      GetLayoutsParam: {},
      GetLayoutParam: {},
    },
    Operations: class {
      constructor(module = null) {
        if (
          null != module &&
          "[object String]" != Object.prototype.toString.call(module)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: module EXPECTED TYPE: String",
            null,
            null
          );
        this.module = module;
      }
      async getLayouts() {
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/layouts")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addParam(
            new Param("module", "Layout.Model.GetLayoutsParam"),
            this.module
          ),
          handlerInstance.apiCall(
            "Layout.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async getLayout(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/layouts/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addParam(
            new Param("module", "Layout.Model.GetLayoutParam"),
            this.module
          ),
          handlerInstance.apiCall(
            "Layout.Model.ResponseHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.Variable = {
    Model: {
      ActionHandler: class {
        constructor() {}
      },
      ActionResponse: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      ResponseWrapper: class {
        constructor() {
          (this.variables = null), (this.keyModified = new Map());
        }
        getVariables() {
          return this.variables;
        }
        setVariables(variables) {
          if (
            null != variables &&
            "[object Array]" != Object.prototype.toString.call(variables)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: variables EXPECTED TYPE: Array",
              null,
              null
            );
          (this.variables = variables), this.keyModified.set("variables", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.variables = null), (this.keyModified = new Map());
        }
        getVariables() {
          return this.variables;
        }
        setVariables(variables) {
          if (
            null != variables &&
            "[object Array]" != Object.prototype.toString.call(variables)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: variables EXPECTED TYPE: Array",
              null,
              null
            );
          (this.variables = variables), this.keyModified.set("variables", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Variable: class {
        constructor() {
          (this.apiName = null),
            (this.name = null),
            (this.description = null),
            (this.id = null),
            (this.type = null),
            (this.variableGroup = null),
            (this.value = null),
            (this.keyModified = new Map());
        }
        getAPIName() {
          return this.apiName;
        }
        setAPIName(apiName) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          (this.apiName = apiName), this.keyModified.set("api_name", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getDescription() {
          return this.description;
        }
        setDescription(description) {
          if (
            null != description &&
            "[object String]" != Object.prototype.toString.call(description)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: description EXPECTED TYPE: String",
              null,
              null
            );
          (this.description = description),
            this.keyModified.set("description", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getType() {
          return this.type;
        }
        setType(type) {
          if (
            null != type &&
            "[object String]" != Object.prototype.toString.call(type)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: type EXPECTED TYPE: String",
              null,
              null
            );
          (this.type = type), this.keyModified.set("type", 1);
        }
        getVariableGroup() {
          return this.variableGroup;
        }
        setVariableGroup(variableGroup) {
          if (
            null != variableGroup &&
            !(variableGroup instanceof ZCRM.VariableGroup.Model.VariableGroup)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: variableGroup EXPECTED TYPE: VariableGroup",
              null,
              null
            );
          (this.variableGroup = variableGroup),
            this.keyModified.set("variable_group", 1);
        }
        getValue() {
          return this.value;
        }
        setValue(value) {
          (this.value = value), this.keyModified.set("value", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ActionWrapper: class {
        constructor() {
          (this.variables = null), (this.keyModified = new Map());
        }
        getVariables() {
          return this.variables;
        }
        setVariables(variables) {
          if (
            null != variables &&
            "[object Array]" != Object.prototype.toString.call(variables)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: variables EXPECTED TYPE: Array",
              null,
              null
            );
          (this.variables = variables), this.keyModified.set("variables", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      GetVariableByIDParam: {
        GROUP: new Param("group", "Variable.Model.GetVariableByIDParam"),
      },
      DeleteVariablesParam: {
        IDS: new Param("ids", "Variable.Model.DeleteVariablesParam"),
      },
      GetVariableForAPINameParam: {
        GROUP: new Param("group", "Variable.Model.GetVariableForAPINameParam"),
      },
      GetVariablesParam: {
        GROUP: new Param("group", "Variable.Model.GetVariablesParam"),
      },
    },
    Operations: class {
      constructor() {}
      async getVariables(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/variables")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Variable.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async createVariables(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.Variable.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/variables")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "Variable.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async updateVariables(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.Variable.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/variables")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "Variable.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async deleteVariables(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/variables")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Variable.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getVariableById(id, paramInstance = null) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/variables/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Variable.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateVariableById(id, request) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Variable.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/variables/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.apiCall(
            "Variable.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async deleteVariable(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/variables/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.apiCall(
            "Variable.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getVariableForAPIName(apiName, paramInstance = null) {
        if ("[object String]" != Object.prototype.toString.call(apiName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: apiName EXPECTED TYPE: String",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/variables/"
          )).concat(apiName.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Variable.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateVariableByAPIName(apiName, request) {
        if ("[object String]" != Object.prototype.toString.call(apiName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: apiName EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Variable.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/variables/"
          )).concat(apiName.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.apiCall(
            "Variable.Model.ActionHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.Tax = {
    Model: {
      ActionResponse: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      ActionHandler: class {
        constructor() {}
      },
      Preference: class {
        constructor() {
          (this.autoPopulateTax = null),
            (this.modifyTaxRates = null),
            (this.keyModified = new Map());
        }
        getAutoPopulateTax() {
          return this.autoPopulateTax;
        }
        setAutoPopulateTax(autoPopulateTax) {
          if (
            null != autoPopulateTax &&
            "[object Boolean]" !=
              Object.prototype.toString.call(autoPopulateTax)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: autoPopulateTax EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.autoPopulateTax = autoPopulateTax),
            this.keyModified.set("auto_populate_tax", 1);
        }
        getModifyTaxRates() {
          return this.modifyTaxRates;
        }
        setModifyTaxRates(modifyTaxRates) {
          if (
            null != modifyTaxRates &&
            "[object Boolean]" != Object.prototype.toString.call(modifyTaxRates)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifyTaxRates EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.modifyTaxRates = modifyTaxRates),
            this.keyModified.set("modify_tax_rates", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ActionWrapper: class {
        constructor() {
          (this.taxes = null), (this.keyModified = new Map());
        }
        getTaxes() {
          return this.taxes;
        }
        setTaxes(taxes) {
          if (
            null != taxes &&
            "[object Array]" != Object.prototype.toString.call(taxes)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: taxes EXPECTED TYPE: Array",
              null,
              null
            );
          (this.taxes = taxes), this.keyModified.set("taxes", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.taxes = null),
            (this.preference = null),
            (this.keyModified = new Map());
        }
        getTaxes() {
          return this.taxes;
        }
        setTaxes(taxes) {
          if (
            null != taxes &&
            "[object Array]" != Object.prototype.toString.call(taxes)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: taxes EXPECTED TYPE: Array",
              null,
              null
            );
          (this.taxes = taxes), this.keyModified.set("taxes", 1);
        }
        getPreference() {
          return this.preference;
        }
        setPreference(preference) {
          if (
            null != preference &&
            !(preference instanceof ZCRM.Tax.Model.Preference)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: preference EXPECTED TYPE: Preference",
              null,
              null
            );
          (this.preference = preference), this.keyModified.set("preference", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.taxes = null), (this.keyModified = new Map());
        }
        getTaxes() {
          return this.taxes;
        }
        setTaxes(taxes) {
          if (
            null != taxes &&
            "[object Array]" != Object.prototype.toString.call(taxes)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: taxes EXPECTED TYPE: Array",
              null,
              null
            );
          (this.taxes = taxes), this.keyModified.set("taxes", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Tax: class {
        constructor() {
          (this.displayLabel = null),
            (this.name = null),
            (this.id = null),
            (this.value = null),
            (this.sequenceNumber = null),
            (this.keyModified = new Map());
        }
        getDisplayLabel() {
          return this.displayLabel;
        }
        setDisplayLabel(displayLabel) {
          if (
            null != displayLabel &&
            "[object String]" != Object.prototype.toString.call(displayLabel)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: displayLabel EXPECTED TYPE: String",
              null,
              null
            );
          (this.displayLabel = displayLabel),
            this.keyModified.set("display_label", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getValue() {
          return this.value;
        }
        setValue(value) {
          if (
            null != value &&
            "[object Number]" != Object.prototype.toString.call(value)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: value EXPECTED TYPE: Float",
              null,
              null
            );
          (this.value = value), this.keyModified.set("value", 1);
        }
        getSequenceNumber() {
          return this.sequenceNumber;
        }
        setSequenceNumber(sequenceNumber) {
          if (
            null != sequenceNumber &&
            "[object Number]" != Object.prototype.toString.call(sequenceNumber)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sequenceNumber EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.sequenceNumber = sequenceNumber),
            this.keyModified.set("sequence_number", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      DeleteTaxesParam: { IDS: new Param("ids", "Tax.Model.DeleteTaxesParam") },
    },
    Operations: class {
      constructor() {}
      async getTaxes() {
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/org/taxes")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "Tax.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async createTaxes(request) {
        if (null != request && !(request instanceof ZCRM.Tax.Model.BodyWrapper))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/org/taxes")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall("Tax.Model.ActionHandler", "application/json")
        );
      }
      async updateTaxes(request) {
        if (null != request && !(request instanceof ZCRM.Tax.Model.BodyWrapper))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/org/taxes")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall("Tax.Model.ActionHandler", "application/json")
        );
      }
      async deleteTaxes(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/org/taxes")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall("Tax.Model.ActionHandler", "application/json")
        );
      }
      async getTax(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/crm/v2/org/taxes/")).concat(
            id.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "Tax.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async deleteTax(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/crm/v2/org/taxes/")).concat(
            id.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.apiCall("Tax.Model.ActionHandler", "application/json")
        );
      }
    },
  }),
  (ZCRM.User = {
    Model: {
      ActionResponse: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      ActionHandler: class {
        constructor() {}
      },
      ActionWrapper: class {
        constructor() {
          (this.users = null), (this.keyModified = new Map());
        }
        getUsers() {
          return this.users;
        }
        setUsers(users) {
          if (
            null != users &&
            "[object Array]" != Object.prototype.toString.call(users)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: users EXPECTED TYPE: Array",
              null,
              null
            );
          (this.users = users), this.keyModified.set("users", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.users = null),
            (this.info = null),
            (this.keyModified = new Map());
        }
        getUsers() {
          return this.users;
        }
        setUsers(users) {
          if (
            null != users &&
            "[object Array]" != Object.prototype.toString.call(users)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: users EXPECTED TYPE: Array",
              null,
              null
            );
          (this.users = users), this.keyModified.set("users", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (null != info && !(info instanceof ZCRM.User.Model.Info))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Info",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Territory: class {
        constructor() {
          (this.manager = null),
            (this.name = null),
            (this.id = null),
            (this.keyModified = new Map());
        }
        getManager() {
          return this.manager;
        }
        setManager(manager) {
          if (
            null != manager &&
            "[object Boolean]" != Object.prototype.toString.call(manager)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: manager EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.manager = manager), this.keyModified.set("manager", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      CustomizeInfo: class {
        constructor() {
          (this.notesDesc = null),
            (this.showRightPanel = null),
            (this.bcView = null),
            (this.showHome = null),
            (this.showDetailView = null),
            (this.unpinRecentItem = null),
            (this.keyModified = new Map());
        }
        getNotesDesc() {
          return this.notesDesc;
        }
        setNotesDesc(notesDesc) {
          if (
            null != notesDesc &&
            "[object Boolean]" != Object.prototype.toString.call(notesDesc)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: notesDesc EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.notesDesc = notesDesc), this.keyModified.set("notes_desc", 1);
        }
        getShowRightPanel() {
          return this.showRightPanel;
        }
        setShowRightPanel(showRightPanel) {
          if (
            null != showRightPanel &&
            "[object String]" != Object.prototype.toString.call(showRightPanel)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: showRightPanel EXPECTED TYPE: String",
              null,
              null
            );
          (this.showRightPanel = showRightPanel),
            this.keyModified.set("show_right_panel", 1);
        }
        getBcView() {
          return this.bcView;
        }
        setBcView(bcView) {
          if (
            null != bcView &&
            "[object String]" != Object.prototype.toString.call(bcView)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: bcView EXPECTED TYPE: String",
              null,
              null
            );
          (this.bcView = bcView), this.keyModified.set("bc_view", 1);
        }
        getShowHome() {
          return this.showHome;
        }
        setShowHome(showHome) {
          if (
            null != showHome &&
            "[object Boolean]" != Object.prototype.toString.call(showHome)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: showHome EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.showHome = showHome), this.keyModified.set("show_home", 1);
        }
        getShowDetailView() {
          return this.showDetailView;
        }
        setShowDetailView(showDetailView) {
          if (
            null != showDetailView &&
            "[object Boolean]" != Object.prototype.toString.call(showDetailView)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: showDetailView EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.showDetailView = showDetailView),
            this.keyModified.set("show_detail_view", 1);
        }
        getUnpinRecentItem() {
          return this.unpinRecentItem;
        }
        setUnpinRecentItem(unpinRecentItem) {
          if (
            null != unpinRecentItem &&
            "[object String]" != Object.prototype.toString.call(unpinRecentItem)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: unpinRecentItem EXPECTED TYPE: String",
              null,
              null
            );
          (this.unpinRecentItem = unpinRecentItem),
            this.keyModified.set("unpin_recent_item", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Theme: class {
        constructor() {
          (this.normalTab = null),
            (this.selectedTab = null),
            (this.newBackground = null),
            (this.background = null),
            (this.screen = null),
            (this.type = null),
            (this.keyModified = new Map());
        }
        getNormalTab() {
          return this.normalTab;
        }
        setNormalTab(normalTab) {
          if (
            null != normalTab &&
            !(normalTab instanceof ZCRM.User.Model.TabTheme)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: normalTab EXPECTED TYPE: TabTheme",
              null,
              null
            );
          (this.normalTab = normalTab), this.keyModified.set("normal_tab", 1);
        }
        getSelectedTab() {
          return this.selectedTab;
        }
        setSelectedTab(selectedTab) {
          if (
            null != selectedTab &&
            !(selectedTab instanceof ZCRM.User.Model.TabTheme)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: selectedTab EXPECTED TYPE: TabTheme",
              null,
              null
            );
          (this.selectedTab = selectedTab),
            this.keyModified.set("selected_tab", 1);
        }
        getNewBackground() {
          return this.newBackground;
        }
        setNewBackground(newBackground) {
          if (
            null != newBackground &&
            "[object String]" != Object.prototype.toString.call(newBackground)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: newBackground EXPECTED TYPE: String",
              null,
              null
            );
          (this.newBackground = newBackground),
            this.keyModified.set("new_background", 1);
        }
        getBackground() {
          return this.background;
        }
        setBackground(background) {
          if (
            null != background &&
            "[object String]" != Object.prototype.toString.call(background)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: background EXPECTED TYPE: String",
              null,
              null
            );
          (this.background = background), this.keyModified.set("background", 1);
        }
        getScreen() {
          return this.screen;
        }
        setScreen(screen) {
          if (
            null != screen &&
            "[object String]" != Object.prototype.toString.call(screen)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: screen EXPECTED TYPE: String",
              null,
              null
            );
          (this.screen = screen), this.keyModified.set("screen", 1);
        }
        getType() {
          return this.type;
        }
        setType(type) {
          if (
            null != type &&
            "[object String]" != Object.prototype.toString.call(type)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: type EXPECTED TYPE: String",
              null,
              null
            );
          (this.type = type), this.keyModified.set("type", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.users = null), (this.keyModified = new Map());
        }
        getUsers() {
          return this.users;
        }
        setUsers(users) {
          if (
            null != users &&
            "[object Array]" != Object.prototype.toString.call(users)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: users EXPECTED TYPE: Array",
              null,
              null
            );
          (this.users = users), this.keyModified.set("users", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Info: class {
        constructor() {
          (this.perPage = null),
            (this.count = null),
            (this.page = null),
            (this.moreRecords = null),
            (this.keyModified = new Map());
        }
        getPerPage() {
          return this.perPage;
        }
        setPerPage(perPage) {
          if (
            null != perPage &&
            "[object Number]" != Object.prototype.toString.call(perPage)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: perPage EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.perPage = perPage), this.keyModified.set("per_page", 1);
        }
        getCount() {
          return this.count;
        }
        setCount(count) {
          if (
            null != count &&
            "[object Number]" != Object.prototype.toString.call(count)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: count EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.count = count), this.keyModified.set("count", 1);
        }
        getPage() {
          return this.page;
        }
        setPage(page) {
          if (
            null != page &&
            "[object Number]" != Object.prototype.toString.call(page)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: page EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.page = page), this.keyModified.set("page", 1);
        }
        getMoreRecords() {
          return this.moreRecords;
        }
        setMoreRecords(moreRecords) {
          if (
            null != moreRecords &&
            "[object Boolean]" != Object.prototype.toString.call(moreRecords)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: moreRecords EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.moreRecords = moreRecords),
            this.keyModified.set("more_records", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Shift: class {
        constructor() {
          (this.id = null), (this.name = null), (this.keyModified = new Map());
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RequestWrapper: class {
        constructor() {
          (this.users = null), (this.keyModified = new Map());
        }
        getUsers() {
          return this.users;
        }
        setUsers(users) {
          if (
            null != users &&
            "[object Array]" != Object.prototype.toString.call(users)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: users EXPECTED TYPE: Array",
              null,
              null
            );
          (this.users = users), this.keyModified.set("users", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      User: class extends ZCRM.Record.Model.Record {
        constructor() {
          super();
        }
        getCountry() {
          return this.getKeyValue("country");
        }
        setCountry(country) {
          if (
            null != country &&
            "[object String]" != Object.prototype.toString.call(country)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: country EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("country", country);
        }
        getCustomizeInfo() {
          return this.getKeyValue("customize_info");
        }
        setCustomizeInfo(customizeInfo) {
          if (
            null != customizeInfo &&
            !(customizeInfo instanceof ZCRM.User.Model.CustomizeInfo)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: customizeInfo EXPECTED TYPE: CustomizeInfo",
              null,
              null
            );
          this.addKeyValue("customize_info", customizeInfo);
        }
        getRole() {
          return this.getKeyValue("role");
        }
        setRole(role) {
          if (null != role && !(role instanceof ZCRM.Role.Model.Role))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: role EXPECTED TYPE: Role",
              null,
              null
            );
          this.addKeyValue("role", role);
        }
        getSignature() {
          return this.getKeyValue("signature");
        }
        setSignature(signature) {
          if (
            null != signature &&
            "[object String]" != Object.prototype.toString.call(signature)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: signature EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("signature", signature);
        }
        getCity() {
          return this.getKeyValue("city");
        }
        setCity(city) {
          if (
            null != city &&
            "[object String]" != Object.prototype.toString.call(city)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: city EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("city", city);
        }
        getNameFormat() {
          return this.getKeyValue("name_format");
        }
        setNameFormat(nameFormat) {
          if (
            null != nameFormat &&
            "[object String]" != Object.prototype.toString.call(nameFormat)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: nameFormat EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("name_format", nameFormat);
        }
        getPersonalAccount() {
          return this.getKeyValue("personal_account");
        }
        setPersonalAccount(personalAccount) {
          if (
            null != personalAccount &&
            "[object Boolean]" !=
              Object.prototype.toString.call(personalAccount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: personalAccount EXPECTED TYPE: Boolean",
              null,
              null
            );
          this.addKeyValue("personal_account", personalAccount);
        }
        getDefaultTabGroup() {
          return this.getKeyValue("default_tab_group");
        }
        setDefaultTabGroup(defaultTabGroup) {
          if (
            null != defaultTabGroup &&
            "[object String]" != Object.prototype.toString.call(defaultTabGroup)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: defaultTabGroup EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("default_tab_group", defaultTabGroup);
        }
        getLanguage() {
          return this.getKeyValue("language");
        }
        setLanguage(language) {
          if (
            null != language &&
            "[object String]" != Object.prototype.toString.call(language)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: language EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("language", language);
        }
        getLocale() {
          return this.getKeyValue("locale");
        }
        setLocale(locale) {
          if (
            null != locale &&
            "[object String]" != Object.prototype.toString.call(locale)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: locale EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("locale", locale);
        }
        getMicrosoft() {
          return this.getKeyValue("microsoft");
        }
        setMicrosoft(microsoft) {
          if (
            null != microsoft &&
            "[object Boolean]" != Object.prototype.toString.call(microsoft)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: microsoft EXPECTED TYPE: Boolean",
              null,
              null
            );
          this.addKeyValue("microsoft", microsoft);
        }
        getIsonline() {
          return this.getKeyValue("Isonline");
        }
        setIsonline(isonline) {
          if (
            null != isonline &&
            "[object Boolean]" != Object.prototype.toString.call(isonline)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: isonline EXPECTED TYPE: Boolean",
              null,
              null
            );
          this.addKeyValue("Isonline", isonline);
        }
        getStreet() {
          return this.getKeyValue("street");
        }
        setStreet(street) {
          if (
            null != street &&
            "[object String]" != Object.prototype.toString.call(street)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: street EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("street", street);
        }
        getCurrency() {
          return this.getKeyValue("Currency");
        }
        setCurrency(currency) {
          if (
            null != currency &&
            "[object String]" != Object.prototype.toString.call(currency)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: currency EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("Currency", currency);
        }
        getAlias() {
          return this.getKeyValue("alias");
        }
        setAlias(alias) {
          if (
            null != alias &&
            "[object String]" != Object.prototype.toString.call(alias)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: alias EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("alias", alias);
        }
        getTheme() {
          return this.getKeyValue("theme");
        }
        setTheme(theme) {
          if (null != theme && !(theme instanceof ZCRM.User.Model.Theme))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: theme EXPECTED TYPE: Theme",
              null,
              null
            );
          this.addKeyValue("theme", theme);
        }
        getState() {
          return this.getKeyValue("state");
        }
        setState(state) {
          if (
            null != state &&
            "[object String]" != Object.prototype.toString.call(state)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: state EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("state", state);
        }
        getFax() {
          return this.getKeyValue("fax");
        }
        setFax(fax) {
          if (
            null != fax &&
            "[object String]" != Object.prototype.toString.call(fax)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fax EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("fax", fax);
        }
        getCountryLocale() {
          return this.getKeyValue("country_locale");
        }
        setCountryLocale(countryLocale) {
          if (
            null != countryLocale &&
            "[object String]" != Object.prototype.toString.call(countryLocale)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: countryLocale EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("country_locale", countryLocale);
        }
        getFirstName() {
          return this.getKeyValue("first_name");
        }
        setFirstName(firstName) {
          if (
            null != firstName &&
            "[object String]" != Object.prototype.toString.call(firstName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: firstName EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("first_name", firstName);
        }
        getEmail() {
          return this.getKeyValue("email");
        }
        setEmail(email) {
          if (
            null != email &&
            "[object String]" != Object.prototype.toString.call(email)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: email EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("email", email);
        }
        getReportingTo() {
          return this.getKeyValue("Reporting_To");
        }
        setReportingTo(reportingTo) {
          if (
            null != reportingTo &&
            !(reportingTo instanceof ZCRM.User.Model.User)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: reportingTo EXPECTED TYPE: User",
              null,
              null
            );
          this.addKeyValue("Reporting_To", reportingTo);
        }
        getDecimalSeparator() {
          return this.getKeyValue("decimal_separator");
        }
        setDecimalSeparator(decimalSeparator) {
          if (
            null != decimalSeparator &&
            "[object String]" !=
              Object.prototype.toString.call(decimalSeparator)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: decimalSeparator EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("decimal_separator", decimalSeparator);
        }
        getZip() {
          return this.getKeyValue("zip");
        }
        setZip(zip) {
          if (
            null != zip &&
            "[object String]" != Object.prototype.toString.call(zip)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: zip EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("zip", zip);
        }
        getWebsite() {
          return this.getKeyValue("website");
        }
        setWebsite(website) {
          if (
            null != website &&
            "[object String]" != Object.prototype.toString.call(website)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: website EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("website", website);
        }
        getTimeFormat() {
          return this.getKeyValue("time_format");
        }
        setTimeFormat(timeFormat) {
          if (
            null != timeFormat &&
            "[object String]" != Object.prototype.toString.call(timeFormat)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: timeFormat EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("time_format", timeFormat);
        }
        getOffset() {
          return this.getKeyValue("offset");
        }
        setOffset(offset) {
          if (
            null != offset &&
            "[object BigInt]" != Object.prototype.toString.call(offset)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: offset EXPECTED TYPE: BigInt",
              null,
              null
            );
          this.addKeyValue("offset", offset);
        }
        getProfile() {
          return this.getKeyValue("profile");
        }
        setProfile(profile) {
          if (
            null != profile &&
            !(profile instanceof ZCRM.Profile.Model.Profile)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: profile EXPECTED TYPE: Profile",
              null,
              null
            );
          this.addKeyValue("profile", profile);
        }
        getMobile() {
          return this.getKeyValue("mobile");
        }
        setMobile(mobile) {
          if (
            null != mobile &&
            "[object String]" != Object.prototype.toString.call(mobile)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: mobile EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("mobile", mobile);
        }
        getLastName() {
          return this.getKeyValue("last_name");
        }
        setLastName(lastName) {
          if (
            null != lastName &&
            "[object String]" != Object.prototype.toString.call(lastName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: lastName EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("last_name", lastName);
        }
        getTimeZone() {
          return this.getKeyValue("time_zone");
        }
        setTimeZone(timeZone) {
          if (
            null != timeZone &&
            "[object String]" != Object.prototype.toString.call(timeZone)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: timeZone EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("time_zone", timeZone);
        }
        getZuid() {
          return this.getKeyValue("zuid");
        }
        setZuid(zuid) {
          if (
            null != zuid &&
            "[object String]" != Object.prototype.toString.call(zuid)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: zuid EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("zuid", zuid);
        }
        getConfirm() {
          return this.getKeyValue("confirm");
        }
        setConfirm(confirm) {
          if (
            null != confirm &&
            "[object Boolean]" != Object.prototype.toString.call(confirm)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: confirm EXPECTED TYPE: Boolean",
              null,
              null
            );
          this.addKeyValue("confirm", confirm);
        }
        getFullName() {
          return this.getKeyValue("full_name");
        }
        setFullName(fullName) {
          if (
            null != fullName &&
            "[object String]" != Object.prototype.toString.call(fullName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fullName EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("full_name", fullName);
        }
        getTerritories() {
          return this.getKeyValue("territories");
        }
        setTerritories(territories) {
          if (
            null != territories &&
            "[object Array]" != Object.prototype.toString.call(territories)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: territories EXPECTED TYPE: Array",
              null,
              null
            );
          this.addKeyValue("territories", territories);
        }
        getPhone() {
          return this.getKeyValue("phone");
        }
        setPhone(phone) {
          if (
            null != phone &&
            "[object String]" != Object.prototype.toString.call(phone)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: phone EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("phone", phone);
        }
        getDob() {
          return this.getKeyValue("dob");
        }
        setDob(dob) {
          if (
            null != dob &&
            "[object String]" != Object.prototype.toString.call(dob)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: dob EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("dob", dob);
        }
        getDateFormat() {
          return this.getKeyValue("date_format");
        }
        setDateFormat(dateFormat) {
          if (
            null != dateFormat &&
            "[object String]" != Object.prototype.toString.call(dateFormat)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: dateFormat EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("date_format", dateFormat);
        }
        getStatus() {
          return this.getKeyValue("status");
        }
        setStatus(status) {
          if (
            null != status &&
            "[object String]" != Object.prototype.toString.call(status)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("status", status);
        }
        getName() {
          return this.getKeyValue("name");
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          this.addKeyValue("name", name);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      TabTheme: class {
        constructor() {
          (this.fontColor = null),
            (this.background = null),
            (this.keyModified = new Map());
        }
        getFontColor() {
          return this.fontColor;
        }
        setFontColor(fontColor) {
          if (
            null != fontColor &&
            "[object String]" != Object.prototype.toString.call(fontColor)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fontColor EXPECTED TYPE: String",
              null,
              null
            );
          (this.fontColor = fontColor), this.keyModified.set("font_color", 1);
        }
        getBackground() {
          return this.background;
        }
        setBackground(background) {
          if (
            null != background &&
            "[object String]" != Object.prototype.toString.call(background)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: background EXPECTED TYPE: String",
              null,
              null
            );
          (this.background = background), this.keyModified.set("background", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      GetUsersHeader: {
        IF_MODIFIED_SINCE: new Header(
          "If-Modified-Since",
          "User.Model.GetUsersHeader"
        ),
      },
      GetUsersParam: {
        TYPE: new Param("type", "User.Model.GetUsersParam"),
        PAGE: new Param("page", "User.Model.GetUsersParam"),
        PER_PAGE: new Param("per_page", "User.Model.GetUsersParam"),
      },
      GetUserHeader: {
        IF_MODIFIED_SINCE: new Header(
          "If-Modified-Since",
          "User.Model.GetUserHeader"
        ),
      },
    },
    Operations: class {
      constructor() {}
      async getUsers(paramInstance = null, headerInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/users")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.apiCall(
            "User.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async createUser(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.User.Model.RequestWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: RequestWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/users")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "User.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async updateUsers(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.User.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/users")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "User.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getUser(id, headerInstance = null) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/crm/v2/users/")).concat(
            id.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.apiCall(
            "User.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateUser(id, request) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.User.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/crm/v2/users/")).concat(
            id.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.apiCall(
            "User.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async deleteUser(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/crm/v2/users/")).concat(
            id.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.apiCall(
            "User.Model.ActionHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.BulkWrite = {
    Model: {
      ActionResponse: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      ResponseWrapper: class {
        constructor() {}
      },
      CallBack: class {
        constructor() {
          (this.url = null),
            (this.method = null),
            (this.keyModified = new Map());
        }
        getUrl() {
          return this.url;
        }
        setUrl(url) {
          if (
            null != url &&
            "[object String]" != Object.prototype.toString.call(url)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: url EXPECTED TYPE: String",
              null,
              null
            );
          (this.url = url), this.keyModified.set("url", 1);
        }
        getMethod() {
          return this.method;
        }
        setMethod(method) {
          if (null != method && !(method instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: method EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.method = method), this.keyModified.set("method", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RequestWrapper: class {
        constructor() {
          (this.characterEncoding = null),
            (this.operation = null),
            (this.callback = null),
            (this.resource = null),
            (this.keyModified = new Map());
        }
        getCharacterEncoding() {
          return this.characterEncoding;
        }
        setCharacterEncoding(characterEncoding) {
          if (
            null != characterEncoding &&
            "[object String]" !=
              Object.prototype.toString.call(characterEncoding)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: characterEncoding EXPECTED TYPE: String",
              null,
              null
            );
          (this.characterEncoding = characterEncoding),
            this.keyModified.set("character_encoding", 1);
        }
        getOperation() {
          return this.operation;
        }
        setOperation(operation) {
          if (null != operation && !(operation instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: operation EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.operation = operation), this.keyModified.set("operation", 1);
        }
        getCallback() {
          return this.callback;
        }
        setCallback(callback) {
          if (
            null != callback &&
            !(callback instanceof ZCRM.BulkWrite.Model.CallBack)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: callback EXPECTED TYPE: CallBack",
              null,
              null
            );
          (this.callback = callback), this.keyModified.set("callback", 1);
        }
        getResource() {
          return this.resource;
        }
        setResource(resource) {
          if (
            null != resource &&
            "[object Array]" != Object.prototype.toString.call(resource)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: resource EXPECTED TYPE: Array",
              null,
              null
            );
          (this.resource = resource), this.keyModified.set("resource", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.code = null),
            (this.message = null),
            (this.status = null),
            (this.details = null),
            (this.errorMessage = null),
            (this.errorCode = null),
            (this.xError = null),
            (this.info = null),
            (this.xInfo = null),
            (this.httpStatus = null),
            (this.keyModified = new Map());
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        getErrorMessage() {
          return this.errorMessage;
        }
        setErrorMessage(errorMessage) {
          if (null != errorMessage && !(errorMessage instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: errorMessage EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.errorMessage = errorMessage),
            this.keyModified.set("ERROR_MESSAGE", 1);
        }
        getErrorCode() {
          return this.errorCode;
        }
        setErrorCode(errorCode) {
          if (
            null != errorCode &&
            "[object Number]" != Object.prototype.toString.call(errorCode)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: errorCode EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.errorCode = errorCode), this.keyModified.set("ERROR_CODE", 1);
        }
        getXError() {
          return this.xError;
        }
        setXError(xError) {
          if (null != xError && !(xError instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: xError EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.xError = xError), this.keyModified.set("x-error", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (null != info && !(info instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        getXInfo() {
          return this.xInfo;
        }
        setXInfo(xInfo) {
          if (null != xInfo && !(xInfo instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: xInfo EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.xInfo = xInfo), this.keyModified.set("x-info", 1);
        }
        getHttpStatus() {
          return this.httpStatus;
        }
        setHttpStatus(httpStatus) {
          if (
            null != httpStatus &&
            "[object String]" != Object.prototype.toString.call(httpStatus)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: httpStatus EXPECTED TYPE: String",
              null,
              null
            );
          (this.httpStatus = httpStatus),
            this.keyModified.set("http_status", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BulkWriteResponse: class {
        constructor() {
          (this.status = null),
            (this.characterEncoding = null),
            (this.resource = null),
            (this.id = null),
            (this.callback = null),
            (this.result = null),
            (this.createdBy = null),
            (this.operation = null),
            (this.createdTime = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (
            null != status &&
            "[object String]" != Object.prototype.toString.call(status)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: String",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCharacterEncoding() {
          return this.characterEncoding;
        }
        setCharacterEncoding(characterEncoding) {
          if (
            null != characterEncoding &&
            "[object String]" !=
              Object.prototype.toString.call(characterEncoding)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: characterEncoding EXPECTED TYPE: String",
              null,
              null
            );
          (this.characterEncoding = characterEncoding),
            this.keyModified.set("character_encoding", 1);
        }
        getResource() {
          return this.resource;
        }
        setResource(resource) {
          if (
            null != resource &&
            "[object Array]" != Object.prototype.toString.call(resource)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: resource EXPECTED TYPE: Array",
              null,
              null
            );
          (this.resource = resource), this.keyModified.set("resource", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getCallback() {
          return this.callback;
        }
        setCallback(callback) {
          if (
            null != callback &&
            !(callback instanceof ZCRM.BulkWrite.Model.CallBack)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: callback EXPECTED TYPE: CallBack",
              null,
              null
            );
          (this.callback = callback), this.keyModified.set("callback", 1);
        }
        getResult() {
          return this.result;
        }
        setResult(result) {
          if (
            null != result &&
            !(result instanceof ZCRM.BulkWrite.Model.Result)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: result EXPECTED TYPE: Result",
              null,
              null
            );
          (this.result = result), this.keyModified.set("result", 1);
        }
        getCreatedBy() {
          return this.createdBy;
        }
        setCreatedBy(createdBy) {
          if (null != createdBy && !(createdBy instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.createdBy = createdBy), this.keyModified.set("created_by", 1);
        }
        getOperation() {
          return this.operation;
        }
        setOperation(operation) {
          if (
            null != operation &&
            "[object String]" != Object.prototype.toString.call(operation)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: operation EXPECTED TYPE: String",
              null,
              null
            );
          (this.operation = operation), this.keyModified.set("operation", 1);
        }
        getCreatedTime() {
          return this.createdTime;
        }
        setCreatedTime(createdTime) {
          if (null != createdTime && !(createdTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.createdTime = createdTime),
            this.keyModified.set("created_time", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      File: class {
        constructor() {
          (this.status = null),
            (this.name = null),
            (this.addedCount = null),
            (this.skippedCount = null),
            (this.updatedCount = null),
            (this.totalCount = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getAddedCount() {
          return this.addedCount;
        }
        setAddedCount(addedCount) {
          if (
            null != addedCount &&
            "[object Number]" != Object.prototype.toString.call(addedCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: addedCount EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.addedCount = addedCount),
            this.keyModified.set("added_count", 1);
        }
        getSkippedCount() {
          return this.skippedCount;
        }
        setSkippedCount(skippedCount) {
          if (
            null != skippedCount &&
            "[object Number]" != Object.prototype.toString.call(skippedCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: skippedCount EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.skippedCount = skippedCount),
            this.keyModified.set("skipped_count", 1);
        }
        getUpdatedCount() {
          return this.updatedCount;
        }
        setUpdatedCount(updatedCount) {
          if (
            null != updatedCount &&
            "[object Number]" != Object.prototype.toString.call(updatedCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: updatedCount EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.updatedCount = updatedCount),
            this.keyModified.set("updated_count", 1);
        }
        getTotalCount() {
          return this.totalCount;
        }
        setTotalCount(totalCount) {
          if (
            null != totalCount &&
            "[object Number]" != Object.prototype.toString.call(totalCount)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: totalCount EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.totalCount = totalCount),
            this.keyModified.set("total_count", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Resource: class {
        constructor() {
          (this.status = null),
            (this.type = null),
            (this.module = null),
            (this.fileId = null),
            (this.ignoreEmpty = null),
            (this.findBy = null),
            (this.fieldMappings = null),
            (this.file = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getType() {
          return this.type;
        }
        setType(type) {
          if (null != type && !(type instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: type EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.type = type), this.keyModified.set("type", 1);
        }
        getModule() {
          return this.module;
        }
        setModule(module) {
          if (
            null != module &&
            "[object String]" != Object.prototype.toString.call(module)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: module EXPECTED TYPE: String",
              null,
              null
            );
          (this.module = module), this.keyModified.set("module", 1);
        }
        getFileId() {
          return this.fileId;
        }
        setFileId(fileId) {
          if (
            null != fileId &&
            "[object String]" != Object.prototype.toString.call(fileId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fileId EXPECTED TYPE: String",
              null,
              null
            );
          (this.fileId = fileId), this.keyModified.set("file_id", 1);
        }
        getIgnoreEmpty() {
          return this.ignoreEmpty;
        }
        setIgnoreEmpty(ignoreEmpty) {
          if (
            null != ignoreEmpty &&
            "[object Boolean]" != Object.prototype.toString.call(ignoreEmpty)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: ignoreEmpty EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.ignoreEmpty = ignoreEmpty),
            this.keyModified.set("ignore_empty", 1);
        }
        getFindBy() {
          return this.findBy;
        }
        setFindBy(findBy) {
          if (
            null != findBy &&
            "[object String]" != Object.prototype.toString.call(findBy)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: findBy EXPECTED TYPE: String",
              null,
              null
            );
          (this.findBy = findBy), this.keyModified.set("find_by", 1);
        }
        getFieldMappings() {
          return this.fieldMappings;
        }
        setFieldMappings(fieldMappings) {
          if (
            null != fieldMappings &&
            "[object Array]" != Object.prototype.toString.call(fieldMappings)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fieldMappings EXPECTED TYPE: Array",
              null,
              null
            );
          (this.fieldMappings = fieldMappings),
            this.keyModified.set("field_mappings", 1);
        }
        getFile() {
          return this.file;
        }
        setFile(file) {
          if (null != file && !(file instanceof ZCRM.BulkWrite.Model.File))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: file EXPECTED TYPE: File",
              null,
              null
            );
          (this.file = file), this.keyModified.set("file", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      FieldMapping: class {
        constructor() {
          (this.apiName = null),
            (this.index = null),
            (this.format = null),
            (this.findBy = null),
            (this.defaultValue = null),
            (this.module = null),
            (this.keyModified = new Map());
        }
        getAPIName() {
          return this.apiName;
        }
        setAPIName(apiName) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          (this.apiName = apiName), this.keyModified.set("api_name", 1);
        }
        getIndex() {
          return this.index;
        }
        setIndex(index) {
          if (
            null != index &&
            "[object Number]" != Object.prototype.toString.call(index)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: index EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.index = index), this.keyModified.set("index", 1);
        }
        getFormat() {
          return this.format;
        }
        setFormat(format) {
          if (
            null != format &&
            "[object String]" != Object.prototype.toString.call(format)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: format EXPECTED TYPE: String",
              null,
              null
            );
          (this.format = format), this.keyModified.set("format", 1);
        }
        getFindBy() {
          return this.findBy;
        }
        setFindBy(findBy) {
          if (
            null != findBy &&
            "[object String]" != Object.prototype.toString.call(findBy)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: findBy EXPECTED TYPE: String",
              null,
              null
            );
          (this.findBy = findBy), this.keyModified.set("find_by", 1);
        }
        getDefaultValue() {
          return this.defaultValue;
        }
        setDefaultValue(defaultValue) {
          if (
            null != defaultValue &&
            "[object Map]" != Object.prototype.toString.call(defaultValue)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: defaultValue EXPECTED TYPE: Map",
              null,
              null
            );
          (this.defaultValue = defaultValue),
            this.keyModified.set("default_value", 1);
        }
        getModule() {
          return this.module;
        }
        setModule(module) {
          if (
            null != module &&
            "[object String]" != Object.prototype.toString.call(module)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: module EXPECTED TYPE: String",
              null,
              null
            );
          (this.module = module), this.keyModified.set("module", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      FileBodyWrapper: class {
        constructor() {
          (this.file = null), (this.keyModified = new Map());
        }
        getFile() {
          return this.file;
        }
        setFile(file) {
          if (
            null != file &&
            !(file instanceof StreamWrapper.Model.StreamWrapper)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: file EXPECTED TYPE: StreamWrapper",
              null,
              null
            );
          (this.file = file), this.keyModified.set("file", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Result: class {
        constructor() {
          (this.downloadUrl = null), (this.keyModified = new Map());
        }
        getDownloadUrl() {
          return this.downloadUrl;
        }
        setDownloadUrl(downloadUrl) {
          if (
            null != downloadUrl &&
            "[object String]" != Object.prototype.toString.call(downloadUrl)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: downloadUrl EXPECTED TYPE: String",
              null,
              null
            );
          (this.downloadUrl = downloadUrl),
            this.keyModified.set("download_url", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      UploadFileHeader: {
        FEATURE: new Header("feature", "BulkWrite.Model.UploadFileHeader"),
        X_CRM_ORG: new Header("X-CRM-ORG", "BulkWrite.Model.UploadFileHeader"),
      },
    },
    Operations: class {
      constructor() {}
      async uploadFile(request, headerInstance = null) {
        if (
          null != request &&
          !(request instanceof ZCRM.BulkWrite.Model.FileBodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: FileBodyWrapper",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat(
            "https://content.zohoapis.com/crm/v2/upload"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("multipart/form-data"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.apiCall(
            "BulkWrite.Model.ActionResponse",
            "application/json"
          )
        );
      }
      async createBulkWriteJob(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.BulkWrite.Model.RequestWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: RequestWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/bulk/v2/write")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "BulkWrite.Model.ActionResponse",
            "application/json"
          )
        );
      }
      async getBulkWriteJobDetails(jobId) {
        if ("[object BigInt]" != Object.prototype.toString.call(jobId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: jobId EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/crm/bulk/v2/write/")).concat(
            jobId.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "BulkWrite.Model.ResponseWrapper",
            "application/json"
          )
        );
      }
      async downloadBulkWriteResult(downloadUrl) {
        if ("[object String]" != Object.prototype.toString.call(downloadUrl))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: downloadUrl EXPECTED TYPE: String",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat("/")).concat(
            downloadUrl.toString()
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "BulkWrite.Model.ResponseHandler",
            "application/octet-stream"
          )
        );
      }
    },
  }),
  (ZCRM.Function = {
    Model: {
      ResponseWrapper: class {
        constructor() {}
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.body = null), (this.keyModified = new Map());
        }
        getBody() {
          return this.body;
        }
        setBody(body) {
          if (
            null != body &&
            "[object Map]" != Object.prototype.toString.call(body)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: body EXPECTED TYPE: Map",
              null,
              null
            );
          (this.body = body), this.keyModified.set("body", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      FileBodyWrapper: class {
        constructor() {
          (this.inputfile = null), (this.keyModified = new Map());
        }
        getInputfile() {
          return this.inputfile;
        }
        setInputfile(inputfile) {
          if (
            null != inputfile &&
            !(inputfile instanceof StreamWrapper.Model.StreamWrapper)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: inputfile EXPECTED TYPE: StreamWrapper",
              null,
              null
            );
          (this.inputfile = inputfile), this.keyModified.set("inputFile", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ExecuteFunctionUsingFileParam: {
        UPLOAD_FILE_PARAM: new Param(
          "upload_file_param",
          "Function.Model.ExecuteFunctionUsingFileParam"
        ),
      },
      ExecuteFunctionUsingParametersHeader: {
        GET_CUSTOM_FUNCTIONS_HEADER: new Header(
          "get_custom_functions_header",
          "Function.Model.ExecuteFunctionUsingParametersHeader"
        ),
      },
      ExecuteFunctionUsingRequestBodyHeader: {
        CUSTOM_FUNCTIONS_HEADER: new Header(
          "custom_functions_header",
          "Function.Model.ExecuteFunctionUsingRequestBodyHeader"
        ),
      },
      ExecuteFunctionUsingFileHeader: {
        UPLOAD_FILE_HEADER: new Header(
          "upload_file_header",
          "Function.Model.ExecuteFunctionUsingFileHeader"
        ),
      },
      ExecuteFunctionUsingParametersParam: {
        GET_CUSTOM_FUNCTIONS_PARAM: new Param(
          "get_custom_functions_param",
          "Function.Model.ExecuteFunctionUsingParametersParam"
        ),
      },
      ExecuteFunctionUsingRequestBodyParam: {
        CUSTOM_FUNCTIONS_PARAM: new Param(
          "custom_functions_param",
          "Function.Model.ExecuteFunctionUsingRequestBodyParam"
        ),
      },
    },
    Operations: class {
      constructor(functionName, authType = null, arguments1 = null) {
        if ("[object String]" != Object.prototype.toString.call(functionName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: functionName EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != authType &&
          "[object String]" != Object.prototype.toString.call(authType)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: authType EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != arguments1 &&
          "[object Map]" != Object.prototype.toString.call(arguments1)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: arguments1 EXPECTED TYPE: Map",
            null,
            null
          );
        (this.functionName = functionName),
          (this.authType = authType),
          (this.arguments1 = arguments1);
      }
      async executeFunctionUsingRequestBody(
        request,
        paramInstance = null,
        headerInstance = null
      ) {
        if (
          null != request &&
          !(request instanceof ZCRM.Function.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/functions/")).concat(
            this.functionName.toString()
          )).concat("/actions/execute")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          await handlerInstance.addParam(
            new Param(
              "auth_type",
              "Function.Model.ExecuteFunctionUsingRequestBodyParam"
            ),
            this.authType
          ),
          await handlerInstance.addParam(
            new Param(
              "arguments",
              "Function.Model.ExecuteFunctionUsingRequestBodyParam"
            ),
            this.arguments1
          ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.apiCall(
            "Function.Model.ResponseWrapper",
            "application/json"
          )
        );
      }
      async executeFunctionUsingParameters(
        paramInstance = null,
        headerInstance = null
      ) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/functions/")).concat(
            this.functionName.toString()
          )).concat("/actions/execute")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addParam(
            new Param(
              "auth_type",
              "Function.Model.ExecuteFunctionUsingParametersParam"
            ),
            this.authType
          ),
          await handlerInstance.addParam(
            new Param(
              "arguments",
              "Function.Model.ExecuteFunctionUsingParametersParam"
            ),
            this.arguments1
          ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.apiCall(
            "Function.Model.ResponseWrapper",
            "application/json"
          )
        );
      }
      async executeFunctionUsingFile(
        request,
        paramInstance = null,
        headerInstance = null
      ) {
        if (
          null != request &&
          !(request instanceof ZCRM.Function.Model.FileBodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: FileBodyWrapper",
            null,
            null
          );
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/functions/")).concat(
            this.functionName.toString()
          )).concat("/actions/execute")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("multipart/form-data"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          await handlerInstance.addParam(
            new Param(
              "auth_type",
              "Function.Model.ExecuteFunctionUsingFileParam"
            ),
            this.authType
          ),
          await handlerInstance.addParam(
            new Param(
              "arguments",
              "Function.Model.ExecuteFunctionUsingFileParam"
            ),
            this.arguments1
          ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.apiCall(
            "Function.Model.ResponseWrapper",
            "application/json"
          )
        );
      }
    },
  });
class RequestProxy {
  constructor(host, port) {
    (this._host = host), (this._port = port);
  }
  getHost() {
    return this._host;
  }
  getPort() {
    return this._port;
  }
}
(ZCRM.Field = {
  Model: {
    ResponseHandler: class {
      constructor() {}
    },
    RelatedDetails: class {
      constructor() {
        (this.displayLabel = null),
          (this.apiName = null),
          (this.module = null),
          (this.id = null),
          (this.type = null),
          (this.keyModified = new Map());
      }
      getDisplayLabel() {
        return this.displayLabel;
      }
      setDisplayLabel(displayLabel) {
        if (
          null != displayLabel &&
          "[object String]" != Object.prototype.toString.call(displayLabel)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: displayLabel EXPECTED TYPE: String",
            null,
            null
          );
        (this.displayLabel = displayLabel),
          this.keyModified.set("display_label", 1);
      }
      getAPIName() {
        return this.apiName;
      }
      setAPIName(apiName) {
        if (
          null != apiName &&
          "[object String]" != Object.prototype.toString.call(apiName)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: apiName EXPECTED TYPE: String",
            null,
            null
          );
        (this.apiName = apiName), this.keyModified.set("api_name", 1);
      }
      getModule() {
        return this.module;
      }
      setModule(module) {
        if (null != module && !(module instanceof ZCRM.Field.Model.Module))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: module EXPECTED TYPE: Module",
            null,
            null
          );
        (this.module = module), this.keyModified.set("module", 1);
      }
      getId() {
        return this.id;
      }
      setId(id) {
        if (
          null != id &&
          "[object BigInt]" != Object.prototype.toString.call(id)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        (this.id = id), this.keyModified.set("id", 1);
      }
      getType() {
        return this.type;
      }
      setType(type) {
        if (
          null != type &&
          "[object String]" != Object.prototype.toString.call(type)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: type EXPECTED TYPE: String",
            null,
            null
          );
        (this.type = type), this.keyModified.set("_type", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    Field: class {
      constructor() {
        (this.systemMandatory = null),
          (this.webhook = null),
          (this.private1 = null),
          (this.layouts = null),
          (this.content = null),
          (this.columnName = null),
          (this.type = null),
          (this.transitionSequence = null),
          (this.personalityName = null),
          (this.message = null),
          (this.mandatory = null),
          (this.criteria = null),
          (this.relatedDetails = null),
          (this.jsonType = null),
          (this.crypt = null),
          (this.fieldLabel = null),
          (this.tooltip = null),
          (this.createdSource = null),
          (this.fieldReadOnly = null),
          (this.displayLabel = null),
          (this.readOnly = null),
          (this.associationDetails = null),
          (this.quickSequenceNumber = null),
          (this.businesscardSupported = null),
          (this.multiModuleLookup = null),
          (this.currency = null),
          (this.id = null),
          (this.customField = null),
          (this.lookup = null),
          (this.visible = null),
          (this.length = null),
          (this.viewType = null),
          (this.subform = null),
          (this.apiName = null),
          (this.unique = null),
          (this.historyTracking = null),
          (this.dataType = null),
          (this.formula = null),
          (this.decimalPlace = null),
          (this.massUpdate = null),
          (this.blueprintSupported = null),
          (this.multiselectlookup = null),
          (this.pickListValues = null),
          (this.autoNumber = null),
          (this.defaultValue = null),
          (this.sectionId = null),
          (this.validationRule = null),
          (this.convertMapping = null),
          (this.keyModified = new Map());
      }
      getSystemMandatory() {
        return this.systemMandatory;
      }
      setSystemMandatory(systemMandatory) {
        if (
          null != systemMandatory &&
          "[object Boolean]" != Object.prototype.toString.call(systemMandatory)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: systemMandatory EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.systemMandatory = systemMandatory),
          this.keyModified.set("system_mandatory", 1);
      }
      getWebhook() {
        return this.webhook;
      }
      setWebhook(webhook) {
        if (
          null != webhook &&
          "[object Boolean]" != Object.prototype.toString.call(webhook)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: webhook EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.webhook = webhook), this.keyModified.set("webhook", 1);
      }
      getPrivate() {
        return this.private1;
      }
      setPrivate(private1) {
        if (null != private1 && !(private1 instanceof ZCRM.Field.Model.Private))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: private1 EXPECTED TYPE: Private",
            null,
            null
          );
        (this.private1 = private1), this.keyModified.set("private", 1);
      }
      getLayouts() {
        return this.layouts;
      }
      setLayouts(layouts) {
        if (null != layouts && !(layouts instanceof ZCRM.Layout.Model.Layout))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: layouts EXPECTED TYPE: Layout",
            null,
            null
          );
        (this.layouts = layouts), this.keyModified.set("layouts", 1);
      }
      getContent() {
        return this.content;
      }
      setContent(content) {
        if (
          null != content &&
          "[object String]" != Object.prototype.toString.call(content)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: content EXPECTED TYPE: String",
            null,
            null
          );
        (this.content = content), this.keyModified.set("content", 1);
      }
      getColumnName() {
        return this.columnName;
      }
      setColumnName(columnName) {
        if (
          null != columnName &&
          "[object String]" != Object.prototype.toString.call(columnName)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: columnName EXPECTED TYPE: String",
            null,
            null
          );
        (this.columnName = columnName), this.keyModified.set("column_name", 1);
      }
      getType() {
        return this.type;
      }
      setType(type) {
        if (
          null != type &&
          "[object String]" != Object.prototype.toString.call(type)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: type EXPECTED TYPE: String",
            null,
            null
          );
        (this.type = type), this.keyModified.set("_type", 1);
      }
      getTransitionSequence() {
        return this.transitionSequence;
      }
      setTransitionSequence(transitionSequence) {
        if (
          null != transitionSequence &&
          "[object Number]" !=
            Object.prototype.toString.call(transitionSequence)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: transitionSequence EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.transitionSequence = transitionSequence),
          this.keyModified.set("transition_sequence", 1);
      }
      getPersonalityName() {
        return this.personalityName;
      }
      setPersonalityName(personalityName) {
        if (
          null != personalityName &&
          "[object String]" != Object.prototype.toString.call(personalityName)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: personalityName EXPECTED TYPE: String",
            null,
            null
          );
        (this.personalityName = personalityName),
          this.keyModified.set("personality_name", 1);
      }
      getMessage() {
        return this.message;
      }
      setMessage(message) {
        if (
          null != message &&
          "[object String]" != Object.prototype.toString.call(message)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: message EXPECTED TYPE: String",
            null,
            null
          );
        (this.message = message), this.keyModified.set("message", 1);
      }
      getMandatory() {
        return this.mandatory;
      }
      setMandatory(mandatory) {
        if (
          null != mandatory &&
          "[object Boolean]" != Object.prototype.toString.call(mandatory)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: mandatory EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.mandatory = mandatory), this.keyModified.set("mandatory", 1);
      }
      getCriteria() {
        return this.criteria;
      }
      setCriteria(criteria) {
        if (
          null != criteria &&
          !(criteria instanceof ZCRM.CustomView.Model.Criteria)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: criteria EXPECTED TYPE: Criteria",
            null,
            null
          );
        (this.criteria = criteria), this.keyModified.set("criteria", 1);
      }
      getRelatedDetails() {
        return this.relatedDetails;
      }
      setRelatedDetails(relatedDetails) {
        if (
          null != relatedDetails &&
          !(relatedDetails instanceof ZCRM.Field.Model.RelatedDetails)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: relatedDetails EXPECTED TYPE: RelatedDetails",
            null,
            null
          );
        (this.relatedDetails = relatedDetails),
          this.keyModified.set("related_details", 1);
      }
      getJsonType() {
        return this.jsonType;
      }
      setJsonType(jsonType) {
        if (
          null != jsonType &&
          "[object String]" != Object.prototype.toString.call(jsonType)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: jsonType EXPECTED TYPE: String",
            null,
            null
          );
        (this.jsonType = jsonType), this.keyModified.set("json_type", 1);
      }
      getCrypt() {
        return this.crypt;
      }
      setCrypt(crypt) {
        if (null != crypt && !(crypt instanceof ZCRM.Field.Model.Crypt))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: crypt EXPECTED TYPE: Crypt",
            null,
            null
          );
        (this.crypt = crypt), this.keyModified.set("crypt", 1);
      }
      getFieldLabel() {
        return this.fieldLabel;
      }
      setFieldLabel(fieldLabel) {
        if (
          null != fieldLabel &&
          "[object String]" != Object.prototype.toString.call(fieldLabel)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: fieldLabel EXPECTED TYPE: String",
            null,
            null
          );
        (this.fieldLabel = fieldLabel), this.keyModified.set("field_label", 1);
      }
      getTooltip() {
        return this.tooltip;
      }
      setTooltip(tooltip) {
        if (null != tooltip && !(tooltip instanceof ZCRM.Field.Model.ToolTip))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: tooltip EXPECTED TYPE: ToolTip",
            null,
            null
          );
        (this.tooltip = tooltip), this.keyModified.set("tooltip", 1);
      }
      getCreatedSource() {
        return this.createdSource;
      }
      setCreatedSource(createdSource) {
        if (
          null != createdSource &&
          "[object String]" != Object.prototype.toString.call(createdSource)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: createdSource EXPECTED TYPE: String",
            null,
            null
          );
        (this.createdSource = createdSource),
          this.keyModified.set("created_source", 1);
      }
      getFieldReadOnly() {
        return this.fieldReadOnly;
      }
      setFieldReadOnly(fieldReadOnly) {
        if (
          null != fieldReadOnly &&
          "[object Boolean]" != Object.prototype.toString.call(fieldReadOnly)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: fieldReadOnly EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.fieldReadOnly = fieldReadOnly),
          this.keyModified.set("field_read_only", 1);
      }
      getDisplayLabel() {
        return this.displayLabel;
      }
      setDisplayLabel(displayLabel) {
        if (
          null != displayLabel &&
          "[object String]" != Object.prototype.toString.call(displayLabel)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: displayLabel EXPECTED TYPE: String",
            null,
            null
          );
        (this.displayLabel = displayLabel),
          this.keyModified.set("display_label", 1);
      }
      getReadOnly() {
        return this.readOnly;
      }
      setReadOnly(readOnly) {
        if (
          null != readOnly &&
          "[object Boolean]" != Object.prototype.toString.call(readOnly)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: readOnly EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.readOnly = readOnly), this.keyModified.set("read_only", 1);
      }
      getAssociationDetails() {
        return this.associationDetails;
      }
      setAssociationDetails(associationDetails) {
        if (
          null != associationDetails &&
          !(associationDetails instanceof ZCRM.Field.Model.AssociationDetails)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: associationDetails EXPECTED TYPE: AssociationDetails",
            null,
            null
          );
        (this.associationDetails = associationDetails),
          this.keyModified.set("association_details", 1);
      }
      getQuickSequenceNumber() {
        return this.quickSequenceNumber;
      }
      setQuickSequenceNumber(quickSequenceNumber) {
        if (
          null != quickSequenceNumber &&
          "[object Number]" !=
            Object.prototype.toString.call(quickSequenceNumber)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: quickSequenceNumber EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.quickSequenceNumber = quickSequenceNumber),
          this.keyModified.set("quick_sequence_number", 1);
      }
      getBusinesscardSupported() {
        return this.businesscardSupported;
      }
      setBusinesscardSupported(businesscardSupported) {
        if (
          null != businesscardSupported &&
          "[object Boolean]" !=
            Object.prototype.toString.call(businesscardSupported)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: businesscardSupported EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.businesscardSupported = businesscardSupported),
          this.keyModified.set("businesscard_supported", 1);
      }
      getMultiModuleLookup() {
        return this.multiModuleLookup;
      }
      setMultiModuleLookup(multiModuleLookup) {
        if (
          null != multiModuleLookup &&
          "[object Map]" != Object.prototype.toString.call(multiModuleLookup)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: multiModuleLookup EXPECTED TYPE: Map",
            null,
            null
          );
        (this.multiModuleLookup = multiModuleLookup),
          this.keyModified.set("multi_module_lookup", 1);
      }
      getCurrency() {
        return this.currency;
      }
      setCurrency(currency) {
        if (
          null != currency &&
          !(currency instanceof ZCRM.Field.Model.Currency)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: currency EXPECTED TYPE: Currency",
            null,
            null
          );
        (this.currency = currency), this.keyModified.set("currency", 1);
      }
      getId() {
        return this.id;
      }
      setId(id) {
        if (
          null != id &&
          "[object BigInt]" != Object.prototype.toString.call(id)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        (this.id = id), this.keyModified.set("id", 1);
      }
      getCustomField() {
        return this.customField;
      }
      setCustomField(customField) {
        if (
          null != customField &&
          "[object Boolean]" != Object.prototype.toString.call(customField)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: customField EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.customField = customField),
          this.keyModified.set("custom_field", 1);
      }
      getLookup() {
        return this.lookup;
      }
      setLookup(lookup) {
        if (null != lookup && !(lookup instanceof ZCRM.Field.Model.Module))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: lookup EXPECTED TYPE: Module",
            null,
            null
          );
        (this.lookup = lookup), this.keyModified.set("lookup", 1);
      }
      getVisible() {
        return this.visible;
      }
      setVisible(visible) {
        if (
          null != visible &&
          "[object Boolean]" != Object.prototype.toString.call(visible)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: visible EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.visible = visible), this.keyModified.set("visible", 1);
      }
      getLength() {
        return this.length;
      }
      setLength(length) {
        if (
          null != length &&
          "[object Number]" != Object.prototype.toString.call(length)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: length EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.length = length), this.keyModified.set("length", 1);
      }
      getViewType() {
        return this.viewType;
      }
      setViewType(viewType) {
        if (
          null != viewType &&
          !(viewType instanceof ZCRM.Field.Model.ViewType)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: viewType EXPECTED TYPE: ViewType",
            null,
            null
          );
        (this.viewType = viewType), this.keyModified.set("view_type", 1);
      }
      getSubform() {
        return this.subform;
      }
      setSubform(subform) {
        if (null != subform && !(subform instanceof ZCRM.Field.Model.Module))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: subform EXPECTED TYPE: Module",
            null,
            null
          );
        (this.subform = subform), this.keyModified.set("subform", 1);
      }
      getAPIName() {
        return this.apiName;
      }
      setAPIName(apiName) {
        if (
          null != apiName &&
          "[object String]" != Object.prototype.toString.call(apiName)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: apiName EXPECTED TYPE: String",
            null,
            null
          );
        (this.apiName = apiName), this.keyModified.set("api_name", 1);
      }
      getUnique() {
        return this.unique;
      }
      setUnique(unique) {
        if (null != unique && !(unique instanceof ZCRM.Field.Model.Unique))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: unique EXPECTED TYPE: Unique",
            null,
            null
          );
        (this.unique = unique), this.keyModified.set("unique", 1);
      }
      getHistoryTracking() {
        return this.historyTracking;
      }
      setHistoryTracking(historyTracking) {
        if (
          null != historyTracking &&
          "[object Boolean]" != Object.prototype.toString.call(historyTracking)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: historyTracking EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.historyTracking = historyTracking),
          this.keyModified.set("history_tracking", 1);
      }
      getDataType() {
        return this.dataType;
      }
      setDataType(dataType) {
        if (
          null != dataType &&
          "[object String]" != Object.prototype.toString.call(dataType)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: dataType EXPECTED TYPE: String",
            null,
            null
          );
        (this.dataType = dataType), this.keyModified.set("data_type", 1);
      }
      getFormula() {
        return this.formula;
      }
      setFormula(formula) {
        if (null != formula && !(formula instanceof ZCRM.Field.Model.Formula))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: formula EXPECTED TYPE: Formula",
            null,
            null
          );
        (this.formula = formula), this.keyModified.set("formula", 1);
      }
      getDecimalPlace() {
        return this.decimalPlace;
      }
      setDecimalPlace(decimalPlace) {
        if (
          null != decimalPlace &&
          "[object Number]" != Object.prototype.toString.call(decimalPlace)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: decimalPlace EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.decimalPlace = decimalPlace),
          this.keyModified.set("decimal_place", 1);
      }
      getMassUpdate() {
        return this.massUpdate;
      }
      setMassUpdate(massUpdate) {
        if (
          null != massUpdate &&
          "[object Boolean]" != Object.prototype.toString.call(massUpdate)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: massUpdate EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.massUpdate = massUpdate), this.keyModified.set("mass_update", 1);
      }
      getBlueprintSupported() {
        return this.blueprintSupported;
      }
      setBlueprintSupported(blueprintSupported) {
        if (
          null != blueprintSupported &&
          "[object Boolean]" !=
            Object.prototype.toString.call(blueprintSupported)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: blueprintSupported EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.blueprintSupported = blueprintSupported),
          this.keyModified.set("blueprint_supported", 1);
      }
      getMultiselectlookup() {
        return this.multiselectlookup;
      }
      setMultiselectlookup(multiselectlookup) {
        if (
          null != multiselectlookup &&
          !(multiselectlookup instanceof ZCRM.Field.Model.MultiSelectLookup)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: multiselectlookup EXPECTED TYPE: MultiSelectLookup",
            null,
            null
          );
        (this.multiselectlookup = multiselectlookup),
          this.keyModified.set("multiselectlookup", 1);
      }
      getPickListValues() {
        return this.pickListValues;
      }
      setPickListValues(pickListValues) {
        if (
          null != pickListValues &&
          "[object Array]" != Object.prototype.toString.call(pickListValues)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: pickListValues EXPECTED TYPE: Array",
            null,
            null
          );
        (this.pickListValues = pickListValues),
          this.keyModified.set("pick_list_values", 1);
      }
      getAutoNumber() {
        return this.autoNumber;
      }
      setAutoNumber(autoNumber) {
        if (
          null != autoNumber &&
          !(autoNumber instanceof ZCRM.Field.Model.AutoNumber)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: autoNumber EXPECTED TYPE: AutoNumber",
            null,
            null
          );
        (this.autoNumber = autoNumber), this.keyModified.set("auto_number", 1);
      }
      getDefaultValue() {
        return this.defaultValue;
      }
      setDefaultValue(defaultValue) {
        if (
          null != defaultValue &&
          "[object String]" != Object.prototype.toString.call(defaultValue)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: defaultValue EXPECTED TYPE: String",
            null,
            null
          );
        (this.defaultValue = defaultValue),
          this.keyModified.set("default_value", 1);
      }
      getSectionId() {
        return this.sectionId;
      }
      setSectionId(sectionId) {
        if (
          null != sectionId &&
          "[object Number]" != Object.prototype.toString.call(sectionId)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: sectionId EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.sectionId = sectionId), this.keyModified.set("section_id", 1);
      }
      getValidationRule() {
        return this.validationRule;
      }
      setValidationRule(validationRule) {
        if (
          null != validationRule &&
          "[object Map]" != Object.prototype.toString.call(validationRule)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: validationRule EXPECTED TYPE: Map",
            null,
            null
          );
        (this.validationRule = validationRule),
          this.keyModified.set("validation_rule", 1);
      }
      getConvertMapping() {
        return this.convertMapping;
      }
      setConvertMapping(convertMapping) {
        if (
          null != convertMapping &&
          "[object Map]" != Object.prototype.toString.call(convertMapping)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: convertMapping EXPECTED TYPE: Map",
            null,
            null
          );
        (this.convertMapping = convertMapping),
          this.keyModified.set("convert_mapping", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    Unique: class {
      constructor() {
        (this.casesensitive = null), (this.keyModified = new Map());
      }
      getCasesensitive() {
        return this.casesensitive;
      }
      setCasesensitive(casesensitive) {
        if (
          null != casesensitive &&
          "[object String]" != Object.prototype.toString.call(casesensitive)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: casesensitive EXPECTED TYPE: String",
            null,
            null
          );
        (this.casesensitive = casesensitive),
          this.keyModified.set("casesensitive", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    Crypt: class {
      constructor() {
        (this.mode = null),
          (this.column = null),
          (this.encfldids = null),
          (this.notify = null),
          (this.table = null),
          (this.status = null),
          (this.keyModified = new Map());
      }
      getMode() {
        return this.mode;
      }
      setMode(mode) {
        if (
          null != mode &&
          "[object String]" != Object.prototype.toString.call(mode)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: mode EXPECTED TYPE: String",
            null,
            null
          );
        (this.mode = mode), this.keyModified.set("mode", 1);
      }
      getColumn() {
        return this.column;
      }
      setColumn(column) {
        if (
          null != column &&
          "[object String]" != Object.prototype.toString.call(column)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: column EXPECTED TYPE: String",
            null,
            null
          );
        (this.column = column), this.keyModified.set("column", 1);
      }
      getEncfldids() {
        return this.encfldids;
      }
      setEncfldids(encfldids) {
        if (
          null != encfldids &&
          "[object Array]" != Object.prototype.toString.call(encfldids)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: encfldids EXPECTED TYPE: Array",
            null,
            null
          );
        (this.encfldids = encfldids), this.keyModified.set("encFldIds", 1);
      }
      getNotify() {
        return this.notify;
      }
      setNotify(notify) {
        if (
          null != notify &&
          "[object String]" != Object.prototype.toString.call(notify)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: notify EXPECTED TYPE: String",
            null,
            null
          );
        (this.notify = notify), this.keyModified.set("notify", 1);
      }
      getTable() {
        return this.table;
      }
      setTable(table) {
        if (
          null != table &&
          "[object String]" != Object.prototype.toString.call(table)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: table EXPECTED TYPE: String",
            null,
            null
          );
        (this.table = table), this.keyModified.set("table", 1);
      }
      getStatus() {
        return this.status;
      }
      setStatus(status) {
        if (
          null != status &&
          "[object Number]" != Object.prototype.toString.call(status)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: status EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.status = status), this.keyModified.set("status", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    ViewType: class {
      constructor() {
        (this.view = null),
          (this.edit = null),
          (this.create = null),
          (this.quickCreate = null),
          (this.keyModified = new Map());
      }
      getView() {
        return this.view;
      }
      setView(view) {
        if (
          null != view &&
          "[object Boolean]" != Object.prototype.toString.call(view)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: view EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.view = view), this.keyModified.set("view", 1);
      }
      getEdit() {
        return this.edit;
      }
      setEdit(edit) {
        if (
          null != edit &&
          "[object Boolean]" != Object.prototype.toString.call(edit)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: edit EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.edit = edit), this.keyModified.set("edit", 1);
      }
      getCreate() {
        return this.create;
      }
      setCreate(create) {
        if (
          null != create &&
          "[object Boolean]" != Object.prototype.toString.call(create)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: create EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.create = create), this.keyModified.set("create", 1);
      }
      getQuickCreate() {
        return this.quickCreate;
      }
      setQuickCreate(quickCreate) {
        if (
          null != quickCreate &&
          "[object Boolean]" != Object.prototype.toString.call(quickCreate)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: quickCreate EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.quickCreate = quickCreate),
          this.keyModified.set("quick_create", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    AutoNumber: class {
      constructor() {
        (this.prefix = null),
          (this.suffix = null),
          (this.startNumber = null),
          (this.keyModified = new Map());
      }
      getPrefix() {
        return this.prefix;
      }
      setPrefix(prefix) {
        if (
          null != prefix &&
          "[object String]" != Object.prototype.toString.call(prefix)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: prefix EXPECTED TYPE: String",
            null,
            null
          );
        (this.prefix = prefix), this.keyModified.set("prefix", 1);
      }
      getSuffix() {
        return this.suffix;
      }
      setSuffix(suffix) {
        if (
          null != suffix &&
          "[object String]" != Object.prototype.toString.call(suffix)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: suffix EXPECTED TYPE: String",
            null,
            null
          );
        (this.suffix = suffix), this.keyModified.set("suffix", 1);
      }
      getStartNumber() {
        return this.startNumber;
      }
      setStartNumber(startNumber) {
        if (
          null != startNumber &&
          "[object Number]" != Object.prototype.toString.call(startNumber)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: startNumber EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.startNumber = startNumber),
          this.keyModified.set("start_number", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    MultiSelectLookup: class {
      constructor() {
        (this.displayLabel = null),
          (this.linkingModule = null),
          (this.lookupApiname = null),
          (this.apiName = null),
          (this.connectedlookupApiname = null),
          (this.id = null),
          (this.keyModified = new Map());
      }
      getDisplayLabel() {
        return this.displayLabel;
      }
      setDisplayLabel(displayLabel) {
        if (
          null != displayLabel &&
          "[object String]" != Object.prototype.toString.call(displayLabel)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: displayLabel EXPECTED TYPE: String",
            null,
            null
          );
        (this.displayLabel = displayLabel),
          this.keyModified.set("display_label", 1);
      }
      getLinkingModule() {
        return this.linkingModule;
      }
      setLinkingModule(linkingModule) {
        if (
          null != linkingModule &&
          "[object String]" != Object.prototype.toString.call(linkingModule)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: linkingModule EXPECTED TYPE: String",
            null,
            null
          );
        (this.linkingModule = linkingModule),
          this.keyModified.set("linking_module", 1);
      }
      getLookupApiname() {
        return this.lookupApiname;
      }
      setLookupApiname(lookupApiname) {
        if (
          null != lookupApiname &&
          "[object String]" != Object.prototype.toString.call(lookupApiname)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: lookupApiname EXPECTED TYPE: String",
            null,
            null
          );
        (this.lookupApiname = lookupApiname),
          this.keyModified.set("lookup_apiname", 1);
      }
      getAPIName() {
        return this.apiName;
      }
      setAPIName(apiName) {
        if (
          null != apiName &&
          "[object String]" != Object.prototype.toString.call(apiName)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: apiName EXPECTED TYPE: String",
            null,
            null
          );
        (this.apiName = apiName), this.keyModified.set("api_name", 1);
      }
      getConnectedlookupApiname() {
        return this.connectedlookupApiname;
      }
      setConnectedlookupApiname(connectedlookupApiname) {
        if (
          null != connectedlookupApiname &&
          "[object String]" !=
            Object.prototype.toString.call(connectedlookupApiname)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: connectedlookupApiname EXPECTED TYPE: String",
            null,
            null
          );
        (this.connectedlookupApiname = connectedlookupApiname),
          this.keyModified.set("connectedlookup_apiname", 1);
      }
      getId() {
        return this.id;
      }
      setId(id) {
        if (
          null != id &&
          "[object BigInt]" != Object.prototype.toString.call(id)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        (this.id = id), this.keyModified.set("id", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    PickListValue: class {
      constructor() {
        (this.displayValue = null),
          (this.sequenceNumber = null),
          (this.expectedDataType = null),
          (this.maps = null),
          (this.actualValue = null),
          (this.sysRefName = null),
          (this.type = null),
          (this.keyModified = new Map());
      }
      getDisplayValue() {
        return this.displayValue;
      }
      setDisplayValue(displayValue) {
        if (
          null != displayValue &&
          "[object String]" != Object.prototype.toString.call(displayValue)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: displayValue EXPECTED TYPE: String",
            null,
            null
          );
        (this.displayValue = displayValue),
          this.keyModified.set("display_value", 1);
      }
      getSequenceNumber() {
        return this.sequenceNumber;
      }
      setSequenceNumber(sequenceNumber) {
        if (
          null != sequenceNumber &&
          "[object Number]" != Object.prototype.toString.call(sequenceNumber)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: sequenceNumber EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.sequenceNumber = sequenceNumber),
          this.keyModified.set("sequence_number", 1);
      }
      getExpectedDataType() {
        return this.expectedDataType;
      }
      setExpectedDataType(expectedDataType) {
        if (
          null != expectedDataType &&
          "[object String]" != Object.prototype.toString.call(expectedDataType)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: expectedDataType EXPECTED TYPE: String",
            null,
            null
          );
        (this.expectedDataType = expectedDataType),
          this.keyModified.set("expected_data_type", 1);
      }
      getMaps() {
        return this.maps;
      }
      setMaps(maps) {
        if (
          null != maps &&
          "[object Array]" != Object.prototype.toString.call(maps)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: maps EXPECTED TYPE: Array",
            null,
            null
          );
        (this.maps = maps), this.keyModified.set("maps", 1);
      }
      getActualValue() {
        return this.actualValue;
      }
      setActualValue(actualValue) {
        if (
          null != actualValue &&
          "[object String]" != Object.prototype.toString.call(actualValue)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: actualValue EXPECTED TYPE: String",
            null,
            null
          );
        (this.actualValue = actualValue),
          this.keyModified.set("actual_value", 1);
      }
      getSysRefName() {
        return this.sysRefName;
      }
      setSysRefName(sysRefName) {
        if (
          null != sysRefName &&
          "[object String]" != Object.prototype.toString.call(sysRefName)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: sysRefName EXPECTED TYPE: String",
            null,
            null
          );
        (this.sysRefName = sysRefName), this.keyModified.set("sys_ref_name", 1);
      }
      getType() {
        return this.type;
      }
      setType(type) {
        if (
          null != type &&
          "[object String]" != Object.prototype.toString.call(type)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: type EXPECTED TYPE: String",
            null,
            null
          );
        (this.type = type), this.keyModified.set("type", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    ResponseWrapper: class {
      constructor() {
        (this.fields = null), (this.keyModified = new Map());
      }
      getFields() {
        return this.fields;
      }
      setFields(fields) {
        if (
          null != fields &&
          "[object Array]" != Object.prototype.toString.call(fields)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: fields EXPECTED TYPE: Array",
            null,
            null
          );
        (this.fields = fields), this.keyModified.set("fields", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    ToolTip: class {
      constructor() {
        (this.name = null), (this.value = null), (this.keyModified = new Map());
      }
      getName() {
        return this.name;
      }
      setName(name) {
        if (
          null != name &&
          "[object String]" != Object.prototype.toString.call(name)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: name EXPECTED TYPE: String",
            null,
            null
          );
        (this.name = name), this.keyModified.set("name", 1);
      }
      getValue() {
        return this.value;
      }
      setValue(value) {
        if (
          null != value &&
          "[object String]" != Object.prototype.toString.call(value)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: value EXPECTED TYPE: String",
            null,
            null
          );
        (this.value = value), this.keyModified.set("value", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    Currency: class {
      constructor() {
        (this.roundingOption = null),
          (this.precision = null),
          (this.keyModified = new Map());
      }
      getRoundingOption() {
        return this.roundingOption;
      }
      setRoundingOption(roundingOption) {
        if (
          null != roundingOption &&
          "[object String]" != Object.prototype.toString.call(roundingOption)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: roundingOption EXPECTED TYPE: String",
            null,
            null
          );
        (this.roundingOption = roundingOption),
          this.keyModified.set("rounding_option", 1);
      }
      getPrecision() {
        return this.precision;
      }
      setPrecision(precision) {
        if (
          null != precision &&
          "[object Number]" != Object.prototype.toString.call(precision)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: precision EXPECTED TYPE: Integer",
            null,
            null
          );
        (this.precision = precision), this.keyModified.set("precision", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    Formula: class {
      constructor() {
        (this.returnType = null),
          (this.expression = null),
          (this.keyModified = new Map());
      }
      getReturnType() {
        return this.returnType;
      }
      setReturnType(returnType) {
        if (
          null != returnType &&
          "[object String]" != Object.prototype.toString.call(returnType)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: returnType EXPECTED TYPE: String",
            null,
            null
          );
        (this.returnType = returnType), this.keyModified.set("return_type", 1);
      }
      getExpression() {
        return this.expression;
      }
      setExpression(expression) {
        if (
          null != expression &&
          "[object String]" != Object.prototype.toString.call(expression)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: expression EXPECTED TYPE: String",
            null,
            null
          );
        (this.expression = expression), this.keyModified.set("expression", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    Private: class {
      constructor() {
        (this.restricted = null),
          (this.export1 = null),
          (this.type = null),
          (this.keyModified = new Map());
      }
      getRestricted() {
        return this.restricted;
      }
      setRestricted(restricted) {
        if (
          null != restricted &&
          "[object Boolean]" != Object.prototype.toString.call(restricted)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: restricted EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.restricted = restricted), this.keyModified.set("restricted", 1);
      }
      getExport() {
        return this.export1;
      }
      setExport(export1) {
        if (
          null != export1 &&
          "[object Boolean]" != Object.prototype.toString.call(export1)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: export1 EXPECTED TYPE: Boolean",
            null,
            null
          );
        (this.export1 = export1), this.keyModified.set("export", 1);
      }
      getType() {
        return this.type;
      }
      setType(type) {
        if (
          null != type &&
          "[object String]" != Object.prototype.toString.call(type)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: type EXPECTED TYPE: String",
            null,
            null
          );
        (this.type = type), this.keyModified.set("type", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    LookupField: class {
      constructor() {
        (this.id = null), (this.name = null), (this.keyModified = new Map());
      }
      getId() {
        return this.id;
      }
      setId(id) {
        if (
          null != id &&
          "[object BigInt]" != Object.prototype.toString.call(id)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        (this.id = id), this.keyModified.set("id", 1);
      }
      getName() {
        return this.name;
      }
      setName(name) {
        if (
          null != name &&
          "[object String]" != Object.prototype.toString.call(name)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: name EXPECTED TYPE: String",
            null,
            null
          );
        (this.name = name), this.keyModified.set("name", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    APIException: class {
      constructor() {
        (this.status = null),
          (this.code = null),
          (this.message = null),
          (this.details = null),
          (this.keyModified = new Map());
      }
      getStatus() {
        return this.status;
      }
      setStatus(status) {
        if (null != status && !(status instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: status EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.status = status), this.keyModified.set("status", 1);
      }
      getCode() {
        return this.code;
      }
      setCode(code) {
        if (null != code && !(code instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: code EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.code = code), this.keyModified.set("code", 1);
      }
      getMessage() {
        return this.message;
      }
      setMessage(message) {
        if (null != message && !(message instanceof Choice))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: message EXPECTED TYPE: Choice",
            null,
            null
          );
        (this.message = message), this.keyModified.set("message", 1);
      }
      getDetails() {
        return this.details;
      }
      setDetails(details) {
        if (
          null != details &&
          "[object Map]" != Object.prototype.toString.call(details)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: details EXPECTED TYPE: Map",
            null,
            null
          );
        (this.details = details), this.keyModified.set("details", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    Module: class {
      constructor() {
        (this.layout = null),
          (this.displayLabel = null),
          (this.apiName = null),
          (this.module = null),
          (this.id = null),
          (this.moduleName = null),
          (this.keyModified = new Map());
      }
      getLayout() {
        return this.layout;
      }
      setLayout(layout) {
        if (null != layout && !(layout instanceof ZCRM.Layout.Model.Layout))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: layout EXPECTED TYPE: Layout",
            null,
            null
          );
        (this.layout = layout), this.keyModified.set("layout", 1);
      }
      getDisplayLabel() {
        return this.displayLabel;
      }
      setDisplayLabel(displayLabel) {
        if (
          null != displayLabel &&
          "[object String]" != Object.prototype.toString.call(displayLabel)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: displayLabel EXPECTED TYPE: String",
            null,
            null
          );
        (this.displayLabel = displayLabel),
          this.keyModified.set("display_label", 1);
      }
      getAPIName() {
        return this.apiName;
      }
      setAPIName(apiName) {
        if (
          null != apiName &&
          "[object String]" != Object.prototype.toString.call(apiName)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: apiName EXPECTED TYPE: String",
            null,
            null
          );
        (this.apiName = apiName), this.keyModified.set("api_name", 1);
      }
      getModule() {
        return this.module;
      }
      setModule(module) {
        if (
          null != module &&
          "[object String]" != Object.prototype.toString.call(module)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: module EXPECTED TYPE: String",
            null,
            null
          );
        (this.module = module), this.keyModified.set("module", 1);
      }
      getId() {
        return this.id;
      }
      setId(id) {
        if (
          null != id &&
          "[object BigInt]" != Object.prototype.toString.call(id)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        (this.id = id), this.keyModified.set("id", 1);
      }
      getModuleName() {
        return this.moduleName;
      }
      setModuleName(moduleName) {
        if (
          null != moduleName &&
          "[object String]" != Object.prototype.toString.call(moduleName)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleName EXPECTED TYPE: String",
            null,
            null
          );
        (this.moduleName = moduleName), this.keyModified.set("module_name", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    AssociationDetails: class {
      constructor() {
        (this.lookupField = null),
          (this.relatedField = null),
          (this.keyModified = new Map());
      }
      getLookupField() {
        return this.lookupField;
      }
      setLookupField(lookupField) {
        if (
          null != lookupField &&
          !(lookupField instanceof ZCRM.Field.Model.LookupField)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: lookupField EXPECTED TYPE: LookupField",
            null,
            null
          );
        (this.lookupField = lookupField),
          this.keyModified.set("lookup_field", 1);
      }
      getRelatedField() {
        return this.relatedField;
      }
      setRelatedField(relatedField) {
        if (
          null != relatedField &&
          !(relatedField instanceof ZCRM.Field.Model.LookupField)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: relatedField EXPECTED TYPE: LookupField",
            null,
            null
          );
        (this.relatedField = relatedField),
          this.keyModified.set("related_field", 1);
      }
      isKeyModified(key) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        return this.keyModified.has(key) ? this.keyModified.get(key) : null;
      }
      setKeyModified(key, modification) {
        if (
          null != key &&
          "[object String]" != Object.prototype.toString.call(key)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: key EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != modification &&
          "[object Number]" != Object.prototype.toString.call(modification)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: modification EXPECTED TYPE: Integer",
            null,
            null
          );
        this.keyModified.set(key, modification);
      }
    },
    GetFieldsParam: { TYPE: new Param("type", "Field.Model.GetFieldsParam") },
    GetFieldParam: {},
  },
  Operations: class {
    constructor(module = null) {
      if (
        null != module &&
        "[object String]" != Object.prototype.toString.call(module)
      )
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: module EXPECTED TYPE: String",
          null,
          null
        );
      this.module = module;
    }
    async getFields(paramInstance = null) {
      if (null != paramInstance && !(paramInstance instanceof ParameterMap))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: paramInstance EXPECTED TYPE: ParameterMap",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = apiPath.concat("/crm/v2/settings/fields")),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
        await handlerInstance.addParam(
          new Param("module", "Field.Model.GetFieldsParam"),
          this.module
        ),
        handlerInstance.setParam(paramInstance),
        handlerInstance.apiCall(
          "Field.Model.ResponseHandler",
          "application/json"
        )
      );
    }
    async getField(id) {
      if ("[object BigInt]" != Object.prototype.toString.call(id))
        throw new SDKException(
          Constants.DATA_TYPE_ERROR,
          "KEY: id EXPECTED TYPE: BigInt",
          null,
          null
        );
      var handlerInstance = new CommonAPIHandler(),
        apiPath = "";
      return (
        (apiPath = (apiPath = apiPath.concat(
          "/crm/v2/settings/fields/"
        )).concat(id.toString())),
        handlerInstance.setAPIPath(apiPath),
        handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
        handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
        await handlerInstance.addParam(
          new Param("module", "Field.Model.GetFieldParam"),
          this.module
        ),
        handlerInstance.apiCall(
          "Field.Model.ResponseHandler",
          "application/json"
        )
      );
    }
  },
}),
  (ZCRM.Profile = {
    Model: {
      ResponseHandler: class {
        constructor() {}
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Category: class {
        constructor() {
          (this.displayLabel = null),
            (this.permissionsDetails = null),
            (this.name = null),
            (this.keyModified = new Map());
        }
        getDisplayLabel() {
          return this.displayLabel;
        }
        setDisplayLabel(displayLabel) {
          if (
            null != displayLabel &&
            "[object String]" != Object.prototype.toString.call(displayLabel)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: displayLabel EXPECTED TYPE: String",
              null,
              null
            );
          (this.displayLabel = displayLabel),
            this.keyModified.set("display_label", 1);
        }
        getPermissionsDetails() {
          return this.permissionsDetails;
        }
        setPermissionsDetails(permissionsDetails) {
          if (
            null != permissionsDetails &&
            "[object Array]" !=
              Object.prototype.toString.call(permissionsDetails)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: permissionsDetails EXPECTED TYPE: Array",
              null,
              null
            );
          (this.permissionsDetails = permissionsDetails),
            this.keyModified.set("permissions_details", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Profile: class {
        constructor() {
          (this.displayLabel = null),
            (this.createdTime = null),
            (this.modifiedTime = null),
            (this.permissionsDetails = null),
            (this.name = null),
            (this.modifiedBy = null),
            (this.default1 = null),
            (this.description = null),
            (this.id = null),
            (this.category = null),
            (this.createdBy = null),
            (this.sections = null),
            (this.delete1 = null),
            (this.keyModified = new Map());
        }
        getDisplayLabel() {
          return this.displayLabel;
        }
        setDisplayLabel(displayLabel) {
          if (
            null != displayLabel &&
            "[object String]" != Object.prototype.toString.call(displayLabel)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: displayLabel EXPECTED TYPE: String",
              null,
              null
            );
          (this.displayLabel = displayLabel),
            this.keyModified.set("display_label", 1);
        }
        getCreatedTime() {
          return this.createdTime;
        }
        setCreatedTime(createdTime) {
          if (null != createdTime && !(createdTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.createdTime = createdTime),
            this.keyModified.set("created_time", 1);
        }
        getModifiedTime() {
          return this.modifiedTime;
        }
        setModifiedTime(modifiedTime) {
          if (null != modifiedTime && !(modifiedTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.modifiedTime = modifiedTime),
            this.keyModified.set("modified_time", 1);
        }
        getPermissionsDetails() {
          return this.permissionsDetails;
        }
        setPermissionsDetails(permissionsDetails) {
          if (
            null != permissionsDetails &&
            "[object Array]" !=
              Object.prototype.toString.call(permissionsDetails)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: permissionsDetails EXPECTED TYPE: Array",
              null,
              null
            );
          (this.permissionsDetails = permissionsDetails),
            this.keyModified.set("permissions_details", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getModifiedBy() {
          return this.modifiedBy;
        }
        setModifiedBy(modifiedBy) {
          if (
            null != modifiedBy &&
            !(modifiedBy instanceof ZCRM.User.Model.User)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.modifiedBy = modifiedBy),
            this.keyModified.set("modified_by", 1);
        }
        getDefault() {
          return this.default1;
        }
        setDefault(default1) {
          if (
            null != default1 &&
            "[object Boolean]" != Object.prototype.toString.call(default1)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: default1 EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.default1 = default1), this.keyModified.set("default", 1);
        }
        getDescription() {
          return this.description;
        }
        setDescription(description) {
          if (
            null != description &&
            "[object String]" != Object.prototype.toString.call(description)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: description EXPECTED TYPE: String",
              null,
              null
            );
          (this.description = description),
            this.keyModified.set("description", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getCategory() {
          return this.category;
        }
        setCategory(category) {
          if (
            null != category &&
            "[object Boolean]" != Object.prototype.toString.call(category)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: category EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.category = category), this.keyModified.set("category", 1);
        }
        getCreatedBy() {
          return this.createdBy;
        }
        setCreatedBy(createdBy) {
          if (null != createdBy && !(createdBy instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.createdBy = createdBy), this.keyModified.set("created_by", 1);
        }
        getSections() {
          return this.sections;
        }
        setSections(sections) {
          if (
            null != sections &&
            "[object Array]" != Object.prototype.toString.call(sections)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sections EXPECTED TYPE: Array",
              null,
              null
            );
          (this.sections = sections), this.keyModified.set("sections", 1);
        }
        getDelete() {
          return this.delete1;
        }
        setDelete(delete1) {
          if (
            null != delete1 &&
            "[object Boolean]" != Object.prototype.toString.call(delete1)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: delete1 EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.delete1 = delete1), this.keyModified.set("_delete", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      PermissionDetail: class {
        constructor() {
          (this.displayLabel = null),
            (this.module = null),
            (this.name = null),
            (this.id = null),
            (this.enabled = null),
            (this.keyModified = new Map());
        }
        getDisplayLabel() {
          return this.displayLabel;
        }
        setDisplayLabel(displayLabel) {
          if (
            null != displayLabel &&
            "[object String]" != Object.prototype.toString.call(displayLabel)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: displayLabel EXPECTED TYPE: String",
              null,
              null
            );
          (this.displayLabel = displayLabel),
            this.keyModified.set("display_label", 1);
        }
        getModule() {
          return this.module;
        }
        setModule(module) {
          if (
            null != module &&
            "[object String]" != Object.prototype.toString.call(module)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: module EXPECTED TYPE: String",
              null,
              null
            );
          (this.module = module), this.keyModified.set("module", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getEnabled() {
          return this.enabled;
        }
        setEnabled(enabled) {
          if (
            null != enabled &&
            "[object Boolean]" != Object.prototype.toString.call(enabled)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: enabled EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.enabled = enabled), this.keyModified.set("enabled", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Section: class {
        constructor() {
          (this.name = null),
            (this.categories = null),
            (this.keyModified = new Map());
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getCategories() {
          return this.categories;
        }
        setCategories(categories) {
          if (
            null != categories &&
            "[object Array]" != Object.prototype.toString.call(categories)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: categories EXPECTED TYPE: Array",
              null,
              null
            );
          (this.categories = categories), this.keyModified.set("categories", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.profiles = null), (this.keyModified = new Map());
        }
        getProfiles() {
          return this.profiles;
        }
        setProfiles(profiles) {
          if (
            null != profiles &&
            "[object Array]" != Object.prototype.toString.call(profiles)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: profiles EXPECTED TYPE: Array",
              null,
              null
            );
          (this.profiles = profiles), this.keyModified.set("profiles", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      GetProfilesHeader: {},
      GetProfileHeader: {},
    },
    Operations: class {
      constructor(ifModifiedSince = null) {
        if (null != ifModifiedSince && !(ifModifiedSince instanceof Date))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: ifModifiedSince EXPECTED TYPE: Date",
            null,
            null
          );
        this.ifModifiedSince = ifModifiedSince;
      }
      async getProfiles() {
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/profiles")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addHeader(
            new Header("If-Modified-Since", "Profile.Model.GetProfilesHeader"),
            this.ifModifiedSince
          ),
          handlerInstance.apiCall(
            "Profile.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async getProfile(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/profiles/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          await handlerInstance.addHeader(
            new Header("If-Modified-Since", "Profile.Model.GetProfileHeader"),
            this.ifModifiedSince
          ),
          handlerInstance.apiCall(
            "Profile.Model.ResponseHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.ShareRecord = {
    Model: {
      ActionHandler: class {
        constructor() {}
      },
      DeleteActionResponse: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      DeleteActionHandler: class {
        constructor() {}
      },
      ActionResponse: class {
        constructor() {}
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SharedThrough: class {
        constructor() {
          (this.module = null),
            (this.id = null),
            (this.entityName = null),
            (this.keyModified = new Map());
        }
        getModule() {
          return this.module;
        }
        setModule(module) {
          if (null != module && !(module instanceof ZCRM.Module.Model.Module))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: module EXPECTED TYPE: Module",
              null,
              null
            );
          (this.module = module), this.keyModified.set("module", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getEntityName() {
          return this.entityName;
        }
        setEntityName(entityName) {
          if (
            null != entityName &&
            "[object String]" != Object.prototype.toString.call(entityName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: entityName EXPECTED TYPE: String",
              null,
              null
            );
          (this.entityName = entityName),
            this.keyModified.set("entity_name", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.share = null),
            (this.shareableUser = null),
            (this.keyModified = new Map());
        }
        getShare() {
          return this.share;
        }
        setShare(share) {
          if (
            null != share &&
            "[object Array]" != Object.prototype.toString.call(share)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: share EXPECTED TYPE: Array",
              null,
              null
            );
          (this.share = share), this.keyModified.set("share", 1);
        }
        getShareableUser() {
          return this.shareableUser;
        }
        setShareableUser(shareableUser) {
          if (
            null != shareableUser &&
            "[object Array]" != Object.prototype.toString.call(shareableUser)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: shareableUser EXPECTED TYPE: Array",
              null,
              null
            );
          (this.shareableUser = shareableUser),
            this.keyModified.set("shareable_user", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ShareRecord: class {
        constructor() {
          (this.shareRelatedRecords = null),
            (this.sharedThrough = null),
            (this.sharedTime = null),
            (this.permission = null),
            (this.sharedBy = null),
            (this.user = null),
            (this.keyModified = new Map());
        }
        getShareRelatedRecords() {
          return this.shareRelatedRecords;
        }
        setShareRelatedRecords(shareRelatedRecords) {
          if (
            null != shareRelatedRecords &&
            "[object Boolean]" !=
              Object.prototype.toString.call(shareRelatedRecords)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: shareRelatedRecords EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.shareRelatedRecords = shareRelatedRecords),
            this.keyModified.set("share_related_records", 1);
        }
        getSharedThrough() {
          return this.sharedThrough;
        }
        setSharedThrough(sharedThrough) {
          if (
            null != sharedThrough &&
            !(sharedThrough instanceof ZCRM.ShareRecord.Model.SharedThrough)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sharedThrough EXPECTED TYPE: SharedThrough",
              null,
              null
            );
          (this.sharedThrough = sharedThrough),
            this.keyModified.set("shared_through", 1);
        }
        getSharedTime() {
          return this.sharedTime;
        }
        setSharedTime(sharedTime) {
          if (null != sharedTime && !(sharedTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sharedTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.sharedTime = sharedTime),
            this.keyModified.set("shared_time", 1);
        }
        getPermission() {
          return this.permission;
        }
        setPermission(permission) {
          if (
            null != permission &&
            "[object String]" != Object.prototype.toString.call(permission)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: permission EXPECTED TYPE: String",
              null,
              null
            );
          (this.permission = permission), this.keyModified.set("permission", 1);
        }
        getSharedBy() {
          return this.sharedBy;
        }
        setSharedBy(sharedBy) {
          if (null != sharedBy && !(sharedBy instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sharedBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.sharedBy = sharedBy), this.keyModified.set("shared_by", 1);
        }
        getUser() {
          return this.user;
        }
        setUser(user) {
          if (null != user && !(user instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: user EXPECTED TYPE: User",
              null,
              null
            );
          (this.user = user), this.keyModified.set("user", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      DeleteActionWrapper: class {
        constructor() {
          (this.share = null), (this.keyModified = new Map());
        }
        getShare() {
          return this.share;
        }
        setShare(share) {
          (this.share = share), this.keyModified.set("share", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.share = null), (this.keyModified = new Map());
        }
        getShare() {
          return this.share;
        }
        setShare(share) {
          if (
            null != share &&
            "[object Array]" != Object.prototype.toString.call(share)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: share EXPECTED TYPE: Array",
              null,
              null
            );
          (this.share = share), this.keyModified.set("share", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ActionWrapper: class {
        constructor() {
          (this.share = null), (this.keyModified = new Map());
        }
        getShare() {
          return this.share;
        }
        setShare(share) {
          if (
            null != share &&
            "[object Array]" != Object.prototype.toString.call(share)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: share EXPECTED TYPE: Array",
              null,
              null
            );
          (this.share = share), this.keyModified.set("share", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      GetSharedRecordDetailsParam: {
        SHAREDTO: new Param(
          "sharedTo",
          "ShareRecord.Model.GetSharedRecordDetailsParam"
        ),
        VIEW: new Param(
          "view",
          "ShareRecord.Model.GetSharedRecordDetailsParam"
        ),
      },
    },
    Operations: class {
      constructor(recordId, moduleAPIName) {
        if ("[object BigInt]" != Object.prototype.toString.call(recordId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: recordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        (this.recordId = recordId), (this.moduleAPIName = moduleAPIName);
      }
      async getSharedRecordDetails(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/actions/share"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "ShareRecord.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async shareRecord(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.ShareRecord.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/actions/share"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "ShareRecord.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async updateSharePermissions(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.ShareRecord.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/actions/share"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "ShareRecord.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async revokeSharedRecord() {
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/actions/share"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.apiCall(
            "ShareRecord.Model.DeleteActionHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.Query = {
    Model: {
      ResponseHandler: class {
        constructor() {}
      },
      ResponseWrapper: class {
        constructor() {
          (this.data = null),
            (this.info = null),
            (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (null != info && !(info instanceof ZCRM.Record.Model.Info))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Info",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.selectQuery = null), (this.keyModified = new Map());
        }
        getSelectQuery() {
          return this.selectQuery;
        }
        setSelectQuery(selectQuery) {
          if (
            null != selectQuery &&
            "[object String]" != Object.prototype.toString.call(selectQuery)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: selectQuery EXPECTED TYPE: String",
              null,
              null
            );
          (this.selectQuery = selectQuery),
            this.keyModified.set("select_query", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
    },
    Operations: class {
      constructor() {}
      async getRecords(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.Query.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/coql")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "Query.Model.ResponseHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.Attachment = {
    Model: {
      ActionResponse: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      ActionHandler: class {
        constructor() {}
      },
      SuccessResponse: class {
        constructor() {
          (this.code = null),
            (this.details = null),
            (this.message = null),
            (this.status = null),
            (this.keyModified = new Map());
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Attachment: class {
        constructor() {
          (this.owner = null),
            (this.modifiedTime = null),
            (this.fileName = null),
            (this.createdTime = null),
            (this.size = null),
            (this.parentId = null),
            (this.editable = null),
            (this.fileId = null),
            (this.type = null),
            (this.seModule = null),
            (this.modifiedBy = null),
            (this.state = null),
            (this.id = null),
            (this.createdBy = null),
            (this.linkUrl = null),
            (this.description = null),
            (this.category = null),
            (this.keyModified = new Map());
        }
        getOwner() {
          return this.owner;
        }
        setOwner(owner) {
          if (null != owner && !(owner instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: owner EXPECTED TYPE: User",
              null,
              null
            );
          (this.owner = owner), this.keyModified.set("Owner", 1);
        }
        getModifiedTime() {
          return this.modifiedTime;
        }
        setModifiedTime(modifiedTime) {
          if (null != modifiedTime && !(modifiedTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.modifiedTime = modifiedTime),
            this.keyModified.set("Modified_Time", 1);
        }
        getFileName() {
          return this.fileName;
        }
        setFileName(fileName) {
          if (
            null != fileName &&
            "[object String]" != Object.prototype.toString.call(fileName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fileName EXPECTED TYPE: String",
              null,
              null
            );
          (this.fileName = fileName), this.keyModified.set("File_Name", 1);
        }
        getCreatedTime() {
          return this.createdTime;
        }
        setCreatedTime(createdTime) {
          if (null != createdTime && !(createdTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.createdTime = createdTime),
            this.keyModified.set("Created_Time", 1);
        }
        getSize() {
          return this.size;
        }
        setSize(size) {
          if (
            null != size &&
            "[object BigInt]" != Object.prototype.toString.call(size)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: size EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.size = size), this.keyModified.set("Size", 1);
        }
        getParentId() {
          return this.parentId;
        }
        setParentId(parentId) {
          if (
            null != parentId &&
            !(parentId instanceof ZCRM.Record.Model.Record)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: parentId EXPECTED TYPE: Record",
              null,
              null
            );
          (this.parentId = parentId), this.keyModified.set("Parent_Id", 1);
        }
        getEditable() {
          return this.editable;
        }
        setEditable(editable) {
          if (
            null != editable &&
            "[object Boolean]" != Object.prototype.toString.call(editable)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: editable EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.editable = editable), this.keyModified.set("$editable", 1);
        }
        getFileId() {
          return this.fileId;
        }
        setFileId(fileId) {
          if (
            null != fileId &&
            "[object String]" != Object.prototype.toString.call(fileId)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fileId EXPECTED TYPE: String",
              null,
              null
            );
          (this.fileId = fileId), this.keyModified.set("$file_id", 1);
        }
        getType() {
          return this.type;
        }
        setType(type) {
          if (
            null != type &&
            "[object String]" != Object.prototype.toString.call(type)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: type EXPECTED TYPE: String",
              null,
              null
            );
          (this.type = type), this.keyModified.set("$type", 1);
        }
        getSeModule() {
          return this.seModule;
        }
        setSeModule(seModule) {
          if (
            null != seModule &&
            "[object String]" != Object.prototype.toString.call(seModule)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: seModule EXPECTED TYPE: String",
              null,
              null
            );
          (this.seModule = seModule), this.keyModified.set("$se_module", 1);
        }
        getModifiedBy() {
          return this.modifiedBy;
        }
        setModifiedBy(modifiedBy) {
          if (
            null != modifiedBy &&
            !(modifiedBy instanceof ZCRM.User.Model.User)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.modifiedBy = modifiedBy),
            this.keyModified.set("Modified_By", 1);
        }
        getState() {
          return this.state;
        }
        setState(state) {
          if (
            null != state &&
            "[object String]" != Object.prototype.toString.call(state)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: state EXPECTED TYPE: String",
              null,
              null
            );
          (this.state = state), this.keyModified.set("$state", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getCreatedBy() {
          return this.createdBy;
        }
        setCreatedBy(createdBy) {
          if (null != createdBy && !(createdBy instanceof ZCRM.User.Model.User))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: createdBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.createdBy = createdBy), this.keyModified.set("Created_By", 1);
        }
        getLinkUrl() {
          return this.linkUrl;
        }
        setLinkUrl(linkUrl) {
          if (
            null != linkUrl &&
            "[object String]" != Object.prototype.toString.call(linkUrl)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: linkUrl EXPECTED TYPE: String",
              null,
              null
            );
          (this.linkUrl = linkUrl), this.keyModified.set("$link_url", 1);
        }
        getDescription() {
          return this.description;
        }
        setDescription(description) {
          if (
            null != description &&
            "[object String]" != Object.prototype.toString.call(description)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: description EXPECTED TYPE: String",
              null,
              null
            );
          (this.description = description),
            this.keyModified.set("description", 1);
        }
        getCategory() {
          return this.category;
        }
        setCategory(category) {
          if (
            null != category &&
            "[object String]" != Object.prototype.toString.call(category)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: category EXPECTED TYPE: String",
              null,
              null
            );
          (this.category = category), this.keyModified.set("category", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ActionWrapper: class {
        constructor() {
          (this.data = null), (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.data = null),
            (this.info = null),
            (this.keyModified = new Map());
        }
        getData() {
          return this.data;
        }
        setData(data) {
          if (
            null != data &&
            "[object Array]" != Object.prototype.toString.call(data)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: data EXPECTED TYPE: Array",
              null,
              null
            );
          (this.data = data), this.keyModified.set("data", 1);
        }
        getInfo() {
          return this.info;
        }
        setInfo(info) {
          if (null != info && !(info instanceof ZCRM.Record.Model.Info))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: info EXPECTED TYPE: Info",
              null,
              null
            );
          (this.info = info), this.keyModified.set("info", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      FileBodyWrapper: class {
        constructor() {
          (this.file = null), (this.keyModified = new Map());
        }
        getFile() {
          return this.file;
        }
        setFile(file) {
          if (
            null != file &&
            !(file instanceof StreamWrapper.Model.StreamWrapper)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: file EXPECTED TYPE: StreamWrapper",
              null,
              null
            );
          (this.file = file), this.keyModified.set("file", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      DeleteAttachmentsParam: {
        IDS: new Param("ids", "Attachment.Model.DeleteAttachmentsParam"),
      },
      UploadLinkAttachmentParam: {
        ATTACHMENTURL: new Param(
          "attachmentUrl",
          "Attachment.Model.UploadLinkAttachmentParam"
        ),
      },
      GetAttachmentsParam: {
        FIELDS: new Param("fields", "Attachment.Model.GetAttachmentsParam"),
        PAGE: new Param("page", "Attachment.Model.GetAttachmentsParam"),
        PER_PAGE: new Param("per_page", "Attachment.Model.GetAttachmentsParam"),
      },
    },
    Operations: class {
      constructor(moduleAPIName, recordId) {
        if ("[object String]" != Object.prototype.toString.call(moduleAPIName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: moduleAPIName EXPECTED TYPE: String",
            null,
            null
          );
        if ("[object BigInt]" != Object.prototype.toString.call(recordId))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: recordId EXPECTED TYPE: BigInt",
            null,
            null
          );
        (this.moduleAPIName = moduleAPIName), (this.recordId = recordId);
      }
      async downloadAttachment(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/Attachments/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "Attachment.Model.ResponseHandler",
            "application/x-download"
          )
        );
      }
      async deleteAttachment(id) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/Attachments/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.apiCall(
            "Attachment.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async getAttachments(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/Attachments"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Attachment.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async uploadAttachment(request) {
        if (
          null != request &&
          !(request instanceof ZCRM.Attachment.Model.FileBodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: FileBodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/Attachments"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setContentType("multipart/form-data"),
          handlerInstance.setRequest(request),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.apiCall(
            "Attachment.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async uploadLinkAttachment(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/Attachments"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_POST),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_CREATE),
          handlerInstance.setMandatoryChecker(!0),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Attachment.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async deleteAttachments(paramInstance = null) {
        if (null != paramInstance && !(paramInstance instanceof ParameterMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: paramInstance EXPECTED TYPE: ParameterMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = (apiPath = (apiPath = (apiPath =
            apiPath.concat("/crm/v2/")).concat(
            this.moduleAPIName.toString()
          )).concat("/")).concat(this.recordId.toString())).concat(
            "/Attachments"
          )),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setCategoryMethod(Constants.REQUEST_METHOD_DELETE),
          handlerInstance.setParam(paramInstance),
          handlerInstance.apiCall(
            "Attachment.Model.ActionHandler",
            "application/json"
          )
        );
      }
    },
  }),
  (ZCRM.Module = {
    Model: {
      ActionResponse: class {
        constructor() {}
      },
      ActionHandler: class {
        constructor() {}
      },
      ResponseHandler: class {
        constructor() {}
      },
      Module: class {
        constructor() {
          (this.name = null),
            (this.globalSearchSupported = null),
            (this.kanbanView = null),
            (this.deletable = null),
            (this.description = null),
            (this.creatable = null),
            (this.filterStatus = null),
            (this.inventoryTemplateSupported = null),
            (this.modifiedTime = null),
            (this.pluralLabel = null),
            (this.presenceSubMenu = null),
            (this.triggersSupported = null),
            (this.id = null),
            (this.relatedListProperties = null),
            (this.properties = null),
            (this.perPage = null),
            (this.visibility = null),
            (this.convertable = null),
            (this.editable = null),
            (this.emailtemplateSupport = null),
            (this.profiles = null),
            (this.filterSupported = null),
            (this.displayField = null),
            (this.searchLayoutFields = null),
            (this.kanbanViewSupported = null),
            (this.showAsTab = null),
            (this.webLink = null),
            (this.sequenceNumber = null),
            (this.singularLabel = null),
            (this.viewable = null),
            (this.apiSupported = null),
            (this.apiName = null),
            (this.quickCreate = null),
            (this.modifiedBy = null),
            (this.generatedType = null),
            (this.feedsRequired = null),
            (this.scoringSupported = null),
            (this.webformSupported = null),
            (this.arguments1 = null),
            (this.moduleName = null),
            (this.businessCardFieldLimit = null),
            (this.customView = null),
            (this.parentModule = null),
            (this.territory = null),
            (this.keyModified = new Map());
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getGlobalSearchSupported() {
          return this.globalSearchSupported;
        }
        setGlobalSearchSupported(globalSearchSupported) {
          if (
            null != globalSearchSupported &&
            "[object Boolean]" !=
              Object.prototype.toString.call(globalSearchSupported)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: globalSearchSupported EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.globalSearchSupported = globalSearchSupported),
            this.keyModified.set("global_search_supported", 1);
        }
        getKanbanView() {
          return this.kanbanView;
        }
        setKanbanView(kanbanView) {
          if (
            null != kanbanView &&
            "[object Boolean]" != Object.prototype.toString.call(kanbanView)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: kanbanView EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.kanbanView = kanbanView),
            this.keyModified.set("kanban_view", 1);
        }
        getDeletable() {
          return this.deletable;
        }
        setDeletable(deletable) {
          if (
            null != deletable &&
            "[object Boolean]" != Object.prototype.toString.call(deletable)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: deletable EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.deletable = deletable), this.keyModified.set("deletable", 1);
        }
        getDescription() {
          return this.description;
        }
        setDescription(description) {
          if (
            null != description &&
            "[object String]" != Object.prototype.toString.call(description)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: description EXPECTED TYPE: String",
              null,
              null
            );
          (this.description = description),
            this.keyModified.set("description", 1);
        }
        getCreatable() {
          return this.creatable;
        }
        setCreatable(creatable) {
          if (
            null != creatable &&
            "[object Boolean]" != Object.prototype.toString.call(creatable)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: creatable EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.creatable = creatable), this.keyModified.set("creatable", 1);
        }
        getFilterStatus() {
          return this.filterStatus;
        }
        setFilterStatus(filterStatus) {
          if (
            null != filterStatus &&
            "[object Boolean]" != Object.prototype.toString.call(filterStatus)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: filterStatus EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.filterStatus = filterStatus),
            this.keyModified.set("filter_status", 1);
        }
        getInventoryTemplateSupported() {
          return this.inventoryTemplateSupported;
        }
        setInventoryTemplateSupported(inventoryTemplateSupported) {
          if (
            null != inventoryTemplateSupported &&
            "[object Boolean]" !=
              Object.prototype.toString.call(inventoryTemplateSupported)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: inventoryTemplateSupported EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.inventoryTemplateSupported = inventoryTemplateSupported),
            this.keyModified.set("inventory_template_supported", 1);
        }
        getModifiedTime() {
          return this.modifiedTime;
        }
        setModifiedTime(modifiedTime) {
          if (null != modifiedTime && !(modifiedTime instanceof Date))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedTime EXPECTED TYPE: Date",
              null,
              null
            );
          (this.modifiedTime = modifiedTime),
            this.keyModified.set("modified_time", 1);
        }
        getPluralLabel() {
          return this.pluralLabel;
        }
        setPluralLabel(pluralLabel) {
          if (
            null != pluralLabel &&
            "[object String]" != Object.prototype.toString.call(pluralLabel)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: pluralLabel EXPECTED TYPE: String",
              null,
              null
            );
          (this.pluralLabel = pluralLabel),
            this.keyModified.set("plural_label", 1);
        }
        getPresenceSubMenu() {
          return this.presenceSubMenu;
        }
        setPresenceSubMenu(presenceSubMenu) {
          if (
            null != presenceSubMenu &&
            "[object Boolean]" !=
              Object.prototype.toString.call(presenceSubMenu)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: presenceSubMenu EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.presenceSubMenu = presenceSubMenu),
            this.keyModified.set("presence_sub_menu", 1);
        }
        getTriggersSupported() {
          return this.triggersSupported;
        }
        setTriggersSupported(triggersSupported) {
          if (
            null != triggersSupported &&
            "[object Boolean]" !=
              Object.prototype.toString.call(triggersSupported)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: triggersSupported EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.triggersSupported = triggersSupported),
            this.keyModified.set("triggers_supported", 1);
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getRelatedListProperties() {
          return this.relatedListProperties;
        }
        setRelatedListProperties(relatedListProperties) {
          if (
            null != relatedListProperties &&
            !(
              relatedListProperties instanceof
              ZCRM.Module.Model.RelatedListProperties
            )
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: relatedListProperties EXPECTED TYPE: RelatedListProperties",
              null,
              null
            );
          (this.relatedListProperties = relatedListProperties),
            this.keyModified.set("related_list_properties", 1);
        }
        getProperties() {
          return this.properties;
        }
        setProperties(properties) {
          if (
            null != properties &&
            "[object Array]" != Object.prototype.toString.call(properties)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: properties EXPECTED TYPE: Array",
              null,
              null
            );
          (this.properties = properties),
            this.keyModified.set("$properties", 1);
        }
        getPerPage() {
          return this.perPage;
        }
        setPerPage(perPage) {
          if (
            null != perPage &&
            "[object Number]" != Object.prototype.toString.call(perPage)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: perPage EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.perPage = perPage), this.keyModified.set("per_page", 1);
        }
        getVisibility() {
          return this.visibility;
        }
        setVisibility(visibility) {
          if (
            null != visibility &&
            "[object Number]" != Object.prototype.toString.call(visibility)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: visibility EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.visibility = visibility), this.keyModified.set("visibility", 1);
        }
        getConvertable() {
          return this.convertable;
        }
        setConvertable(convertable) {
          if (
            null != convertable &&
            "[object Boolean]" != Object.prototype.toString.call(convertable)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: convertable EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.convertable = convertable),
            this.keyModified.set("convertable", 1);
        }
        getEditable() {
          return this.editable;
        }
        setEditable(editable) {
          if (
            null != editable &&
            "[object Boolean]" != Object.prototype.toString.call(editable)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: editable EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.editable = editable), this.keyModified.set("editable", 1);
        }
        getEmailtemplateSupport() {
          return this.emailtemplateSupport;
        }
        setEmailtemplateSupport(emailtemplateSupport) {
          if (
            null != emailtemplateSupport &&
            "[object Boolean]" !=
              Object.prototype.toString.call(emailtemplateSupport)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: emailtemplateSupport EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.emailtemplateSupport = emailtemplateSupport),
            this.keyModified.set("emailTemplate_support", 1);
        }
        getProfiles() {
          return this.profiles;
        }
        setProfiles(profiles) {
          if (
            null != profiles &&
            "[object Array]" != Object.prototype.toString.call(profiles)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: profiles EXPECTED TYPE: Array",
              null,
              null
            );
          (this.profiles = profiles), this.keyModified.set("profiles", 1);
        }
        getFilterSupported() {
          return this.filterSupported;
        }
        setFilterSupported(filterSupported) {
          if (
            null != filterSupported &&
            "[object Boolean]" !=
              Object.prototype.toString.call(filterSupported)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: filterSupported EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.filterSupported = filterSupported),
            this.keyModified.set("filter_supported", 1);
        }
        getDisplayField() {
          return this.displayField;
        }
        setDisplayField(displayField) {
          if (
            null != displayField &&
            "[object String]" != Object.prototype.toString.call(displayField)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: displayField EXPECTED TYPE: String",
              null,
              null
            );
          (this.displayField = displayField),
            this.keyModified.set("display_field", 1);
        }
        getSearchLayoutFields() {
          return this.searchLayoutFields;
        }
        setSearchLayoutFields(searchLayoutFields) {
          if (
            null != searchLayoutFields &&
            "[object Array]" !=
              Object.prototype.toString.call(searchLayoutFields)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: searchLayoutFields EXPECTED TYPE: Array",
              null,
              null
            );
          (this.searchLayoutFields = searchLayoutFields),
            this.keyModified.set("search_layout_fields", 1);
        }
        getKanbanViewSupported() {
          return this.kanbanViewSupported;
        }
        setKanbanViewSupported(kanbanViewSupported) {
          if (
            null != kanbanViewSupported &&
            "[object Boolean]" !=
              Object.prototype.toString.call(kanbanViewSupported)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: kanbanViewSupported EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.kanbanViewSupported = kanbanViewSupported),
            this.keyModified.set("kanban_view_supported", 1);
        }
        getShowAsTab() {
          return this.showAsTab;
        }
        setShowAsTab(showAsTab) {
          if (
            null != showAsTab &&
            "[object Boolean]" != Object.prototype.toString.call(showAsTab)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: showAsTab EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.showAsTab = showAsTab), this.keyModified.set("show_as_tab", 1);
        }
        getWebLink() {
          return this.webLink;
        }
        setWebLink(webLink) {
          if (
            null != webLink &&
            "[object String]" != Object.prototype.toString.call(webLink)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: webLink EXPECTED TYPE: String",
              null,
              null
            );
          (this.webLink = webLink), this.keyModified.set("web_link", 1);
        }
        getSequenceNumber() {
          return this.sequenceNumber;
        }
        setSequenceNumber(sequenceNumber) {
          if (
            null != sequenceNumber &&
            "[object Number]" != Object.prototype.toString.call(sequenceNumber)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sequenceNumber EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.sequenceNumber = sequenceNumber),
            this.keyModified.set("sequence_number", 1);
        }
        getSingularLabel() {
          return this.singularLabel;
        }
        setSingularLabel(singularLabel) {
          if (
            null != singularLabel &&
            "[object String]" != Object.prototype.toString.call(singularLabel)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: singularLabel EXPECTED TYPE: String",
              null,
              null
            );
          (this.singularLabel = singularLabel),
            this.keyModified.set("singular_label", 1);
        }
        getViewable() {
          return this.viewable;
        }
        setViewable(viewable) {
          if (
            null != viewable &&
            "[object Boolean]" != Object.prototype.toString.call(viewable)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: viewable EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.viewable = viewable), this.keyModified.set("viewable", 1);
        }
        getAPISupported() {
          return this.apiSupported;
        }
        setAPISupported(apiSupported) {
          if (
            null != apiSupported &&
            "[object Boolean]" != Object.prototype.toString.call(apiSupported)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiSupported EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.apiSupported = apiSupported),
            this.keyModified.set("api_supported", 1);
        }
        getAPIName() {
          return this.apiName;
        }
        setAPIName(apiName) {
          if (
            null != apiName &&
            "[object String]" != Object.prototype.toString.call(apiName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: apiName EXPECTED TYPE: String",
              null,
              null
            );
          (this.apiName = apiName), this.keyModified.set("api_name", 1);
        }
        getQuickCreate() {
          return this.quickCreate;
        }
        setQuickCreate(quickCreate) {
          if (
            null != quickCreate &&
            "[object Boolean]" != Object.prototype.toString.call(quickCreate)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: quickCreate EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.quickCreate = quickCreate),
            this.keyModified.set("quick_create", 1);
        }
        getModifiedBy() {
          return this.modifiedBy;
        }
        setModifiedBy(modifiedBy) {
          if (
            null != modifiedBy &&
            !(modifiedBy instanceof ZCRM.User.Model.User)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modifiedBy EXPECTED TYPE: User",
              null,
              null
            );
          (this.modifiedBy = modifiedBy),
            this.keyModified.set("modified_by", 1);
        }
        getGeneratedType() {
          return this.generatedType;
        }
        setGeneratedType(generatedType) {
          if (null != generatedType && !(generatedType instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: generatedType EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.generatedType = generatedType),
            this.keyModified.set("generated_type", 1);
        }
        getFeedsRequired() {
          return this.feedsRequired;
        }
        setFeedsRequired(feedsRequired) {
          if (
            null != feedsRequired &&
            "[object Boolean]" != Object.prototype.toString.call(feedsRequired)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: feedsRequired EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.feedsRequired = feedsRequired),
            this.keyModified.set("feeds_required", 1);
        }
        getScoringSupported() {
          return this.scoringSupported;
        }
        setScoringSupported(scoringSupported) {
          if (
            null != scoringSupported &&
            "[object Boolean]" !=
              Object.prototype.toString.call(scoringSupported)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: scoringSupported EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.scoringSupported = scoringSupported),
            this.keyModified.set("scoring_supported", 1);
        }
        getWebformSupported() {
          return this.webformSupported;
        }
        setWebformSupported(webformSupported) {
          if (
            null != webformSupported &&
            "[object Boolean]" !=
              Object.prototype.toString.call(webformSupported)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: webformSupported EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.webformSupported = webformSupported),
            this.keyModified.set("webform_supported", 1);
        }
        getArguments() {
          return this.arguments1;
        }
        setArguments(arguments1) {
          if (
            null != arguments1 &&
            "[object Array]" != Object.prototype.toString.call(arguments1)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: arguments1 EXPECTED TYPE: Array",
              null,
              null
            );
          (this.arguments1 = arguments1), this.keyModified.set("arguments", 1);
        }
        getModuleName() {
          return this.moduleName;
        }
        setModuleName(moduleName) {
          if (
            null != moduleName &&
            "[object String]" != Object.prototype.toString.call(moduleName)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: moduleName EXPECTED TYPE: String",
              null,
              null
            );
          (this.moduleName = moduleName),
            this.keyModified.set("module_name", 1);
        }
        getBusinessCardFieldLimit() {
          return this.businessCardFieldLimit;
        }
        setBusinessCardFieldLimit(businessCardFieldLimit) {
          if (
            null != businessCardFieldLimit &&
            "[object Number]" !=
              Object.prototype.toString.call(businessCardFieldLimit)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: businessCardFieldLimit EXPECTED TYPE: Integer",
              null,
              null
            );
          (this.businessCardFieldLimit = businessCardFieldLimit),
            this.keyModified.set("business_card_field_limit", 1);
        }
        getCustomView() {
          return this.customView;
        }
        setCustomView(customView) {
          if (
            null != customView &&
            !(customView instanceof ZCRM.CustomView.Model.CustomView)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: customView EXPECTED TYPE: CustomView",
              null,
              null
            );
          (this.customView = customView),
            this.keyModified.set("custom_view", 1);
        }
        getParentModule() {
          return this.parentModule;
        }
        setParentModule(parentModule) {
          if (
            null != parentModule &&
            !(parentModule instanceof ZCRM.Module.Model.Module)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: parentModule EXPECTED TYPE: Module",
              null,
              null
            );
          (this.parentModule = parentModule),
            this.keyModified.set("parent_module", 1);
        }
        getTerritory() {
          return this.territory;
        }
        setTerritory(territory) {
          if (
            null != territory &&
            !(territory instanceof ZCRM.Module.Model.Territory)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: territory EXPECTED TYPE: Territory",
              null,
              null
            );
          (this.territory = territory), this.keyModified.set("territory", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Territory: class {
        constructor() {
          (this.id = null),
            (this.name = null),
            (this.subordinates = null),
            (this.keyModified = new Map());
        }
        getId() {
          return this.id;
        }
        setId(id) {
          if (
            null != id &&
            "[object BigInt]" != Object.prototype.toString.call(id)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: id EXPECTED TYPE: BigInt",
              null,
              null
            );
          (this.id = id), this.keyModified.set("id", 1);
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getSubordinates() {
          return this.subordinates;
        }
        setSubordinates(subordinates) {
          if (
            null != subordinates &&
            "[object Boolean]" != Object.prototype.toString.call(subordinates)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: subordinates EXPECTED TYPE: Boolean",
              null,
              null
            );
          (this.subordinates = subordinates),
            this.keyModified.set("subordinates", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      APIException: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      SuccessResponse: class {
        constructor() {
          (this.status = null),
            (this.code = null),
            (this.message = null),
            (this.details = null),
            (this.keyModified = new Map());
        }
        getStatus() {
          return this.status;
        }
        setStatus(status) {
          if (null != status && !(status instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: status EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.status = status), this.keyModified.set("status", 1);
        }
        getCode() {
          return this.code;
        }
        setCode(code) {
          if (null != code && !(code instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: code EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.code = code), this.keyModified.set("code", 1);
        }
        getMessage() {
          return this.message;
        }
        setMessage(message) {
          if (null != message && !(message instanceof Choice))
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: message EXPECTED TYPE: Choice",
              null,
              null
            );
          (this.message = message), this.keyModified.set("message", 1);
        }
        getDetails() {
          return this.details;
        }
        setDetails(details) {
          if (
            null != details &&
            "[object Map]" != Object.prototype.toString.call(details)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: details EXPECTED TYPE: Map",
              null,
              null
            );
          (this.details = details), this.keyModified.set("details", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ActionWrapper: class {
        constructor() {
          (this.modules = null), (this.keyModified = new Map());
        }
        getModules() {
          return this.modules;
        }
        setModules(modules) {
          if (
            null != modules &&
            "[object Array]" != Object.prototype.toString.call(modules)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modules EXPECTED TYPE: Array",
              null,
              null
            );
          (this.modules = modules), this.keyModified.set("modules", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      ResponseWrapper: class {
        constructor() {
          (this.modules = null), (this.keyModified = new Map());
        }
        getModules() {
          return this.modules;
        }
        setModules(modules) {
          if (
            null != modules &&
            "[object Array]" != Object.prototype.toString.call(modules)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modules EXPECTED TYPE: Array",
              null,
              null
            );
          (this.modules = modules), this.keyModified.set("modules", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      Argument: class {
        constructor() {
          (this.name = null),
            (this.value = null),
            (this.keyModified = new Map());
        }
        getName() {
          return this.name;
        }
        setName(name) {
          if (
            null != name &&
            "[object String]" != Object.prototype.toString.call(name)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: name EXPECTED TYPE: String",
              null,
              null
            );
          (this.name = name), this.keyModified.set("name", 1);
        }
        getValue() {
          return this.value;
        }
        setValue(value) {
          if (
            null != value &&
            "[object String]" != Object.prototype.toString.call(value)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: value EXPECTED TYPE: String",
              null,
              null
            );
          (this.value = value), this.keyModified.set("value", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      RelatedListProperties: class {
        constructor() {
          (this.sortBy = null),
            (this.fields = null),
            (this.sortOrder = null),
            (this.keyModified = new Map());
        }
        getSortBy() {
          return this.sortBy;
        }
        setSortBy(sortBy) {
          if (
            null != sortBy &&
            "[object String]" != Object.prototype.toString.call(sortBy)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sortBy EXPECTED TYPE: String",
              null,
              null
            );
          (this.sortBy = sortBy), this.keyModified.set("sort_by", 1);
        }
        getFields() {
          return this.fields;
        }
        setFields(fields) {
          if (
            null != fields &&
            "[object Array]" != Object.prototype.toString.call(fields)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: fields EXPECTED TYPE: Array",
              null,
              null
            );
          (this.fields = fields), this.keyModified.set("fields", 1);
        }
        getSortOrder() {
          return this.sortOrder;
        }
        setSortOrder(sortOrder) {
          if (
            null != sortOrder &&
            "[object String]" != Object.prototype.toString.call(sortOrder)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: sortOrder EXPECTED TYPE: String",
              null,
              null
            );
          (this.sortOrder = sortOrder), this.keyModified.set("sort_order", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      BodyWrapper: class {
        constructor() {
          (this.modules = null), (this.keyModified = new Map());
        }
        getModules() {
          return this.modules;
        }
        setModules(modules) {
          if (
            null != modules &&
            "[object Array]" != Object.prototype.toString.call(modules)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modules EXPECTED TYPE: Array",
              null,
              null
            );
          (this.modules = modules), this.keyModified.set("modules", 1);
        }
        isKeyModified(key) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          return this.keyModified.has(key) ? this.keyModified.get(key) : null;
        }
        setKeyModified(key, modification) {
          if (
            null != key &&
            "[object String]" != Object.prototype.toString.call(key)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: key EXPECTED TYPE: String",
              null,
              null
            );
          if (
            null != modification &&
            "[object Number]" != Object.prototype.toString.call(modification)
          )
            throw new SDKException(
              Constants.DATA_TYPE_ERROR,
              "KEY: modification EXPECTED TYPE: Integer",
              null,
              null
            );
          this.keyModified.set(key, modification);
        }
      },
      GetModulesHeader: {
        IF_MODIFIED_SINCE: new Header(
          "If-Modified-Since",
          "Module.Model.GetModulesHeader"
        ),
      },
    },
    Operations: class {
      constructor() {}
      async getModules(headerInstance = null) {
        if (null != headerInstance && !(headerInstance instanceof HeaderMap))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: headerInstance EXPECTED TYPE: HeaderMap",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = apiPath.concat("/crm/v2/settings/modules")),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.setHeader(headerInstance),
          handlerInstance.apiCall(
            "Module.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async getModule(apiName) {
        if ("[object String]" != Object.prototype.toString.call(apiName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: apiName EXPECTED TYPE: String",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/modules/"
          )).concat(apiName.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_GET),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_READ),
          handlerInstance.apiCall(
            "Module.Model.ResponseHandler",
            "application/json"
          )
        );
      }
      async updateModuleByAPIName(apiName, request) {
        if ("[object String]" != Object.prototype.toString.call(apiName))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: apiName EXPECTED TYPE: String",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Module.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/modules/"
          )).concat(apiName.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.apiCall(
            "Module.Model.ActionHandler",
            "application/json"
          )
        );
      }
      async updateModuleById(id, request) {
        if ("[object BigInt]" != Object.prototype.toString.call(id))
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: id EXPECTED TYPE: BigInt",
            null,
            null
          );
        if (
          null != request &&
          !(request instanceof ZCRM.Module.Model.BodyWrapper)
        )
          throw new SDKException(
            Constants.DATA_TYPE_ERROR,
            "KEY: request EXPECTED TYPE: BodyWrapper",
            null,
            null
          );
        var handlerInstance = new CommonAPIHandler(),
          apiPath = "";
        return (
          (apiPath = (apiPath = apiPath.concat(
            "/crm/v2/settings/modules/"
          )).concat(id.toString())),
          handlerInstance.setAPIPath(apiPath),
          handlerInstance.setHttpMethod(Constants.REQUEST_METHOD_PUT),
          handlerInstance.setCategoryMethod(Constants.REQUEST_CATEGORY_UPDATE),
          handlerInstance.setContentType("application/json"),
          handlerInstance.setRequest(request),
          handlerInstance.apiCall(
            "Module.Model.ActionHandler",
            "application/json"
          )
        );
      }
    },
  });
class SDKException extends Error {
  constructor(code, message, details = null, cause = null) {
    super(),
      (this.code = code),
      (this.message = null === message ? "" : message),
      (this.details = details),
      (this.cause = cause),
      null != this.details &&
        (this.message = this.message + JSON.stringify(this.details)),
      null != this.cause &&
        (this.message = this.message.concat(this.cause.toString()));
  }
}
class Logger {
  getLevel() {
    return this.level;
  }
  static getInstance(level) {
    return new Logger(level);
  }
  constructor(level) {
    this.level = level;
  }
}
var Levels = {
  ALL: Constants.ALL,
  INFO: Constants.INFO,
  DEBUG: Constants.DEBUG,
  WARN: Constants.WARN,
  ERROR: Constants.ERROR,
  OFF: Constants.OFF,
};
class SDKLogger {
  static initialize(logger) {
    this.logger = logger;
  }
  static log(level, message) {
    let date = new Date();
    if (
      this.logger.level != Levels.OFF &&
      (level == this.logger.level || this.logger.level == Levels.ALL)
    )
      switch (level) {
        case "debug":
          console.debug(
            this.logger.level.toUpperCase() +
              " - " +
              date.toString() +
              " : " +
              message
          );
          break;
        case "warn":
          console.warn(
            this.logger.level.toUpperCase() +
              " - " +
              date.toString() +
              " : " +
              message
          );
          break;
        case "error":
          console.error(
            this.logger.level.toUpperCase() +
              " - " +
              date.toString() +
              " : " +
              message
          );
          break;
        default:
          console.info(
            this.logger.level.toUpperCase() +
              " - " +
              date.toString() +
              " : " +
              message
          );
      }
  }
}
